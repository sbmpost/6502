AS65 Assembler for R6502 [1.42].  Copyright 1994-2007, Frank A. Kingswood                                                Page    1
---------------------------------------------------- 6502_functional_test.a65 ----------------------------------------------------

6108 lines read, no errors in pass 1.
                        ;
                        ; 6 5 0 2   F U N C T I O N A L   T E S T
                        ;
                        ; Copyright (C) 2012-2015  Klaus Dormann
                        ;
                        ; This program is free software: you can redistribute it and/or modify
                        ; it under the terms of the GNU General Public License as published by
                        ; the Free Software Foundation, either version 3 of the License, or
                        ; (at your option) any later version.
                        ;
                        ; This program is distributed in the hope that it will be useful,
                        ; but WITHOUT ANY WARRANTY; without even the implied warranty of
                        ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                        ; GNU General Public License for more details.
                        ;
                        ; You should have received a copy of the GNU General Public License
                        ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
                        
                        
                        ; This program is designed to test all opcodes of a 6502 emulator using all
                        ; addressing modes with focus on propper setting of the processor status
                        ; register bits.
                        ; 
                        ; version 04-dec-2017
                        ; contact info at http://2m5.de or email K@2m5.de
                        ;
                        ; assembled with AS65 from http://www.kingswood-consulting.co.uk/assemblers/
                        ; command line switches: -l -m -s2 -w -h0
                        ;                         |  |  |   |  no page headers in listing
                        ;                         |  |  |   wide listing (133 char/col)
                        ;                         |  |  write intel hex file instead of binary
                        ;                         |  expand macros in listing
                        ;                         generate pass2 listing
                        ;
                        ; No IO - should be run from a monitor with access to registers.
                        ; To run load intel hex image with a load command, than alter PC to 400 hex
                        ; (code_segment) and enter a go command.
                        ; Loop on program counter determines error or successful completion of test.
                        ; Check listing for relevant traps (jump/branch *).
                        ; Please note that in early tests some instructions will have to be used before
                        ; they are actually tested!
                        ;
                        ; RESET, NMI or IRQ should not occur and will be trapped if vectors are enabled.
                        ; Tests documented behavior of the original NMOS 6502 only! No unofficial
                        ; opcodes. Additional opcodes of newer versions of the CPU (65C02, 65816) will
                        ; not be tested. Decimal ops will only be tested with valid BCD operands and
                        ; N V Z flags will be ignored.
                        ;
                        ; Debugging hints:
                        ;     Most of the code is written sequentially. if you hit a trap, check the
                        ;   immediately preceeding code for the instruction to be tested. Results are
                        ;   tested first, flags are checked second by pushing them onto the stack and
                        ;   pulling them to the accumulator after the result was checked. The "real"
                        ;   flags are no longer valid for the tested instruction at this time!
                        ;     If the tested instruction was indexed, the relevant index (X or Y) must
                        ;   also be checked. Opposed to the flags, X and Y registers are still valid.
                        ;
                        ; versions:
                        ;   28-jul-2012  1st version distributed for testing
                        ;   29-jul-2012  fixed references to location 0, now #0
                        ;                added license - GPLv3
                        ;   30-jul-2012  added configuration options
                        ;   01-aug-2012  added trap macro to allow user to change error handling
                        ;   01-dec-2012  fixed trap in branch field must be a branch
                        ;   02-mar-2013  fixed PLA flags not tested
                        ;   19-jul-2013  allowed ROM vectors to be loaded when load_data_direct = 0
                        ;                added test sequence check to detect if tests jump their fence
                        ;   23-jul-2013  added RAM integrity check option
                        ;   16-aug-2013  added error report to standard output option
                        ;   13-dec-2014  added binary/decimal opcode table switch test
                        ;   14-dec-2014  improved relative address test
                        ;   23-aug-2015  added option to disable self modifying tests
                        ;   24-aug-2015  all self modifying immediate opcodes now execute in data RAM
                        ;                added small branch offset pretest
                        ;   21-oct-2015  added option to disable decimal mode ADC & SBC tests
                        ;   04-dec-2017  fixed BRK only tested with interrupts enabled
                        ;                added option to skip the remainder of a failing test
                        ;                in report.i65
                        
                        
                        ; C O N F I G U R A T I O N
                        
                        ;ROM_vectors writable (0=no, 1=yes)
                        ;if ROM vectors can not be used interrupts will not be trapped
                        ;as a consequence BRK can not be tested but will be emulated to test RTI
0000 =                  ROM_vectors = 0
                        
                        ;load_data_direct (0=move from code segment, 1=load directly)
                        ;loading directly is preferred but may not be supported by your platform
                        ;0 produces only consecutive object code, 1 is not suitable for a binary image
0001 =                  load_data_direct = 1
                        
                        ;I_flag behavior (0=force enabled, 1=force disabled, 2=prohibit change, 3=allow
                        ;change) 2 requires extra code and is not recommended. SEI & CLI can only be
                        ;tested if you allow changing the interrupt status (I_flag = 3)
0003 =                  I_flag = 3
                        
                        ;configure memory - try to stay away from memory used by the system
                        ;zero_page memory start address, $50 (80) consecutive Bytes required
                        ;                                add 2 if I_flag = 2
                        ;zero_page = $a  
0000 =                  zero_page = $0
                        
                        ;data_segment memory start address, $6A (106) consecutive Bytes required
0200 =                  data_segment = $200  
                            if (data_segment & $ff) != 0
                                ERROR ERROR ERROR low byte of data_segment MUST be $00 !!
                            endif  
                        
                        ;code_segment memory start address, 13kB of consecutive space required
                        ;                                   add 2.5 kB if I_flag = 2
0400 =                  code_segment = $400  
                        
                        ;self modifying code may be disabled to allow running in ROM
                        ;0=part of the code is self modifying and must reside in RAM
                        ;1=tests disabled: branch range
0000 =                  disable_selfmod = 0
                        
                        ;report errors through I/O channel (0=use standard self trap loops, 1=include
                        ;report.i65 as I/O channel, add 3.5 kB)
0000 =                  report = 0
                        
                        ;RAM integrity test option. Checks for undesired RAM writes.
                        ;set lowest non RAM or RAM mirror address page (-1=disable, 0=64k, $40=16k)
                        ;leave disabled if a monitor, OS or background interrupt is allowed to alter RAM
ffff =                  ram_top = -1
                        
                        ;disable test decimal mode ADC & SBC, 0=enable, 1=disable,
                        ;2=disable including decimal flag in processor status
0001 =                  disable_decimal = 1
                        
                                noopt       ;do not take shortcuts
                        
                        ;macros for error & success traps to allow user modification
                        ;example:
                        ;trap    macro
                        ;        jsr my_error_handler
                        ;        endm
                        ;trap_eq macro
                        ;        bne skip\?
                        ;        trap           ;failed equal (zero)
                        ;skip\?
                        ;        endm
                        ;
                        ; my_error_handler should pop the calling address from the stack and report it.
                        ; putting larger portions of code (more than 3 bytes) inside the trap macro
                        ; may lead to branch range problems for some tests.
                            if report = 0
                        trap    macro
                                jmp *           ;failed anyway
                                endm
                        trap_eq macro
                                beq *           ;failed equal (zero)
                                endm
                        trap_ne macro
                                bne *           ;failed not equal (non zero)
                                endm
                        trap_cs macro
                                bcs *           ;failed carry set
                                endm
                        trap_cc macro
                                bcc *           ;failed carry clear
                                endm
                        trap_mi macro
                                bmi *           ;failed minus (bit 7 set)
                                endm
                        trap_pl macro
                                bpl *           ;failed plus (bit 7 clear)
                                endm
                        trap_vs macro
                                bvs *           ;failed overflow set
                                endm
                        trap_vc macro
                                bvc *           ;failed overflow clear
                                endm
                        ; please observe that during the test the stack gets invalidated
                        ; therefore a RTS inside the success macro is not possible
                        success macro
                                jmp *           ;test passed, no errors
                                endm
                            endif
                            if report = 1
                        trap    macro
                                jsr report_error
                                endm
                        trap_eq macro
                                bne skip\?
                                trap           ;failed equal (zero)
                        skip\?
                                endm
                        trap_ne macro
                                beq skip\?
                                trap            ;failed not equal (non zero)
                        skip\?
                                endm
                        trap_cs macro
                                bcc skip\?
                                trap            ;failed carry set
                        skip\?
                                endm
                        trap_cc macro
                                bcs skip\?
                                trap            ;failed carry clear
                        skip\?
                                endm
                        trap_mi macro
                                bpl skip\?
                                trap            ;failed minus (bit 7 set)
                        skip\?
                                endm
                        trap_pl macro
                                bmi skip\?
                                trap            ;failed plus (bit 7 clear)
                        skip\?
                                endm
                        trap_vs macro
                                bvc skip\?
                                trap            ;failed overflow set
                        skip\?
                                endm
                        trap_vc macro
                                bvs skip\?
                                trap            ;failed overflow clear
                        skip\?
                                endm
                        ; please observe that during the test the stack gets invalidated
                        ; therefore a RTS inside the success macro is not possible
                        success macro
                                jsr report_success
                                endm
                            endif
                        
                        
0001 =                  carry   equ %00000001   ;flag bits in status
0002 =                  zero    equ %00000010
0004 =                  intdis  equ %00000100
0008 =                  decmode equ %00001000
0010 =                  break   equ %00010000
0020 =                  reserv  equ %00100000
0040 =                  overfl  equ %01000000
0080 =                  minus   equ %10000000
                        
0001 =                  fc      equ carry
0002 =                  fz      equ zero
0003 =                  fzc     equ carry+zero
0040 =                  fv      equ overfl
0042 =                  fvz     equ overfl+zero
0080 =                  fn      equ minus
0081 =                  fnc     equ minus+carry
0082 =                  fnz     equ minus+zero
0083 =                  fnzc    equ minus+zero+carry
00c0 =                  fnv     equ minus+overfl
                        
0030 =                  fao     equ break+reserv    ;bits always on after PHP, BRK
0034 =                  fai     equ fao+intdis      ;+ forced interrupt disable
0038 =                  faod    equ fao+decmode     ;+ ignore decimal
003c =                  faid    equ fai+decmode     ;+ ignore decimal
00ff =                  m8      equ $ff             ;8 bit mask
00fb =                  m8i     equ $ff&~intdis     ;8 bit mask - interrupt disable
                        
                        ;macros to allow masking of status bits.
                        ;masking test of decimal bit
                        ;masking of interrupt enable/disable on load and compare
                        ;masking of always on bits after PHP or BRK (unused & break) on compare
                            if disable_decimal < 2
                                if I_flag = 0
                        load_flag   macro
                                    lda #\1&m8i         ;force enable interrupts (mask I)
                                    endm
                        cmp_flag    macro
                                    cmp #(\1|fao)&m8i   ;I_flag is always enabled + always on bits
                                    endm
                        eor_flag    macro
                                    eor #(\1&m8i|fao)   ;mask I, invert expected flags + always on bits
                                    endm
                                endif
                                if I_flag = 1
                        load_flag   macro
                                    lda #\1|intdis      ;force disable interrupts
                                    endm
                        cmp_flag    macro
                                    cmp #(\1|fai)&m8    ;I_flag is always disabled + always on bits
                                    endm
                        eor_flag    macro
                                    eor #(\1|fai)       ;invert expected flags + always on bits + I
                                    endm
                                endif
                                if I_flag = 2
                        load_flag   macro
                                    lda #\1
                                    ora flag_I_on       ;restore I-flag
                                    and flag_I_off
                                    endm
                        cmp_flag    macro
                                    eor flag_I_on       ;I_flag is never changed
                                    cmp #(\1|fao)&m8i   ;expected flags + always on bits, mask I
                                    endm
                        eor_flag    macro
                                    eor flag_I_on       ;I_flag is never changed
                                    eor #(\1&m8i|fao)   ;mask I, invert expected flags + always on bits
                                    endm
                                endif
                                if I_flag = 3
                        load_flag   macro
                                    lda #\1             ;allow test to change I-flag (no mask)
                                    endm
                        cmp_flag    macro
                                    cmp #(\1|fao)&m8    ;expected flags + always on bits
                                    endm
                        eor_flag    macro
                                    eor #\1|fao         ;invert expected flags + always on bits
                                    endm
                                endif
                            else
                                if I_flag = 0
                        load_flag   macro
                                    lda #\1&m8i         ;force enable interrupts (mask I)
                                    endm
                        cmp_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    cmp #(\1|faod)&m8i  ;I_flag is always enabled + always on bits
                                    endm
                        eor_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    eor #(\1&m8i|faod)  ;mask I, invert expected flags + always on bits
                                    endm
                                endif
                                if I_flag = 1
                        load_flag   macro
                                    lda #\1|intdis      ;force disable interrupts
                                    endm
                        cmp_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    cmp #(\1|faid)&m8   ;I_flag is always disabled + always on bits
                                    endm
                        eor_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    eor #(\1|faid)      ;invert expected flags + always on bits + I
                                    endm
                                endif
                                if I_flag = 2
                        load_flag   macro
                                    lda #\1
                                    ora flag_I_on       ;restore I-flag
                                    and flag_I_off
                                    endm
                        cmp_flag    macro
                                    eor flag_I_on       ;I_flag is never changed
                                    ora #decmode        ;ignore decimal mode bit
                                    cmp #(\1|faod)&m8i  ;expected flags + always on bits, mask I
                                    endm
                        eor_flag    macro
                                    eor flag_I_on       ;I_flag is never changed
                                    ora #decmode        ;ignore decimal mode bit
                                    eor #(\1&m8i|faod)  ;mask I, invert expected flags + always on bits
                                    endm
                                endif
                                if I_flag = 3
                        load_flag   macro
                                    lda #\1             ;allow test to change I-flag (no mask)
                                    endm
                        cmp_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    cmp #(\1|faod)&m8   ;expected flags + always on bits
                                    endm
                        eor_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    eor #\1|faod        ;invert expected flags + always on bits
                                    endm
                                endif
                            endif
                        
                        ;macros to set (register|memory|zeropage) & status
                        set_stat    macro       ;setting flags in the processor status register
                                    load_flag \1
                                    pha         ;use stack to load status
                                    plp
                                    endm
                        
                        set_a       macro       ;precharging accu & status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda #\1     ;precharge accu
                                    plp
                                    endm
                        
                        set_x       macro       ;precharging index & status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    ldx #\1     ;precharge index x
                                    plp
                                    endm
                        
                        set_y       macro       ;precharging index & status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    ldy #\1     ;precharge index y
                                    plp
                                    endm
                        
                        set_ax      macro       ;precharging indexed accu & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;precharge accu
                                    plp
                                    endm
                        
                        set_ay      macro       ;precharging indexed accu & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,y    ;precharge accu
                                    plp
                                    endm
                        
                        set_z       macro       ;precharging indexed zp & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;load to zeropage
                                    sta zpt
                                    plp
                                    endm
                        
                        set_zx      macro       ;precharging zp,x & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;load to indexed zeropage
                                    sta zpt,x
                                    plp
                                    endm
                        
                        set_abs     macro       ;precharging indexed memory & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;load to memory
                                    sta abst
                                    plp
                                    endm
                        
                        set_absx    macro       ;precharging abs,x & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;load to indexed memory
                                    sta abst,x
                                    plp
                                    endm
                        
                        ;macros to test (register|memory|zeropage) & status & (mask)
                        tst_stat    macro       ;testing flags in the processor status register
                                    php         ;save status
                                    pla         ;use stack to retrieve status
                                    pha
                                    cmp_flag \1
                                    trap_ne
                                    plp         ;restore status
                                    endm
                                    
                        tst_a       macro       ;testing result in accu & flags
                                    php         ;save flags
                                    cmp #\1     ;test result
                                    trap_ne
                                    pla         ;load status
                                    pha
                                    cmp_flag \2
                                    trap_ne
                                    plp         ;restore status
                                    endm
                        
                        tst_x       macro       ;testing result in x index & flags
                                    php         ;save flags
                                    cpx #\1     ;test result
                                    trap_ne
                                    pla         ;load status
                                    pha
                                    cmp_flag \2
                                    trap_ne
                                    plp         ;restore status
                                    endm
                        
                        tst_y       macro       ;testing result in y index & flags
                                    php         ;save flags
                                    cpy #\1     ;test result
                                    trap_ne
                                    pla         ;load status
                                    pha
                                    cmp_flag \2
                                    trap_ne
                                    plp         ;restore status
                                    endm
                        
                        tst_ax      macro       ;indexed testing result in accu & flags
                                    php         ;save flags
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne     ;
                                    endm
                        
                        tst_ay      macro       ;indexed testing result in accu & flags
                                    php         ;save flags
                                    cmp \1,y    ;test result
                                    trap_ne     ;
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,y    ;test flags
                                    trap_ne
                                    endm
                                
                        tst_z       macro       ;indexed testing result in zp & flags
                                    php         ;save flags
                                    lda zpt
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne
                                    endm
                        
                        tst_zx      macro       ;testing result in zp,x & flags
                                    php         ;save flags
                                    lda zpt,x
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne
                                    endm
                        
                        tst_abs     macro       ;indexed testing result in memory & flags
                                    php         ;save flags
                                    lda abst
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne
                                    endm
                        
                        tst_absx    macro       ;testing result in abs,x & flags
                                    php         ;save flags
                                    lda abst,x
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne
                                    endm
                                    
                        ; RAM integrity test
                        ;   verifies that none of the previous tests has altered RAM outside of the
                        ;   designated write areas.
                        ;   uses zpt word as indirect pointer, zpt+2 word as checksum
                                if ram_top > -1
                        check_ram   macro 
                                    cld
                                    lda #0
                                    sta zpt         ;set low byte of indirect pointer
                                    sta zpt+3       ;checksum high byte
                                  if disable_selfmod = 0
                                    sta range_adr   ;reset self modifying code
                                  endif
                                    clc
                                    ldx #zp_bss-zero_page ;zeropage - write test area
                        ccs3\?      adc zero_page,x
                                    bcc ccs2\?
                                    inc zpt+3       ;carry to high byte
                                    clc
                        ccs2\?      inx
                                    bne ccs3\?
                                    ldx #hi(abs1)   ;set high byte of indirect pointer
                                    stx zpt+1
                                    ldy #lo(abs1)   ;data after write & execute test area
                        ccs5\?      adc (zpt),y
                                    bcc ccs4\?
                                    inc zpt+3       ;carry to high byte
                                    clc
                        ccs4\?      iny
                                    bne ccs5\?
                                    inx             ;advance RAM high address
                                    stx zpt+1
                                    cpx #ram_top
                                    bne ccs5\?
                                    sta zpt+2       ;checksum low is
                                    cmp ram_chksm   ;checksum low expected
                                    trap_ne         ;checksum mismatch
                                    lda zpt+3       ;checksum high is
                                    cmp ram_chksm+1 ;checksum high expected
                                    trap_ne         ;checksum mismatch
                                    endm            
                                else
                        check_ram   macro
                                    ;RAM check disabled - RAM size not set
                                    endm
                                endif
                        
                        next_test   macro           ;make sure, tests don't jump the fence
                                    lda test_case   ;previous test
                                    cmp #test_num
                                    trap_ne         ;test is out of sequence
                        test_num = test_num + 1
                                    lda #test_num   ;*** next tests' number
                                    sta test_case
                                    ;check_ram       ;uncomment to find altered RAM after each test
                                    endm
                        
                            if load_data_direct = 1
                                data
                            else
                                bss                 ;uninitialized segment, copy of data at end of code!
                            endif
0000 =                          org zero_page
                        ;break test interrupt save
0000 : 00               irq_a   ds  1               ;a register
0001 : 00               irq_x   ds  1               ;x register
                            if I_flag = 2
                        ;masking for I bit in status
                        flag_I_on   ds  1           ;or mask to load flags   
                        flag_I_off  ds  1           ;and mask to load flags
                            endif
0002 :                  zpt                         ;5 bytes store/modify test area
                        ;add/subtract operand generation and result/flag prediction
0002 : 00               adfc    ds  1               ;carry flag before op
0003 : 00               ad1     ds  1               ;operand 1 - accumulator
0004 : 00               ad2     ds  1               ;operand 2 - memory / immediate
0005 : 00               adrl    ds  1               ;expected result bits 0-7
0006 : 00               adrh    ds  1               ;expected result bit 8 (carry)
0007 : 00               adrf    ds  1               ;expected flags NV0000ZC (only binary mode)
0008 : 00               sb2     ds  1               ;operand 2 complemented for subtract
0009 :                  zp_bss
0009 : c3824100         zp1     db  $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
000d : 7f               zp7f    db  $7f             ;test pattern for compare  
                        ;logical zeropage operands
000e : 001f7180         zpOR    db  0,$1f,$71,$80   ;test pattern for OR
0012 : 0fff7f80         zpAN    db  $0f,$ff,$7f,$80 ;test pattern for AND
0016 : ff0f8f8f         zpEO    db  $ff,$0f,$8f,$8f ;test pattern for EOR
                        ;indirect addressing pointers
001a : 1702             ind1    dw  abs1            ;indirect pointer to pattern in absolute memory
001c : 1802                     dw  abs1+1
001e : 1902                     dw  abs1+2
0020 : 1a02                     dw  abs1+3
0022 : 1b02                     dw  abs7f
0024 : 1f01             inw1    dw  abs1-$f8        ;indirect pointer for wrap-test pattern
0026 : 0302             indt    dw  abst            ;indirect pointer to store area in absolute memory
0028 : 0402                     dw  abst+1
002a : 0502                     dw  abst+2
002c : 0602                     dw  abst+3
002e : 0b01             inwt    dw  abst-$f8        ;indirect pointer for wrap-test store
0030 : 4e02             indAN   dw  absAN           ;indirect pointer to AND pattern in absolute memory
0032 : 4f02                     dw  absAN+1
0034 : 5002                     dw  absAN+2
0036 : 5102                     dw  absAN+3
0038 : 5202             indEO   dw  absEO           ;indirect pointer to EOR pattern in absolute memory
003a : 5302                     dw  absEO+1
003c : 5402                     dw  absEO+2
003e : 5502                     dw  absEO+3
0040 : 4a02             indOR   dw  absOR           ;indirect pointer to OR pattern in absolute memory
0042 : 4b02                     dw  absOR+1
0044 : 4c02                     dw  absOR+2
0046 : 4d02                     dw  absOR+3
                        ;add/subtract indirect pointers
0048 : 0302             adi2    dw  ada2            ;indirect pointer to operand 2 in absolute memory
004a : 0402             sbi2    dw  sba2            ;indirect pointer to complemented operand 2 (SBC)
004c : 0401             adiy2   dw  ada2-$ff        ;with offset for indirect indexed
004e : 0501             sbiy2   dw  sba2-$ff
0050 :                  zp_bss_end
                           
0200 =                          org data_segment
0200 : 00               test_case   ds  1           ;current test number
0201 : 0000             ram_chksm   ds  2           ;checksum for RAM integrity test
                        ;add/subtract operand copy - abs tests write area
0203 :                  abst                        ;5 bytes store/modify test area
0203 : 00               ada2    ds  1               ;operand 2
0204 : 00               sba2    ds  1               ;operand 2 complemented for subtract
0205 : 000000                   ds  3               ;fill remaining bytes
0208 :                  data_bss
                            if load_data_direct = 1
0208 : 2900             ex_andi and #0              ;execute immediate opcodes
020a : 60                       rts
020b : 4900             ex_eori eor #0              ;execute immediate opcodes
020d : 60                       rts
020e : 0900             ex_orai ora #0              ;execute immediate opcodes
0210 : 60                       rts
0211 : 6900             ex_adci adc #0              ;execute immediate opcodes
0213 : 60                       rts
0214 : e900             ex_sbci sbc #0              ;execute immediate opcodes
0216 : 60                       rts
                            else
                        ex_andi ds  3
                        ex_eori ds  3
                        ex_orai ds  3
                        ex_adci ds  3
                        ex_sbci ds  3
                            endif
0217 : c3824100         abs1    db  $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
021b : 7f               abs7f   db  $7f             ;test pattern for compare
                        ;loads
021c : 80800002         fLDx    db  fn,fn,0,fz      ;expected flags for load
                        ;shifts
0220 :                  rASL                        ;expected result ASL & ROL -carry  
0220 : 86048200         rROL    db  $86,$04,$82,0   ; "
0224 : 87058301         rROLc   db  $87,$05,$83,1   ;expected result ROL +carry
0228 :                  rLSR                        ;expected result LSR & ROR -carry
0228 : 61412000         rROR    db  $61,$41,$20,0   ; "
022c : e1c1a080         rRORc   db  $e1,$c1,$a0,$80 ;expected result ROR +carry
0230 :                  fASL                        ;expected flags for shifts
0230 : 81018002         fROL    db  fnc,fc,fn,fz    ;no carry in
0234 : 81018000         fROLc   db  fnc,fc,fn,0     ;carry in
0238 :                  fLSR
0238 : 01000102         fROR    db  fc,0,fc,fz      ;no carry in
023c : 81808180         fRORc   db  fnc,fn,fnc,fn   ;carry in
                        ;increments (decrements)
0240 : 7f80ff0001       rINC    db  $7f,$80,$ff,0,1 ;expected result for INC/DEC
0245 : 0080800200       fINC    db  0,fn,fn,fz,0    ;expected flags for INC/DEC
                        ;logical memory operand
024a : 001f7180         absOR   db  0,$1f,$71,$80   ;test pattern for OR
024e : 0fff7f80         absAN   db  $0f,$ff,$7f,$80 ;test pattern for AND
0252 : ff0f8f8f         absEO   db  $ff,$0f,$8f,$8f ;test pattern for EOR
                        ;logical accu operand
0256 : 00f11f00         absORa  db  0,$f1,$1f,0     ;test pattern for OR
025a : f0ffffff         absANa  db  $f0,$ff,$ff,$ff ;test pattern for AND
025e : fff0f00f         absEOa  db  $ff,$f0,$f0,$0f ;test pattern for EOR
                        ;logical results
0262 : 00ff7f80         absrlo  db  0,$ff,$7f,$80
0266 : 02800080         absflo  db  fz,fn,0,fn
026a :                  data_bss_end
                        
                        
                                code
0400 =                          org code_segment
0400 : d8               start   cld
0401 : a2ff                     ldx #$ff
0403 : 9a                       txs
0404 : a900                     lda #0          ;*** test 0 = initialize
0406 : 8d0002                   sta test_case
0000 =                  test_num = 0
                        
                        ;stop interrupts before initializing BSS
                            if I_flag = 1
                                sei
                            endif
                            
                        ;initialize I/O for report channel
                            if report = 1
                                jsr report_init
                            endif
                            
                        ;pretest small branch offset
0409 : a205                     ldx #5
040b : 4c3304                   jmp psb_test
040e :                  psb_bwok
040e : a005                     ldy #5
0410 : d008                     bne psb_forw
                                trap        ;branch should be taken
0412 : 4c1204          >        jmp *           ;failed anyway
                        
0415 : 88                       dey         ;forward landing zone
0416 : 88                       dey
0417 : 88                       dey
0418 : 88                       dey
0419 : 88                       dey
041a :                  psb_forw
041a : 88                       dey
041b : 88                       dey
041c : 88                       dey
041d : 88                       dey
041e : 88                       dey
041f : f017                     beq psb_fwok
                                trap        ;forward offset
0421 : 4c2104          >        jmp *           ;failed anyway
                        
                        
0424 : ca                       dex         ;backward landing zone
0425 : ca                       dex
0426 : ca                       dex
0427 : ca                       dex
0428 : ca                       dex
0429 :                  psb_back
0429 : ca                       dex
042a : ca                       dex
042b : ca                       dex
042c : ca                       dex
042d : ca                       dex
042e : f0de                     beq psb_bwok
                                trap        ;backward offset
0430 : 4c3004          >        jmp *           ;failed anyway
                        
0433 :                  psb_test
0433 : d0f4                     bne psb_back
                                trap        ;branch should be taken
0435 : 4c3504          >        jmp *           ;failed anyway
                        
0438 :                  psb_fwok
                                
                        ;initialize BSS segment
                            if load_data_direct != 1
                                ldx #zp_end-zp_init-1
                        ld_zp   lda zp_init,x
                                sta zp_bss,x
                                dex
                                bpl ld_zp
                                ldx #data_end-data_init-1
                        ld_data lda data_init,x
                                sta data_bss,x
                                dex
                                bpl ld_data
                              if ROM_vectors = 1
                                ldx #5
                        ld_vect lda vec_init,x
                                sta vec_bss,x
                                dex
                                bpl ld_vect
                              endif
                            endif
                        
                        ;retain status of interrupt flag
                            if I_flag = 2
                                php
                                pla
                                and #4          ;isolate flag
                                sta flag_I_on   ;or mask
                                eor #lo(~4)     ;reverse
                                sta flag_I_off  ;and mask
                            endif
                                
                        ;generate checksum for RAM integrity test
                            if ram_top > -1
                                lda #0 
                                sta zpt         ;set low byte of indirect pointer
                                sta ram_chksm+1 ;checksum high byte
                              if disable_selfmod = 0
                                sta range_adr   ;reset self modifying code
                              endif
                                clc
                                ldx #zp_bss-zero_page ;zeropage - write test area
                        gcs3    adc zero_page,x
                                bcc gcs2
                                inc ram_chksm+1 ;carry to high byte
                                clc
                        gcs2    inx
                                bne gcs3
                                ldx #hi(abs1)   ;set high byte of indirect pointer
                                stx zpt+1
                                ldy #lo(abs1)   ;data after write & execute test area
                        gcs5    adc (zpt),y
                                bcc gcs4
                                inc ram_chksm+1 ;carry to high byte
                                clc
                        gcs4    iny
                                bne gcs5
                                inx             ;advance RAM high address
                                stx zpt+1
                                cpx #ram_top
                                bne gcs5
                                sta ram_chksm   ;checksum complete
                            endif
                                next_test            
0438 : ad0002          >            lda test_case   ;previous test
043b : c900            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
043d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0001 =                 >test_num = test_num + 1
043f : a901            >            lda #test_num   ;*** next tests' number
0441 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                            if disable_selfmod = 0
                        ;testing relative addressing with BEQ
0444 : a0fe                     ldy #$fe        ;testing maximum range, not -1/-2 (invalid/self adr)
0446 :                  range_loop
0446 : 88                       dey             ;next relative address
0447 : 98                       tya
0448 : aa                       tax             ;precharge count to end of loop
0449 : 1008                     bpl range_fw    ;calculate relative address
044b : 18                       clc             ;avoid branch self or to relative address of branch
044c : 6902                     adc #2
044e : ea                       nop             ;offset landing zone - tolerate +/-5 offset to branch
044f : ea                       nop
0450 : ea                       nop
0451 : ea                       nop
0452 : ea                       nop
0453 :                  range_fw
0453 : ea                       nop
0454 : ea                       nop
0455 : ea                       nop
0456 : ea                       nop
0457 : ea                       nop
0458 : 497f                     eor #$7f        ;complement except sign
045a : 8de604                   sta range_adr   ;load into test target
045d : a900                     lda #0          ;should set zero flag in status register
045f : 4ce504                   jmp range_op
                                
0462 : ca                       dex             ; offset landing zone - backward branch too far
0463 : ca                       dex
0464 : ca                       dex
0465 : ca                       dex
0466 : ca                       dex
                                ;relative address target field with branch under test in the middle
0467 : ca                       dex             ;-128 - max backward
0468 : ca                       dex
0469 : ca                       dex
046a : ca                       dex
046b : ca                       dex
046c : ca                       dex
046d : ca                       dex
046e : ca                       dex
046f : ca                       dex             ;-120
0470 : ca                       dex
0471 : ca                       dex
0472 : ca                       dex
0473 : ca                       dex
0474 : ca                       dex
0475 : ca                       dex
0476 : ca                       dex
0477 : ca                       dex
0478 : ca                       dex
0479 : ca                       dex             ;-110
047a : ca                       dex
047b : ca                       dex
047c : ca                       dex
047d : ca                       dex
047e : ca                       dex
047f : ca                       dex
0480 : ca                       dex
0481 : ca                       dex
0482 : ca                       dex
0483 : ca                       dex             ;-100
0484 : ca                       dex
0485 : ca                       dex
0486 : ca                       dex
0487 : ca                       dex
0488 : ca                       dex
0489 : ca                       dex
048a : ca                       dex
048b : ca                       dex
048c : ca                       dex
048d : ca                       dex             ;-90
048e : ca                       dex
048f : ca                       dex
0490 : ca                       dex
0491 : ca                       dex
0492 : ca                       dex
0493 : ca                       dex
0494 : ca                       dex
0495 : ca                       dex
0496 : ca                       dex
0497 : ca                       dex             ;-80
0498 : ca                       dex
0499 : ca                       dex
049a : ca                       dex
049b : ca                       dex
049c : ca                       dex
049d : ca                       dex
049e : ca                       dex
049f : ca                       dex
04a0 : ca                       dex
04a1 : ca                       dex             ;-70
04a2 : ca                       dex
04a3 : ca                       dex
04a4 : ca                       dex
04a5 : ca                       dex
04a6 : ca                       dex
04a7 : ca                       dex
04a8 : ca                       dex
04a9 : ca                       dex
04aa : ca                       dex
04ab : ca                       dex             ;-60
04ac : ca                       dex
04ad : ca                       dex
04ae : ca                       dex
04af : ca                       dex
04b0 : ca                       dex
04b1 : ca                       dex
04b2 : ca                       dex
04b3 : ca                       dex
04b4 : ca                       dex
04b5 : ca                       dex             ;-50
04b6 : ca                       dex
04b7 : ca                       dex
04b8 : ca                       dex
04b9 : ca                       dex
04ba : ca                       dex
04bb : ca                       dex
04bc : ca                       dex
04bd : ca                       dex
04be : ca                       dex
04bf : ca                       dex             ;-40
04c0 : ca                       dex
04c1 : ca                       dex
04c2 : ca                       dex
04c3 : ca                       dex
04c4 : ca                       dex
04c5 : ca                       dex
04c6 : ca                       dex
04c7 : ca                       dex
04c8 : ca                       dex
04c9 : ca                       dex             ;-30
04ca : ca                       dex
04cb : ca                       dex
04cc : ca                       dex
04cd : ca                       dex
04ce : ca                       dex
04cf : ca                       dex
04d0 : ca                       dex
04d1 : ca                       dex
04d2 : ca                       dex
04d3 : ca                       dex             ;-20
04d4 : ca                       dex
04d5 : ca                       dex
04d6 : ca                       dex
04d7 : ca                       dex
04d8 : ca                       dex
04d9 : ca                       dex
04da : ca                       dex
04db : ca                       dex
04dc : ca                       dex
04dd : ca                       dex             ;-10
04de : ca                       dex
04df : ca                       dex
04e0 : ca                       dex
04e1 : ca                       dex
04e2 : ca                       dex
04e3 : ca                       dex
04e4 : ca                       dex             ;-3
04e5 :                  range_op                ;test target with zero flag=0, z=1 if previous dex
04e6 =                  range_adr   = *+1       ;modifiable relative address
04e5 : f03e                     beq *+64        ;+64 if called without modification
04e7 : ca                       dex             ;+0
04e8 : ca                       dex
04e9 : ca                       dex
04ea : ca                       dex
04eb : ca                       dex
04ec : ca                       dex
04ed : ca                       dex
04ee : ca                       dex
04ef : ca                       dex
04f0 : ca                       dex
04f1 : ca                       dex             ;+10
04f2 : ca                       dex
04f3 : ca                       dex
04f4 : ca                       dex
04f5 : ca                       dex
04f6 : ca                       dex
04f7 : ca                       dex
04f8 : ca                       dex
04f9 : ca                       dex
04fa : ca                       dex
04fb : ca                       dex             ;+20
04fc : ca                       dex
04fd : ca                       dex
04fe : ca                       dex
04ff : ca                       dex
0500 : ca                       dex
0501 : ca                       dex
0502 : ca                       dex
0503 : ca                       dex
0504 : ca                       dex
0505 : ca                       dex             ;+30
0506 : ca                       dex
0507 : ca                       dex
0508 : ca                       dex
0509 : ca                       dex
050a : ca                       dex
050b : ca                       dex
050c : ca                       dex
050d : ca                       dex
050e : ca                       dex
050f : ca                       dex             ;+40
0510 : ca                       dex
0511 : ca                       dex
0512 : ca                       dex
0513 : ca                       dex
0514 : ca                       dex
0515 : ca                       dex
0516 : ca                       dex
0517 : ca                       dex
0518 : ca                       dex
0519 : ca                       dex             ;+50
051a : ca                       dex
051b : ca                       dex
051c : ca                       dex
051d : ca                       dex
051e : ca                       dex
051f : ca                       dex
0520 : ca                       dex
0521 : ca                       dex
0522 : ca                       dex
0523 : ca                       dex             ;+60
0524 : ca                       dex
0525 : ca                       dex
0526 : ca                       dex
0527 : ca                       dex
0528 : ca                       dex
0529 : ca                       dex
052a : ca                       dex
052b : ca                       dex
052c : ca                       dex
052d : ca                       dex             ;+70
052e : ca                       dex
052f : ca                       dex
0530 : ca                       dex
0531 : ca                       dex
0532 : ca                       dex
0533 : ca                       dex
0534 : ca                       dex
0535 : ca                       dex
0536 : ca                       dex
0537 : ca                       dex             ;+80
0538 : ca                       dex
0539 : ca                       dex
053a : ca                       dex
053b : ca                       dex
053c : ca                       dex
053d : ca                       dex
053e : ca                       dex
053f : ca                       dex
0540 : ca                       dex
0541 : ca                       dex             ;+90
0542 : ca                       dex
0543 : ca                       dex
0544 : ca                       dex
0545 : ca                       dex
0546 : ca                       dex
0547 : ca                       dex
0548 : ca                       dex
0549 : ca                       dex
054a : ca                       dex
054b : ca                       dex             ;+100
054c : ca                       dex
054d : ca                       dex
054e : ca                       dex
054f : ca                       dex
0550 : ca                       dex
0551 : ca                       dex
0552 : ca                       dex
0553 : ca                       dex
0554 : ca                       dex
0555 : ca                       dex             ;+110
0556 : ca                       dex
0557 : ca                       dex
0558 : ca                       dex
0559 : ca                       dex
055a : ca                       dex
055b : ca                       dex
055c : ca                       dex
055d : ca                       dex
055e : ca                       dex
055f : ca                       dex             ;+120
0560 : ca                       dex
0561 : ca                       dex
0562 : ca                       dex
0563 : ca                       dex
0564 : ca                       dex
0565 : ca                       dex
0566 : ea                       nop             ;offset landing zone - forward branch too far
0567 : ea                       nop
0568 : ea                       nop
0569 : ea                       nop
056a : ea                       nop
056b : f008                     beq range_ok    ;+127 - max forward
                                trap            ; bad range
056d : 4c6d05          >        jmp *           ;failed anyway
                        
0570 : ea                       nop             ;offset landing zone - tolerate +/-5 offset to branch
0571 : ea                       nop
0572 : ea                       nop
0573 : ea                       nop
0574 : ea                       nop
0575 :                  range_ok
0575 : ea                       nop
0576 : ea                       nop
0577 : ea                       nop
0578 : ea                       nop
0579 : ea                       nop
057a : c000                     cpy #0
057c : f003                     beq range_end   
057e : 4c4604                   jmp range_loop
0581 :                  range_end               ;range test successful
                            endif
                                next_test
0581 : ad0002          >            lda test_case   ;previous test
0584 : c901            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0586 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0002 =                 >test_num = test_num + 1
0588 : a902            >            lda #test_num   ;*** next tests' number
058a : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ;partial test BNE & CMP, CPX, CPY immediate
058d : c001                     cpy #1          ;testing BNE true
058f : d003                     bne test_bne
                                trap 
0591 : 4c9105          >        jmp *           ;failed anyway
                        
0594 :                  test_bne
0594 : a900                     lda #0 
0596 : c900                     cmp #0          ;test compare immediate 
                                trap_ne
0598 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                trap_cc
059a : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_mi
059c : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
059e : c901                     cmp #1
                                trap_eq 
05a0 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_cs
05a2 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_pl
05a4 : 10fe            >        bpl *           ;failed plus (bit 7 clear)
                        
05a6 : aa                       tax 
05a7 : e000                     cpx #0          ;test compare x immediate
                                trap_ne
05a9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                trap_cc
05ab : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_mi
05ad : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
05af : e001                     cpx #1
                                trap_eq 
05b1 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_cs
05b3 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_pl
05b5 : 10fe            >        bpl *           ;failed plus (bit 7 clear)
                        
05b7 : a8                       tay 
05b8 : c000                     cpy #0          ;test compare y immediate
                                trap_ne
05ba : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                trap_cc
05bc : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_mi
05be : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
05c0 : c001                     cpy #1
                                trap_eq 
05c2 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_cs
05c4 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_pl
05c6 : 10fe            >        bpl *           ;failed plus (bit 7 clear)
                        
                                next_test
05c8 : ad0002          >            lda test_case   ;previous test
05cb : c902            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
05cd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0003 =                 >test_num = test_num + 1
05cf : a903            >            lda #test_num   ;*** next tests' number
05d1 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        ;testing stack operations PHA PHP PLA PLP
                                    
05d4 : a2ff                     ldx #$ff        ;initialize stack
05d6 : 9a                       txs
05d7 : a955                     lda #$55
05d9 : 48                       pha
05da : a9aa                     lda #$aa
05dc : 48                       pha
05dd : cdfe01                   cmp $1fe        ;on stack ?
                                trap_ne
05e0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
05e2 : ba                       tsx
05e3 : 8a                       txa             ;overwrite accu
05e4 : c9fd                     cmp #$fd        ;sp decremented?
                                trap_ne
05e6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
05e8 : 68                       pla
05e9 : c9aa                     cmp #$aa        ;successful retreived from stack?
                                trap_ne
05eb : d0fe            >        bne *           ;failed not equal (non zero)
                        
05ed : 68                       pla
05ee : c955                     cmp #$55
                                trap_ne
05f0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
05f2 : cdff01                   cmp $1ff        ;remains on stack?
                                trap_ne
05f5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
05f7 : ba                       tsx
05f8 : e0ff                     cpx #$ff        ;sp incremented?
                                trap_ne
05fa : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
05fc : ad0002          >            lda test_case   ;previous test
05ff : c903            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0601 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0004 =                 >test_num = test_num + 1
0603 : a904            >            lda #test_num   ;*** next tests' number
0605 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ;testing branch decisions BPL BMI BVC BVS BCC BCS BNE BEQ
                                set_stat $ff    ;all on
                       >            load_flag $ff    
0608 : a9ff            >            lda #$ff                 ;allow test to change I-flag (no mask)
                       >
060a : 48              >            pha         ;use stack to load status
060b : 28              >            plp
                        
060c : 101a                     bpl nbr1        ;branches should not be taken
060e : 501b                     bvc nbr2
0610 : 901c                     bcc nbr3
0612 : d01d                     bne nbr4
0614 : 3003                     bmi br1         ;branches should be taken
                                trap 
0616 : 4c1606          >        jmp *           ;failed anyway
                        
0619 : 7003             br1     bvs br2
                                trap 
061b : 4c1b06          >        jmp *           ;failed anyway
                        
061e : b003             br2     bcs br3
                                trap 
0620 : 4c2006          >        jmp *           ;failed anyway
                        
0623 : f00f             br3     beq br4
                                trap 
0625 : 4c2506          >        jmp *           ;failed anyway
                        
0628 :                  nbr1
                                trap            ;previous bpl taken 
0628 : 4c2806          >        jmp *           ;failed anyway
                        
062b :                  nbr2
                                trap            ;previous bvc taken
062b : 4c2b06          >        jmp *           ;failed anyway
                        
062e :                  nbr3
                                trap            ;previous bcc taken
062e : 4c2e06          >        jmp *           ;failed anyway
                        
0631 :                  nbr4
                                trap            ;previous bne taken
0631 : 4c3106          >        jmp *           ;failed anyway
                        
0634 : 08               br4     php
0635 : ba                       tsx
0636 : e0fe                     cpx #$fe        ;sp after php?
                                trap_ne
0638 : d0fe            >        bne *           ;failed not equal (non zero)
                        
063a : 68                       pla
                                cmp_flag $ff    ;returned all flags on?
063b : c9ff            >            cmp #($ff    |fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
063d : d0fe            >        bne *           ;failed not equal (non zero)
                        
063f : ba                       tsx
0640 : e0ff                     cpx #$ff        ;sp after php?
                                trap_ne
0642 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0      ;all off
                       >            load_flag 0      
0644 : a900            >            lda #0                   ;allow test to change I-flag (no mask)
                       >
0646 : 48              >            pha         ;use stack to load status
0647 : 28              >            plp
                        
0648 : 301a                     bmi nbr11       ;branches should not be taken
064a : 701b                     bvs nbr12
064c : b01c                     bcs nbr13
064e : f01d                     beq nbr14
0650 : 1003                     bpl br11        ;branches should be taken
                                trap 
0652 : 4c5206          >        jmp *           ;failed anyway
                        
0655 : 5003             br11    bvc br12
                                trap 
0657 : 4c5706          >        jmp *           ;failed anyway
                        
065a : 9003             br12    bcc br13
                                trap 
065c : 4c5c06          >        jmp *           ;failed anyway
                        
065f : d00f             br13    bne br14
                                trap 
0661 : 4c6106          >        jmp *           ;failed anyway
                        
0664 :                  nbr11
                                trap            ;previous bmi taken 
0664 : 4c6406          >        jmp *           ;failed anyway
                        
0667 :                  nbr12
                                trap            ;previous bvs taken 
0667 : 4c6706          >        jmp *           ;failed anyway
                        
066a :                  nbr13
                                trap            ;previous bcs taken 
066a : 4c6a06          >        jmp *           ;failed anyway
                        
066d :                  nbr14
                                trap            ;previous beq taken 
066d : 4c6d06          >        jmp *           ;failed anyway
                        
0670 : 08               br14    php
0671 : 68                       pla
                                cmp_flag 0      ;flags off except break (pushed by sw) + reserved?
0672 : c930            >            cmp #(0      |fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0674 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                ;crosscheck flags
                                set_stat zero
                       >            load_flag zero
0676 : a902            >            lda #zero             ;allow test to change I-flag (no mask)
                       >
0678 : 48              >            pha         ;use stack to load status
0679 : 28              >            plp
                        
067a : d002                     bne brzs1
067c : f003                     beq brzs2
067e :                  brzs1
                                trap            ;branch zero/non zero
067e : 4c7e06          >        jmp *           ;failed anyway
                        
0681 : b002             brzs2   bcs brzs3
0683 : 9003                     bcc brzs4
0685 :                  brzs3
                                trap            ;branch carry/no carry
0685 : 4c8506          >        jmp *           ;failed anyway
                        
0688 : 3002             brzs4   bmi brzs5
068a : 1003                     bpl brzs6
068c :                  brzs5
                                trap            ;branch minus/plus
068c : 4c8c06          >        jmp *           ;failed anyway
                        
068f : 7002             brzs6   bvs brzs7
0691 : 5003                     bvc brzs8
0693 :                  brzs7
                                trap            ;branch overflow/no overflow
0693 : 4c9306          >        jmp *           ;failed anyway
                        
0696 :                  brzs8
                                set_stat carry
                       >            load_flag carry
0696 : a901            >            lda #carry             ;allow test to change I-flag (no mask)
                       >
0698 : 48              >            pha         ;use stack to load status
0699 : 28              >            plp
                        
069a : f002                     beq brcs1
069c : d003                     bne brcs2
069e :                  brcs1
                                trap            ;branch zero/non zero
069e : 4c9e06          >        jmp *           ;failed anyway
                        
06a1 : 9002             brcs2   bcc brcs3
06a3 : b003                     bcs brcs4
06a5 :                  brcs3
                                trap            ;branch carry/no carry
06a5 : 4ca506          >        jmp *           ;failed anyway
                        
06a8 : 3002             brcs4   bmi brcs5
06aa : 1003                     bpl brcs6
06ac :                  brcs5
                                trap            ;branch minus/plus
06ac : 4cac06          >        jmp *           ;failed anyway
                        
06af : 7002             brcs6   bvs brcs7
06b1 : 5003                     bvc brcs8
06b3 :                  brcs7
                                trap            ;branch overflow/no overflow
06b3 : 4cb306          >        jmp *           ;failed anyway
                        
                        
06b6 :                  brcs8
                                set_stat minus
                       >            load_flag minus
06b6 : a980            >            lda #minus             ;allow test to change I-flag (no mask)
                       >
06b8 : 48              >            pha         ;use stack to load status
06b9 : 28              >            plp
                        
06ba : f002                     beq brmi1
06bc : d003                     bne brmi2
06be :                  brmi1
                                trap            ;branch zero/non zero
06be : 4cbe06          >        jmp *           ;failed anyway
                        
06c1 : b002             brmi2   bcs brmi3
06c3 : 9003                     bcc brmi4
06c5 :                  brmi3
                                trap            ;branch carry/no carry
06c5 : 4cc506          >        jmp *           ;failed anyway
                        
06c8 : 1002             brmi4   bpl brmi5
06ca : 3003                     bmi brmi6
06cc :                  brmi5
                                trap            ;branch minus/plus
06cc : 4ccc06          >        jmp *           ;failed anyway
                        
06cf : 7002             brmi6   bvs brmi7
06d1 : 5003                     bvc brmi8
06d3 :                  brmi7
                                trap            ;branch overflow/no overflow
06d3 : 4cd306          >        jmp *           ;failed anyway
                        
06d6 :                  brmi8
                                set_stat overfl
                       >            load_flag overfl
06d6 : a940            >            lda #overfl             ;allow test to change I-flag (no mask)
                       >
06d8 : 48              >            pha         ;use stack to load status
06d9 : 28              >            plp
                        
06da : f002                     beq brvs1
06dc : d003                     bne brvs2
06de :                  brvs1
                                trap            ;branch zero/non zero
06de : 4cde06          >        jmp *           ;failed anyway
                        
06e1 : b002             brvs2   bcs brvs3
06e3 : 9003                     bcc brvs4
06e5 :                  brvs3
                                trap            ;branch carry/no carry
06e5 : 4ce506          >        jmp *           ;failed anyway
                        
06e8 : 3002             brvs4   bmi brvs5
06ea : 1003                     bpl brvs6
06ec :                  brvs5
                                trap            ;branch minus/plus
06ec : 4cec06          >        jmp *           ;failed anyway
                        
06ef : 5002             brvs6   bvc brvs7
06f1 : 7003                     bvs brvs8
06f3 :                  brvs7
                                trap            ;branch overflow/no overflow
06f3 : 4cf306          >        jmp *           ;failed anyway
                        
06f6 :                  brvs8
                                set_stat $ff-zero
                       >            load_flag $ff-zero
06f6 : a9fd            >            lda #$ff-zero             ;allow test to change I-flag (no mask)
                       >
06f8 : 48              >            pha         ;use stack to load status
06f9 : 28              >            plp
                        
06fa : f002                     beq brzc1
06fc : d003                     bne brzc2
06fe :                  brzc1
                                trap            ;branch zero/non zero
06fe : 4cfe06          >        jmp *           ;failed anyway
                        
0701 : 9002             brzc2   bcc brzc3
0703 : b003                     bcs brzc4
0705 :                  brzc3
                                trap            ;branch carry/no carry
0705 : 4c0507          >        jmp *           ;failed anyway
                        
0708 : 1002             brzc4   bpl brzc5
070a : 3003                     bmi brzc6
070c :                  brzc5
                                trap            ;branch minus/plus
070c : 4c0c07          >        jmp *           ;failed anyway
                        
070f : 5002             brzc6   bvc brzc7
0711 : 7003                     bvs brzc8
0713 :                  brzc7
                                trap            ;branch overflow/no overflow
0713 : 4c1307          >        jmp *           ;failed anyway
                        
0716 :                  brzc8
                                set_stat $ff-carry
                       >            load_flag $ff-carry
0716 : a9fe            >            lda #$ff-carry             ;allow test to change I-flag (no mask)
                       >
0718 : 48              >            pha         ;use stack to load status
0719 : 28              >            plp
                        
071a : d002                     bne brcc1
071c : f003                     beq brcc2
071e :                  brcc1
                                trap            ;branch zero/non zero
071e : 4c1e07          >        jmp *           ;failed anyway
                        
0721 : b002             brcc2   bcs brcc3
0723 : 9003                     bcc brcc4
0725 :                  brcc3
                                trap            ;branch carry/no carry
0725 : 4c2507          >        jmp *           ;failed anyway
                        
0728 : 1002             brcc4   bpl brcc5
072a : 3003                     bmi brcc6
072c :                  brcc5
                                trap            ;branch minus/plus
072c : 4c2c07          >        jmp *           ;failed anyway
                        
072f : 5002             brcc6   bvc brcc7
0731 : 7003                     bvs brcc8
0733 :                  brcc7
                                trap            ;branch overflow/no overflow
0733 : 4c3307          >        jmp *           ;failed anyway
                        
0736 :                  brcc8
                                set_stat $ff-minus
                       >            load_flag $ff-minus
0736 : a97f            >            lda #$ff-minus             ;allow test to change I-flag (no mask)
                       >
0738 : 48              >            pha         ;use stack to load status
0739 : 28              >            plp
                        
073a : d002                     bne brpl1
073c : f003                     beq brpl2
073e :                  brpl1
                                trap            ;branch zero/non zero
073e : 4c3e07          >        jmp *           ;failed anyway
                        
0741 : 9002             brpl2   bcc brpl3
0743 : b003                     bcs brpl4
0745 :                  brpl3
                                trap            ;branch carry/no carry
0745 : 4c4507          >        jmp *           ;failed anyway
                        
0748 : 3002             brpl4   bmi brpl5
074a : 1003                     bpl brpl6
074c :                  brpl5
                                trap            ;branch minus/plus
074c : 4c4c07          >        jmp *           ;failed anyway
                        
074f : 5002             brpl6   bvc brpl7
0751 : 7003                     bvs brpl8
0753 :                  brpl7
                                trap            ;branch overflow/no overflow
0753 : 4c5307          >        jmp *           ;failed anyway
                        
0756 :                  brpl8
                                set_stat $ff-overfl
                       >            load_flag $ff-overfl
0756 : a9bf            >            lda #$ff-overfl             ;allow test to change I-flag (no mask)
                       >
0758 : 48              >            pha         ;use stack to load status
0759 : 28              >            plp
                        
075a : d002                     bne brvc1
075c : f003                     beq brvc2
075e :                  brvc1
                                trap            ;branch zero/non zero
075e : 4c5e07          >        jmp *           ;failed anyway
                        
0761 : 9002             brvc2   bcc brvc3
0763 : b003                     bcs brvc4
0765 :                  brvc3
                                trap            ;branch carry/no carry
0765 : 4c6507          >        jmp *           ;failed anyway
                        
0768 : 1002             brvc4   bpl brvc5
076a : 3003                     bmi brvc6
076c :                  brvc5
                                trap            ;branch minus/plus
076c : 4c6c07          >        jmp *           ;failed anyway
                        
076f : 7002             brvc6   bvs brvc7
0771 : 5003                     bvc brvc8
0773 :                  brvc7
                                trap            ;branch overflow/no overflow
0773 : 4c7307          >        jmp *           ;failed anyway
                        
0776 :                  brvc8
                                next_test
0776 : ad0002          >            lda test_case   ;previous test
0779 : c904            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
077b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0005 =                 >test_num = test_num + 1
077d : a905            >            lda #test_num   ;*** next tests' number
077f : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; test PHA does not alter flags or accumulator but PLA does
0782 : a255                     ldx #$55        ;x & y protected
0784 : a0aa                     ldy #$aa
                                set_a 1,$ff     ;push
                       >            load_flag $ff     
0786 : a9ff            >            lda #$ff                  ;allow test to change I-flag (no mask)
                       >
0788 : 48              >            pha         ;use stack to load status
0789 : a901            >            lda #1     ;precharge accu
078b : 28              >            plp
                        
078c : 48                       pha
                                tst_a 1,$ff
078d : 08              >            php         ;save flags
078e : c901            >            cmp #1     ;test result
                       >            trap_ne
0790 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0792 : 68              >            pla         ;load status
0793 : 48              >            pha
                       >            cmp_flag $ff
0794 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0796 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0798 : 28              >            plp         ;restore status
                        
                                set_a 0,0
                       >            load_flag 0
0799 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
079b : 48              >            pha         ;use stack to load status
079c : a900            >            lda #0     ;precharge accu
079e : 28              >            plp
                        
079f : 48                       pha
                                tst_a 0,0
07a0 : 08              >            php         ;save flags
07a1 : c900            >            cmp #0     ;test result
                       >            trap_ne
07a3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07a5 : 68              >            pla         ;load status
07a6 : 48              >            pha
                       >            cmp_flag 0
07a7 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
07a9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07ab : 28              >            plp         ;restore status
                        
                                set_a $ff,$ff
                       >            load_flag $ff
07ac : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
07ae : 48              >            pha         ;use stack to load status
07af : a9ff            >            lda #$ff     ;precharge accu
07b1 : 28              >            plp
                        
07b2 : 48                       pha
                                tst_a $ff,$ff
07b3 : 08              >            php         ;save flags
07b4 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
07b6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07b8 : 68              >            pla         ;load status
07b9 : 48              >            pha
                       >            cmp_flag $ff
07ba : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
07bc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07be : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
07bf : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
07c1 : 48              >            pha         ;use stack to load status
07c2 : a901            >            lda #1     ;precharge accu
07c4 : 28              >            plp
                        
07c5 : 48                       pha
                                tst_a 1,0
07c6 : 08              >            php         ;save flags
07c7 : c901            >            cmp #1     ;test result
                       >            trap_ne
07c9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07cb : 68              >            pla         ;load status
07cc : 48              >            pha
                       >            cmp_flag 0
07cd : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
07cf : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07d1 : 28              >            plp         ;restore status
                        
                                set_a 0,$ff
                       >            load_flag $ff
07d2 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
07d4 : 48              >            pha         ;use stack to load status
07d5 : a900            >            lda #0     ;precharge accu
07d7 : 28              >            plp
                        
07d8 : 48                       pha
                                tst_a 0,$ff
07d9 : 08              >            php         ;save flags
07da : c900            >            cmp #0     ;test result
                       >            trap_ne
07dc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07de : 68              >            pla         ;load status
07df : 48              >            pha
                       >            cmp_flag $ff
07e0 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
07e2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07e4 : 28              >            plp         ;restore status
                        
                                set_a $ff,0
                       >            load_flag 0
07e5 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
07e7 : 48              >            pha         ;use stack to load status
07e8 : a9ff            >            lda #$ff     ;precharge accu
07ea : 28              >            plp
                        
07eb : 48                       pha
                                tst_a $ff,0
07ec : 08              >            php         ;save flags
07ed : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
07ef : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07f1 : 68              >            pla         ;load status
07f2 : 48              >            pha
                       >            cmp_flag 0
07f3 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
07f5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07f7 : 28              >            plp         ;restore status
                        
                                set_a 0,$ff     ;pull
                       >            load_flag $ff     
07f8 : a9ff            >            lda #$ff                  ;allow test to change I-flag (no mask)
                       >
07fa : 48              >            pha         ;use stack to load status
07fb : a900            >            lda #0     ;precharge accu
07fd : 28              >            plp
                        
07fe : 68                       pla
                                tst_a $ff,$ff-zero
07ff : 08              >            php         ;save flags
0800 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
0802 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0804 : 68              >            pla         ;load status
0805 : 48              >            pha
                       >            cmp_flag $ff-zero
0806 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0808 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
080a : 28              >            plp         ;restore status
                        
                                set_a $ff,0
                       >            load_flag 0
080b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
080d : 48              >            pha         ;use stack to load status
080e : a9ff            >            lda #$ff     ;precharge accu
0810 : 28              >            plp
                        
0811 : 68                       pla
                                tst_a 0,zero
0812 : 08              >            php         ;save flags
0813 : c900            >            cmp #0     ;test result
                       >            trap_ne
0815 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0817 : 68              >            pla         ;load status
0818 : 48              >            pha
                       >            cmp_flag zero
0819 : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
081b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
081d : 28              >            plp         ;restore status
                        
                                set_a $fe,$ff
                       >            load_flag $ff
081e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0820 : 48              >            pha         ;use stack to load status
0821 : a9fe            >            lda #$fe     ;precharge accu
0823 : 28              >            plp
                        
0824 : 68                       pla
                                tst_a 1,$ff-zero-minus
0825 : 08              >            php         ;save flags
0826 : c901            >            cmp #1     ;test result
                       >            trap_ne
0828 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
082a : 68              >            pla         ;load status
082b : 48              >            pha
                       >            cmp_flag $ff-zero-minus
082c : c97d            >            cmp #($ff-zero-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
082e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0830 : 28              >            plp         ;restore status
                        
                                set_a 0,0
                       >            load_flag 0
0831 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0833 : 48              >            pha         ;use stack to load status
0834 : a900            >            lda #0     ;precharge accu
0836 : 28              >            plp
                        
0837 : 68                       pla
                                tst_a $ff,minus
0838 : 08              >            php         ;save flags
0839 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
083b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
083d : 68              >            pla         ;load status
083e : 48              >            pha
                       >            cmp_flag minus
083f : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0841 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0843 : 28              >            plp         ;restore status
                        
                                set_a $ff,$ff
                       >            load_flag $ff
0844 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0846 : 48              >            pha         ;use stack to load status
0847 : a9ff            >            lda #$ff     ;precharge accu
0849 : 28              >            plp
                        
084a : 68                       pla
                                tst_a 0,$ff-minus
084b : 08              >            php         ;save flags
084c : c900            >            cmp #0     ;test result
                       >            trap_ne
084e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0850 : 68              >            pla         ;load status
0851 : 48              >            pha
                       >            cmp_flag $ff-minus
0852 : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0854 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0856 : 28              >            plp         ;restore status
                        
                                set_a $fe,0
                       >            load_flag 0
0857 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0859 : 48              >            pha         ;use stack to load status
085a : a9fe            >            lda #$fe     ;precharge accu
085c : 28              >            plp
                        
085d : 68                       pla
                                tst_a 1,0
085e : 08              >            php         ;save flags
085f : c901            >            cmp #1     ;test result
                       >            trap_ne
0861 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0863 : 68              >            pla         ;load status
0864 : 48              >            pha
                       >            cmp_flag 0
0865 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0867 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0869 : 28              >            plp         ;restore status
                        
086a : e055                     cpx #$55        ;x & y unchanged?
                                trap_ne
086c : d0fe            >        bne *           ;failed not equal (non zero)
                        
086e : c0aa                     cpy #$aa
                                trap_ne
0870 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
0872 : ad0002          >            lda test_case   ;previous test
0875 : c905            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0877 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0006 =                 >test_num = test_num + 1
0879 : a906            >            lda #test_num   ;*** next tests' number
087b : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                         
                        ; partial pretest EOR #
                                set_a $3c,0
                       >            load_flag 0
087e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0880 : 48              >            pha         ;use stack to load status
0881 : a93c            >            lda #$3c     ;precharge accu
0883 : 28              >            plp
                        
0884 : 49c3                     eor #$c3
                                tst_a $ff,fn
0886 : 08              >            php         ;save flags
0887 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
0889 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
088b : 68              >            pla         ;load status
088c : 48              >            pha
                       >            cmp_flag fn
088d : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
088f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0891 : 28              >            plp         ;restore status
                        
                                set_a $c3,0
                       >            load_flag 0
0892 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0894 : 48              >            pha         ;use stack to load status
0895 : a9c3            >            lda #$c3     ;precharge accu
0897 : 28              >            plp
                        
0898 : 49c3                     eor #$c3
                                tst_a 0,fz
089a : 08              >            php         ;save flags
089b : c900            >            cmp #0     ;test result
                       >            trap_ne
089d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
089f : 68              >            pla         ;load status
08a0 : 48              >            pha
                       >            cmp_flag fz
08a1 : c932            >            cmp #(fz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
08a3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
08a5 : 28              >            plp         ;restore status
                        
                                next_test
08a6 : ad0002          >            lda test_case   ;previous test
08a9 : c906            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
08ab : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0007 =                 >test_num = test_num + 1
08ad : a907            >            lda #test_num   ;*** next tests' number
08af : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; PC modifying instructions except branches (NOP, JMP, JSR, RTS, BRK, RTI)
                        ; testing NOP
08b2 : a224                     ldx #$24
08b4 : a042                     ldy #$42
                                set_a $18,0
                       >            load_flag 0
08b6 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
08b8 : 48              >            pha         ;use stack to load status
08b9 : a918            >            lda #$18     ;precharge accu
08bb : 28              >            plp
                        
08bc : ea                       nop
                                tst_a $18,0
08bd : 08              >            php         ;save flags
08be : c918            >            cmp #$18     ;test result
                       >            trap_ne
08c0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
08c2 : 68              >            pla         ;load status
08c3 : 48              >            pha
                       >            cmp_flag 0
08c4 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
08c6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
08c8 : 28              >            plp         ;restore status
                        
08c9 : e024                     cpx #$24
                                trap_ne
08cb : d0fe            >        bne *           ;failed not equal (non zero)
                        
08cd : c042                     cpy #$42
                                trap_ne
08cf : d0fe            >        bne *           ;failed not equal (non zero)
                        
08d1 : a2db                     ldx #$db
08d3 : a0bd                     ldy #$bd
                                set_a $e7,$ff
                       >            load_flag $ff
08d5 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
08d7 : 48              >            pha         ;use stack to load status
08d8 : a9e7            >            lda #$e7     ;precharge accu
08da : 28              >            plp
                        
08db : ea                       nop
                                tst_a $e7,$ff
08dc : 08              >            php         ;save flags
08dd : c9e7            >            cmp #$e7     ;test result
                       >            trap_ne
08df : d0fe            >        bne *           ;failed not equal (non zero)
                       >
08e1 : 68              >            pla         ;load status
08e2 : 48              >            pha
                       >            cmp_flag $ff
08e3 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
08e5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
08e7 : 28              >            plp         ;restore status
                        
08e8 : e0db                     cpx #$db
                                trap_ne
08ea : d0fe            >        bne *           ;failed not equal (non zero)
                        
08ec : c0bd                     cpy #$bd
                                trap_ne
08ee : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
08f0 : ad0002          >            lda test_case   ;previous test
08f3 : c907            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
08f5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0008 =                 >test_num = test_num + 1
08f7 : a908            >            lda #test_num   ;*** next tests' number
08f9 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; jump absolute
                                set_stat $0
                       >            load_flag $0
08fc : a900            >            lda #$0             ;allow test to change I-flag (no mask)
                       >
08fe : 48              >            pha         ;use stack to load status
08ff : 28              >            plp
                        
0900 : a946                     lda #'F'
0902 : a241                     ldx #'A'
0904 : a052                     ldy #'R'        ;N=0, V=0, Z=0, C=0
0906 : 4c7434                   jmp test_far
0909 : ea                       nop
090a : ea                       nop
                                trap_ne         ;runover protection
090b : d0fe            >        bne *           ;failed not equal (non zero)
                        
090d : e8                       inx
090e : e8                       inx
090f :                  far_ret 
                                trap_eq         ;returned flags OK?
090f : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_pl
0911 : 10fe            >        bpl *           ;failed plus (bit 7 clear)
                        
                                trap_cc
0913 : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_vc
0915 : 50fe            >        bvc *           ;failed overflow clear
                        
0917 : c9ec                     cmp #('F'^$aa)  ;returned registers OK?
                                trap_ne
0919 : d0fe            >        bne *           ;failed not equal (non zero)
                        
091b : e042                     cpx #('A'+1)
                                trap_ne
091d : d0fe            >        bne *           ;failed not equal (non zero)
                        
091f : c04f                     cpy #('R'-3)
                                trap_ne
0921 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0923 : ca                       dex
0924 : c8                       iny
0925 : c8                       iny
0926 : c8                       iny
0927 : 49aa                     eor #$aa        ;N=0, V=1, Z=0, C=1
0929 : 4c3209                   jmp test_near
092c : ea                       nop
092d : ea                       nop
                                trap_ne         ;runover protection
092e : d0fe            >        bne *           ;failed not equal (non zero)
                        
0930 : e8                       inx
0931 : e8                       inx
0932 :                  test_near
                                trap_eq         ;passed flags OK?
0932 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_mi
0934 : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
                                trap_cc
0936 : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_vc
0938 : 50fe            >        bvc *           ;failed overflow clear
                        
093a : c946                     cmp #'F'        ;passed registers OK?
                                trap_ne
093c : d0fe            >        bne *           ;failed not equal (non zero)
                        
093e : e041                     cpx #'A'
                                trap_ne
0940 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0942 : c052                     cpy #'R'
                                trap_ne
0944 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
0946 : ad0002          >            lda test_case   ;previous test
0949 : c908            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
094b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0009 =                 >test_num = test_num + 1
094d : a909            >            lda #test_num   ;*** next tests' number
094f : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; jump indirect
                                set_stat 0
                       >            load_flag 0
0952 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0954 : 48              >            pha         ;use stack to load status
0955 : 28              >            plp
                        
0956 : a949                     lda #'I'
0958 : a24e                     ldx #'N'
095a : a044                     ldy #'D'        ;N=0, V=0, Z=0, C=0
095c : 6ca234                   jmp (ptr_tst_ind)
095f : ea                       nop
                                trap_ne         ;runover protection
0960 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0962 : 88                       dey
0963 : 88                       dey
0964 :                  ind_ret 
0964 : 08                       php             ;either SP or Y count will fail, if we do not hit
0965 : 88                       dey
0966 : 88                       dey
0967 : 88                       dey
0968 : 28                       plp
                                trap_eq         ;returned flags OK?
0969 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_pl
096b : 10fe            >        bpl *           ;failed plus (bit 7 clear)
                        
                                trap_cc
096d : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_vc
096f : 50fe            >        bvc *           ;failed overflow clear
                        
0971 : c9e3                     cmp #('I'^$aa)  ;returned registers OK?
                                trap_ne
0973 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0975 : e04f                     cpx #('N'+1)
                                trap_ne
0977 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0979 : c03e                     cpy #('D'-6)
                                trap_ne
097b : d0fe            >        bne *           ;failed not equal (non zero)
                        
097d : ba                       tsx             ;SP check
097e : e0ff                     cpx #$ff
                                trap_ne
0980 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
0982 : ad0002          >            lda test_case   ;previous test
0985 : c909            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0987 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
000a =                 >test_num = test_num + 1
0989 : a90a            >            lda #test_num   ;*** next tests' number
098b : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; jump subroutine & return from subroutine
                                set_stat 0
                       >            load_flag 0
098e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0990 : 48              >            pha         ;use stack to load status
0991 : 28              >            plp
                        
0992 : a94a                     lda #'J'
0994 : a253                     ldx #'S'
0996 : a052                     ldy #'R'        ;N=0, V=0, Z=0, C=0
0998 : 20e134                   jsr test_jsr
099a =                  jsr_ret = *-1           ;last address of jsr = return address
099b : 08                       php             ;either SP or Y count will fail, if we do not hit
099c : 88                       dey
099d : 88                       dey
099e : 88                       dey
099f : 28                       plp
                                trap_eq         ;returned flags OK?
09a0 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_pl
09a2 : 10fe            >        bpl *           ;failed plus (bit 7 clear)
                        
                                trap_cc
09a4 : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_vc
09a6 : 50fe            >        bvc *           ;failed overflow clear
                        
09a8 : c9e0                     cmp #('J'^$aa)  ;returned registers OK?
                                trap_ne
09aa : d0fe            >        bne *           ;failed not equal (non zero)
                        
09ac : e054                     cpx #('S'+1)
                                trap_ne
09ae : d0fe            >        bne *           ;failed not equal (non zero)
                        
09b0 : c04c                     cpy #('R'-6)
                                trap_ne
09b2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
09b4 : ba                       tsx             ;sp?
09b5 : e0ff                     cpx #$ff
                                trap_ne
09b7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
09b9 : ad0002          >            lda test_case   ;previous test
09bc : c90a            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
09be : d0fe            >        bne *           ;failed not equal (non zero)
                       >
000b =                 >test_num = test_num + 1
09c0 : a90b            >            lda #test_num   ;*** next tests' number
09c2 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; break & return from interrupt
                            if ROM_vectors = 1
                                load_flag 0     ;with interrupts enabled if allowed!
                                pha
                                lda #'B'
                                ldx #'R'
                                ldy #'K'
                                plp             ;N=0, V=0, Z=0, C=0
                                brk
                            elseif RTI_test = 1
                                lda #hi brk_ret0 ;emulated break
                                pha
                                lda #lo brk_ret0
                                pha
                                load_flag fao    ;set break & unused on stack
                                pha
                                load_flag intdis ;during interrupt
                                pha
                                lda #'B'
                                ldx #'R'
                                ldy #'K'
                                plp             ;N=0, V=0, Z=0, C=0
                                jmp irq_trap
                            endif
                            if RTI_test = 1
                                dey             ;should not be executed
                        brk_ret0                ;address of break return
                                php             ;either SP or Y count will fail, if we do not hit
                                dey
                                dey
                                dey
                                cmp #'B'^$aa    ;returned registers OK?
                                ;the IRQ vector was never executed if A & X stay unmodified
                                trap_ne
                                cpx #'R'+1
                                trap_ne
                                cpy #'K'-6
                                trap_ne
                                pla             ;returned flags OK (unchanged)?
                                cmp_flag 0
                                trap_ne
                                tsx             ;sp?
                                cpx #$ff
                                trap_ne
                            endif
                            if ROM_vectors = 1
                                load_flag $ff   ;with interrupts disabled if allowed!
                                pha
                                lda #$ff-'B'
                                ldx #$ff-'R'
                                ldy #$ff-'K'
                                plp             ;N=1, V=1, Z=1, C=1
                                brk
                            elseif RTI_test = 1
                                lda #hi brk_ret1 ;emulated break
                                pha
                                lda #lo brk_ret1
                                pha
                                load_flag $ff
                                pha             ;set break & unused on stack
                                pha             ;actual flags
                                lda #$ff-'B'
                                ldx #$ff-'R'
                                ldy #$ff-'K'
                                plp             ;N=1, V=1, Z=1, C=1
                                jmp irq_trap
                            endif
                            if RTI_test = 1
                                dey             ;should not be executed
                        brk_ret1                ;address of break return
                                php             ;either SP or Y count will fail, if we do not hit
                                dey
                                dey
                                dey
                                cmp #($ff-'B')^$aa  ;returned registers OK?
                                ;the IRQ vector was never executed if A & X stay unmodified
                                trap_ne
                                cpx #$ff-'R'+1
                                trap_ne
                                cpy #$ff-'K'-6
                                trap_ne
                                pla             ;returned flags OK (unchanged)?
                                cmp_flag $ff
                                trap_ne
                                tsx             ;sp?
                                cpx #$ff
                                trap_ne
                            endif
                                next_test
09c5 : ad0002          >            lda test_case   ;previous test
09c8 : c90b            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
09ca : d0fe            >        bne *           ;failed not equal (non zero)
                       >
000c =                 >test_num = test_num + 1
09cc : a90c            >            lda #test_num   ;*** next tests' number
09ce : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                         
                        ; test set and clear flags CLC CLI CLD CLV SEC SEI SED
                                set_stat $ff
                       >            load_flag $ff
09d1 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
09d3 : 48              >            pha         ;use stack to load status
09d4 : 28              >            plp
                        
09d5 : 18                       clc
                                tst_stat $ff-carry
09d6 : 08              >            php         ;save status
09d7 : 68              >            pla         ;use stack to retrieve status
09d8 : 48              >            pha
                       >            cmp_flag $ff-carry
09d9 : c9fe            >            cmp #($ff-carry|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
09db : d0fe            >        bne *           ;failed not equal (non zero)
                       >
09dd : 28              >            plp         ;restore status
                        
09de : 38                       sec
                                tst_stat $ff
09df : 08              >            php         ;save status
09e0 : 68              >            pla         ;use stack to retrieve status
09e1 : 48              >            pha
                       >            cmp_flag $ff
09e2 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
09e4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
09e6 : 28              >            plp         ;restore status
                        
                            if I_flag = 3
09e7 : 58                       cli
                                tst_stat $ff-intdis
09e8 : 08              >            php         ;save status
09e9 : 68              >            pla         ;use stack to retrieve status
09ea : 48              >            pha
                       >            cmp_flag $ff-intdis
09eb : c9fb            >            cmp #($ff-intdis|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
09ed : d0fe            >        bne *           ;failed not equal (non zero)
                       >
09ef : 28              >            plp         ;restore status
                        
09f0 : 78                       sei
                                tst_stat $ff
09f1 : 08              >            php         ;save status
09f2 : 68              >            pla         ;use stack to retrieve status
09f3 : 48              >            pha
                       >            cmp_flag $ff
09f4 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
09f6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
09f8 : 28              >            plp         ;restore status
                        
                            endif
09f9 : d8                       cld
                                tst_stat $ff-decmode
09fa : 08              >            php         ;save status
09fb : 68              >            pla         ;use stack to retrieve status
09fc : 48              >            pha
                       >            cmp_flag $ff-decmode
09fd : c9f7            >            cmp #($ff-decmode|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
09ff : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a01 : 28              >            plp         ;restore status
                        
0a02 : f8                       sed
                                tst_stat $ff
0a03 : 08              >            php         ;save status
0a04 : 68              >            pla         ;use stack to retrieve status
0a05 : 48              >            pha
                       >            cmp_flag $ff
0a06 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a08 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a0a : 28              >            plp         ;restore status
                        
0a0b : b8                       clv
                                tst_stat $ff-overfl
0a0c : 08              >            php         ;save status
0a0d : 68              >            pla         ;use stack to retrieve status
0a0e : 48              >            pha
                       >            cmp_flag $ff-overfl
0a0f : c9bf            >            cmp #($ff-overfl|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a11 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a13 : 28              >            plp         ;restore status
                        
                                set_stat 0
                       >            load_flag 0
0a14 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0a16 : 48              >            pha         ;use stack to load status
0a17 : 28              >            plp
                        
                                tst_stat 0
0a18 : 08              >            php         ;save status
0a19 : 68              >            pla         ;use stack to retrieve status
0a1a : 48              >            pha
                       >            cmp_flag 0
0a1b : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a1d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a1f : 28              >            plp         ;restore status
                        
0a20 : 38                       sec
                                tst_stat carry
0a21 : 08              >            php         ;save status
0a22 : 68              >            pla         ;use stack to retrieve status
0a23 : 48              >            pha
                       >            cmp_flag carry
0a24 : c931            >            cmp #(carry|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a26 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a28 : 28              >            plp         ;restore status
                        
0a29 : 18                       clc
                                tst_stat 0  
0a2a : 08              >            php         ;save status
0a2b : 68              >            pla         ;use stack to retrieve status
0a2c : 48              >            pha
                       >            cmp_flag 0  
0a2d : c930            >            cmp #(0  |fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a2f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a31 : 28              >            plp         ;restore status
                        
                            if I_flag = 3
0a32 : 78                       sei
                                tst_stat intdis
0a33 : 08              >            php         ;save status
0a34 : 68              >            pla         ;use stack to retrieve status
0a35 : 48              >            pha
                       >            cmp_flag intdis
0a36 : c934            >            cmp #(intdis|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a38 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a3a : 28              >            plp         ;restore status
                        
0a3b : 58                       cli
                                tst_stat 0
0a3c : 08              >            php         ;save status
0a3d : 68              >            pla         ;use stack to retrieve status
0a3e : 48              >            pha
                       >            cmp_flag 0
0a3f : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a41 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a43 : 28              >            plp         ;restore status
                        
                            endif  
0a44 : f8                       sed
                                tst_stat decmode
0a45 : 08              >            php         ;save status
0a46 : 68              >            pla         ;use stack to retrieve status
0a47 : 48              >            pha
                       >            cmp_flag decmode
0a48 : c938            >            cmp #(decmode|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a4a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a4c : 28              >            plp         ;restore status
                        
0a4d : d8                       cld
                                tst_stat 0  
0a4e : 08              >            php         ;save status
0a4f : 68              >            pla         ;use stack to retrieve status
0a50 : 48              >            pha
                       >            cmp_flag 0  
0a51 : c930            >            cmp #(0  |fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a53 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a55 : 28              >            plp         ;restore status
                        
                                set_stat overfl
                       >            load_flag overfl
0a56 : a940            >            lda #overfl             ;allow test to change I-flag (no mask)
                       >
0a58 : 48              >            pha         ;use stack to load status
0a59 : 28              >            plp
                        
                                tst_stat overfl
0a5a : 08              >            php         ;save status
0a5b : 68              >            pla         ;use stack to retrieve status
0a5c : 48              >            pha
                       >            cmp_flag overfl
0a5d : c970            >            cmp #(overfl|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a5f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a61 : 28              >            plp         ;restore status
                        
0a62 : b8                       clv
                                tst_stat 0
0a63 : 08              >            php         ;save status
0a64 : 68              >            pla         ;use stack to retrieve status
0a65 : 48              >            pha
                       >            cmp_flag 0
0a66 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a68 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a6a : 28              >            plp         ;restore status
                        
                                next_test
0a6b : ad0002          >            lda test_case   ;previous test
0a6e : c90c            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0a70 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
000d =                 >test_num = test_num + 1
0a72 : a90d            >            lda #test_num   ;*** next tests' number
0a74 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        ; testing index register increment/decrement and transfer
                        ; INX INY DEX DEY TAX TXA TAY TYA 
0a77 : a2fe                     ldx #$fe
                                set_stat $ff
                       >            load_flag $ff
0a79 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0a7b : 48              >            pha         ;use stack to load status
0a7c : 28              >            plp
                        
0a7d : e8                       inx             ;ff
                                tst_x $ff,$ff-zero
0a7e : 08              >            php         ;save flags
0a7f : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
0a81 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a83 : 68              >            pla         ;load status
0a84 : 48              >            pha
                       >            cmp_flag $ff-zero
0a85 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a87 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a89 : 28              >            plp         ;restore status
                        
0a8a : e8                       inx             ;00
                                tst_x 0,$ff-minus
0a8b : 08              >            php         ;save flags
0a8c : e000            >            cpx #0     ;test result
                       >            trap_ne
0a8e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a90 : 68              >            pla         ;load status
0a91 : 48              >            pha
                       >            cmp_flag $ff-minus
0a92 : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a94 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a96 : 28              >            plp         ;restore status
                        
0a97 : e8                       inx             ;01
                                tst_x 1,$ff-minus-zero
0a98 : 08              >            php         ;save flags
0a99 : e001            >            cpx #1     ;test result
                       >            trap_ne
0a9b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a9d : 68              >            pla         ;load status
0a9e : 48              >            pha
                       >            cmp_flag $ff-minus-zero
0a9f : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0aa1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0aa3 : 28              >            plp         ;restore status
                        
0aa4 : ca                       dex             ;00
                                tst_x 0,$ff-minus
0aa5 : 08              >            php         ;save flags
0aa6 : e000            >            cpx #0     ;test result
                       >            trap_ne
0aa8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0aaa : 68              >            pla         ;load status
0aab : 48              >            pha
                       >            cmp_flag $ff-minus
0aac : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0aae : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ab0 : 28              >            plp         ;restore status
                        
0ab1 : ca                       dex             ;ff
                                tst_x $ff,$ff-zero
0ab2 : 08              >            php         ;save flags
0ab3 : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
0ab5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ab7 : 68              >            pla         ;load status
0ab8 : 48              >            pha
                       >            cmp_flag $ff-zero
0ab9 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0abb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0abd : 28              >            plp         ;restore status
                        
0abe : ca                       dex             ;fe
                                set_stat 0
                       >            load_flag 0
0abf : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0ac1 : 48              >            pha         ;use stack to load status
0ac2 : 28              >            plp
                        
0ac3 : e8                       inx             ;ff
                                tst_x $ff,minus
0ac4 : 08              >            php         ;save flags
0ac5 : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
0ac7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ac9 : 68              >            pla         ;load status
0aca : 48              >            pha
                       >            cmp_flag minus
0acb : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0acd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0acf : 28              >            plp         ;restore status
                        
0ad0 : e8                       inx             ;00
                                tst_x 0,zero
0ad1 : 08              >            php         ;save flags
0ad2 : e000            >            cpx #0     ;test result
                       >            trap_ne
0ad4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ad6 : 68              >            pla         ;load status
0ad7 : 48              >            pha
                       >            cmp_flag zero
0ad8 : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0ada : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0adc : 28              >            plp         ;restore status
                        
0add : e8                       inx             ;01
                                tst_x 1,0
0ade : 08              >            php         ;save flags
0adf : e001            >            cpx #1     ;test result
                       >            trap_ne
0ae1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ae3 : 68              >            pla         ;load status
0ae4 : 48              >            pha
                       >            cmp_flag 0
0ae5 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0ae7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ae9 : 28              >            plp         ;restore status
                        
0aea : ca                       dex             ;00
                                tst_x 0,zero
0aeb : 08              >            php         ;save flags
0aec : e000            >            cpx #0     ;test result
                       >            trap_ne
0aee : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0af0 : 68              >            pla         ;load status
0af1 : 48              >            pha
                       >            cmp_flag zero
0af2 : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0af4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0af6 : 28              >            plp         ;restore status
                        
0af7 : ca                       dex             ;ff
                                tst_x $ff,minus
0af8 : 08              >            php         ;save flags
0af9 : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
0afb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0afd : 68              >            pla         ;load status
0afe : 48              >            pha
                       >            cmp_flag minus
0aff : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b01 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b03 : 28              >            plp         ;restore status
                        
                        
0b04 : a0fe                     ldy #$fe
                                set_stat $ff
                       >            load_flag $ff
0b06 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0b08 : 48              >            pha         ;use stack to load status
0b09 : 28              >            plp
                        
0b0a : c8                       iny             ;ff
                                tst_y $ff,$ff-zero
0b0b : 08              >            php         ;save flags
0b0c : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
0b0e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b10 : 68              >            pla         ;load status
0b11 : 48              >            pha
                       >            cmp_flag $ff-zero
0b12 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b14 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b16 : 28              >            plp         ;restore status
                        
0b17 : c8                       iny             ;00
                                tst_y 0,$ff-minus
0b18 : 08              >            php         ;save flags
0b19 : c000            >            cpy #0     ;test result
                       >            trap_ne
0b1b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b1d : 68              >            pla         ;load status
0b1e : 48              >            pha
                       >            cmp_flag $ff-minus
0b1f : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b21 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b23 : 28              >            plp         ;restore status
                        
0b24 : c8                       iny             ;01
                                tst_y 1,$ff-minus-zero
0b25 : 08              >            php         ;save flags
0b26 : c001            >            cpy #1     ;test result
                       >            trap_ne
0b28 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b2a : 68              >            pla         ;load status
0b2b : 48              >            pha
                       >            cmp_flag $ff-minus-zero
0b2c : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b2e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b30 : 28              >            plp         ;restore status
                        
0b31 : 88                       dey             ;00
                                tst_y 0,$ff-minus
0b32 : 08              >            php         ;save flags
0b33 : c000            >            cpy #0     ;test result
                       >            trap_ne
0b35 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b37 : 68              >            pla         ;load status
0b38 : 48              >            pha
                       >            cmp_flag $ff-minus
0b39 : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b3b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b3d : 28              >            plp         ;restore status
                        
0b3e : 88                       dey             ;ff
                                tst_y $ff,$ff-zero
0b3f : 08              >            php         ;save flags
0b40 : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
0b42 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b44 : 68              >            pla         ;load status
0b45 : 48              >            pha
                       >            cmp_flag $ff-zero
0b46 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b48 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b4a : 28              >            plp         ;restore status
                        
0b4b : 88                       dey             ;fe
                                set_stat 0
                       >            load_flag 0
0b4c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0b4e : 48              >            pha         ;use stack to load status
0b4f : 28              >            plp
                        
0b50 : c8                       iny             ;ff
                                tst_y $ff,0+minus
0b51 : 08              >            php         ;save flags
0b52 : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
0b54 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b56 : 68              >            pla         ;load status
0b57 : 48              >            pha
                       >            cmp_flag 0+minus
0b58 : c9b0            >            cmp #(0+minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b5a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b5c : 28              >            plp         ;restore status
                        
0b5d : c8                       iny             ;00
                                tst_y 0,zero
0b5e : 08              >            php         ;save flags
0b5f : c000            >            cpy #0     ;test result
                       >            trap_ne
0b61 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b63 : 68              >            pla         ;load status
0b64 : 48              >            pha
                       >            cmp_flag zero
0b65 : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b67 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b69 : 28              >            plp         ;restore status
                        
0b6a : c8                       iny             ;01
                                tst_y 1,0
0b6b : 08              >            php         ;save flags
0b6c : c001            >            cpy #1     ;test result
                       >            trap_ne
0b6e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b70 : 68              >            pla         ;load status
0b71 : 48              >            pha
                       >            cmp_flag 0
0b72 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b74 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b76 : 28              >            plp         ;restore status
                        
0b77 : 88                       dey             ;00
                                tst_y 0,zero
0b78 : 08              >            php         ;save flags
0b79 : c000            >            cpy #0     ;test result
                       >            trap_ne
0b7b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b7d : 68              >            pla         ;load status
0b7e : 48              >            pha
                       >            cmp_flag zero
0b7f : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b81 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b83 : 28              >            plp         ;restore status
                        
0b84 : 88                       dey             ;ff
                                tst_y $ff,minus
0b85 : 08              >            php         ;save flags
0b86 : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
0b88 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b8a : 68              >            pla         ;load status
0b8b : 48              >            pha
                       >            cmp_flag minus
0b8c : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b8e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b90 : 28              >            plp         ;restore status
                        
                                        
0b91 : a2ff                     ldx #$ff
                                set_stat $ff
                       >            load_flag $ff
0b93 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0b95 : 48              >            pha         ;use stack to load status
0b96 : 28              >            plp
                        
0b97 : 8a                       txa
                                tst_a $ff,$ff-zero
0b98 : 08              >            php         ;save flags
0b99 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
0b9b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b9d : 68              >            pla         ;load status
0b9e : 48              >            pha
                       >            cmp_flag $ff-zero
0b9f : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0ba1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ba3 : 28              >            plp         ;restore status
                        
0ba4 : 08                       php
0ba5 : e8                       inx             ;00
0ba6 : 28                       plp
0ba7 : 8a                       txa
                                tst_a 0,$ff-minus
0ba8 : 08              >            php         ;save flags
0ba9 : c900            >            cmp #0     ;test result
                       >            trap_ne
0bab : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bad : 68              >            pla         ;load status
0bae : 48              >            pha
                       >            cmp_flag $ff-minus
0baf : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0bb1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bb3 : 28              >            plp         ;restore status
                        
0bb4 : 08                       php
0bb5 : e8                       inx             ;01
0bb6 : 28                       plp
0bb7 : 8a                       txa
                                tst_a 1,$ff-minus-zero
0bb8 : 08              >            php         ;save flags
0bb9 : c901            >            cmp #1     ;test result
                       >            trap_ne
0bbb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bbd : 68              >            pla         ;load status
0bbe : 48              >            pha
                       >            cmp_flag $ff-minus-zero
0bbf : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0bc1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bc3 : 28              >            plp         ;restore status
                        
                                set_stat 0
                       >            load_flag 0
0bc4 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0bc6 : 48              >            pha         ;use stack to load status
0bc7 : 28              >            plp
                        
0bc8 : 8a                       txa
                                tst_a 1,0
0bc9 : 08              >            php         ;save flags
0bca : c901            >            cmp #1     ;test result
                       >            trap_ne
0bcc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bce : 68              >            pla         ;load status
0bcf : 48              >            pha
                       >            cmp_flag 0
0bd0 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0bd2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bd4 : 28              >            plp         ;restore status
                        
0bd5 : 08                       php
0bd6 : ca                       dex             ;00
0bd7 : 28                       plp
0bd8 : 8a                       txa
                                tst_a 0,zero
0bd9 : 08              >            php         ;save flags
0bda : c900            >            cmp #0     ;test result
                       >            trap_ne
0bdc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bde : 68              >            pla         ;load status
0bdf : 48              >            pha
                       >            cmp_flag zero
0be0 : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0be2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0be4 : 28              >            plp         ;restore status
                        
0be5 : 08                       php
0be6 : ca                       dex             ;ff
0be7 : 28                       plp
0be8 : 8a                       txa
                                tst_a $ff,minus
0be9 : 08              >            php         ;save flags
0bea : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
0bec : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bee : 68              >            pla         ;load status
0bef : 48              >            pha
                       >            cmp_flag minus
0bf0 : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0bf2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bf4 : 28              >            plp         ;restore status
                        
                                                
0bf5 : a0ff                     ldy #$ff
                                set_stat $ff
                       >            load_flag $ff
0bf7 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0bf9 : 48              >            pha         ;use stack to load status
0bfa : 28              >            plp
                        
0bfb : 98                       tya
                                tst_a $ff,$ff-zero
0bfc : 08              >            php         ;save flags
0bfd : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
0bff : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c01 : 68              >            pla         ;load status
0c02 : 48              >            pha
                       >            cmp_flag $ff-zero
0c03 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c05 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c07 : 28              >            plp         ;restore status
                        
0c08 : 08                       php
0c09 : c8                       iny             ;00
0c0a : 28                       plp
0c0b : 98                       tya
                                tst_a 0,$ff-minus
0c0c : 08              >            php         ;save flags
0c0d : c900            >            cmp #0     ;test result
                       >            trap_ne
0c0f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c11 : 68              >            pla         ;load status
0c12 : 48              >            pha
                       >            cmp_flag $ff-minus
0c13 : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c15 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c17 : 28              >            plp         ;restore status
                        
0c18 : 08                       php
0c19 : c8                       iny             ;01
0c1a : 28                       plp
0c1b : 98                       tya
                                tst_a 1,$ff-minus-zero
0c1c : 08              >            php         ;save flags
0c1d : c901            >            cmp #1     ;test result
                       >            trap_ne
0c1f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c21 : 68              >            pla         ;load status
0c22 : 48              >            pha
                       >            cmp_flag $ff-minus-zero
0c23 : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c25 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c27 : 28              >            plp         ;restore status
                        
                                set_stat 0
                       >            load_flag 0
0c28 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0c2a : 48              >            pha         ;use stack to load status
0c2b : 28              >            plp
                        
0c2c : 98                       tya
                                tst_a 1,0
0c2d : 08              >            php         ;save flags
0c2e : c901            >            cmp #1     ;test result
                       >            trap_ne
0c30 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c32 : 68              >            pla         ;load status
0c33 : 48              >            pha
                       >            cmp_flag 0
0c34 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c36 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c38 : 28              >            plp         ;restore status
                        
0c39 : 08                       php
0c3a : 88                       dey             ;00
0c3b : 28                       plp
0c3c : 98                       tya
                                tst_a 0,zero
0c3d : 08              >            php         ;save flags
0c3e : c900            >            cmp #0     ;test result
                       >            trap_ne
0c40 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c42 : 68              >            pla         ;load status
0c43 : 48              >            pha
                       >            cmp_flag zero
0c44 : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c46 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c48 : 28              >            plp         ;restore status
                        
0c49 : 08                       php
0c4a : 88                       dey             ;ff
0c4b : 28                       plp
0c4c : 98                       tya
                                tst_a $ff,minus
0c4d : 08              >            php         ;save flags
0c4e : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
0c50 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c52 : 68              >            pla         ;load status
0c53 : 48              >            pha
                       >            cmp_flag minus
0c54 : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c56 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c58 : 28              >            plp         ;restore status
                        
                        
                                load_flag $ff
0c59 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                        
0c5b : 48                       pha
0c5c : a2ff                     ldx #$ff        ;ff
0c5e : 8a                       txa
0c5f : 28                       plp             
0c60 : a8                       tay
                                tst_y $ff,$ff-zero
0c61 : 08              >            php         ;save flags
0c62 : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
0c64 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c66 : 68              >            pla         ;load status
0c67 : 48              >            pha
                       >            cmp_flag $ff-zero
0c68 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c6a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c6c : 28              >            plp         ;restore status
                        
0c6d : 08                       php
0c6e : e8                       inx             ;00
0c6f : 8a                       txa
0c70 : 28                       plp
0c71 : a8                       tay
                                tst_y 0,$ff-minus
0c72 : 08              >            php         ;save flags
0c73 : c000            >            cpy #0     ;test result
                       >            trap_ne
0c75 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c77 : 68              >            pla         ;load status
0c78 : 48              >            pha
                       >            cmp_flag $ff-minus
0c79 : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c7b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c7d : 28              >            plp         ;restore status
                        
0c7e : 08                       php
0c7f : e8                       inx             ;01
0c80 : 8a                       txa
0c81 : 28                       plp
0c82 : a8                       tay
                                tst_y 1,$ff-minus-zero
0c83 : 08              >            php         ;save flags
0c84 : c001            >            cpy #1     ;test result
                       >            trap_ne
0c86 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c88 : 68              >            pla         ;load status
0c89 : 48              >            pha
                       >            cmp_flag $ff-minus-zero
0c8a : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c8c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c8e : 28              >            plp         ;restore status
                        
                                load_flag 0
0c8f : a900            >            lda #0             ;allow test to change I-flag (no mask)
                        
0c91 : 48                       pha
0c92 : a900                     lda #0
0c94 : 8a                       txa
0c95 : 28                       plp
0c96 : a8                       tay
                                tst_y 1,0
0c97 : 08              >            php         ;save flags
0c98 : c001            >            cpy #1     ;test result
                       >            trap_ne
0c9a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c9c : 68              >            pla         ;load status
0c9d : 48              >            pha
                       >            cmp_flag 0
0c9e : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0ca0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ca2 : 28              >            plp         ;restore status
                        
0ca3 : 08                       php
0ca4 : ca                       dex             ;00
0ca5 : 8a                       txa
0ca6 : 28                       plp
0ca7 : a8                       tay
                                tst_y 0,zero
0ca8 : 08              >            php         ;save flags
0ca9 : c000            >            cpy #0     ;test result
                       >            trap_ne
0cab : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0cad : 68              >            pla         ;load status
0cae : 48              >            pha
                       >            cmp_flag zero
0caf : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0cb1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0cb3 : 28              >            plp         ;restore status
                        
0cb4 : 08                       php
0cb5 : ca                       dex             ;ff
0cb6 : 8a                       txa
0cb7 : 28                       plp
0cb8 : a8                       tay
                                tst_y $ff,minus
0cb9 : 08              >            php         ;save flags
0cba : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
0cbc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0cbe : 68              >            pla         ;load status
0cbf : 48              >            pha
                       >            cmp_flag minus
0cc0 : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0cc2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0cc4 : 28              >            plp         ;restore status
                        
                        
                        
                                load_flag $ff
0cc5 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                        
0cc7 : 48                       pha
0cc8 : a0ff                     ldy #$ff        ;ff
0cca : 98                       tya
0ccb : 28                       plp
0ccc : aa                       tax
                                tst_x $ff,$ff-zero
0ccd : 08              >            php         ;save flags
0cce : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
0cd0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0cd2 : 68              >            pla         ;load status
0cd3 : 48              >            pha
                       >            cmp_flag $ff-zero
0cd4 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0cd6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0cd8 : 28              >            plp         ;restore status
                        
0cd9 : 08                       php
0cda : c8                       iny             ;00
0cdb : 98                       tya
0cdc : 28                       plp
0cdd : aa                       tax
                                tst_x 0,$ff-minus
0cde : 08              >            php         ;save flags
0cdf : e000            >            cpx #0     ;test result
                       >            trap_ne
0ce1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ce3 : 68              >            pla         ;load status
0ce4 : 48              >            pha
                       >            cmp_flag $ff-minus
0ce5 : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0ce7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ce9 : 28              >            plp         ;restore status
                        
0cea : 08                       php
0ceb : c8                       iny             ;01
0cec : 98                       tya
0ced : 28                       plp
0cee : aa                       tax
                                tst_x 1,$ff-minus-zero
0cef : 08              >            php         ;save flags
0cf0 : e001            >            cpx #1     ;test result
                       >            trap_ne
0cf2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0cf4 : 68              >            pla         ;load status
0cf5 : 48              >            pha
                       >            cmp_flag $ff-minus-zero
0cf6 : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0cf8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0cfa : 28              >            plp         ;restore status
                        
                                load_flag 0
0cfb : a900            >            lda #0             ;allow test to change I-flag (no mask)
                        
0cfd : 48                       pha
0cfe : a900                     lda #0          ;preset status
0d00 : 98                       tya
0d01 : 28                       plp
0d02 : aa                       tax
                                tst_x 1,0
0d03 : 08              >            php         ;save flags
0d04 : e001            >            cpx #1     ;test result
                       >            trap_ne
0d06 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d08 : 68              >            pla         ;load status
0d09 : 48              >            pha
                       >            cmp_flag 0
0d0a : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0d0c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d0e : 28              >            plp         ;restore status
                        
0d0f : 08                       php
0d10 : 88                       dey             ;00
0d11 : 98                       tya
0d12 : 28                       plp
0d13 : aa                       tax
                                tst_x 0,zero
0d14 : 08              >            php         ;save flags
0d15 : e000            >            cpx #0     ;test result
                       >            trap_ne
0d17 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d19 : 68              >            pla         ;load status
0d1a : 48              >            pha
                       >            cmp_flag zero
0d1b : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0d1d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d1f : 28              >            plp         ;restore status
                        
0d20 : 08                       php
0d21 : 88                       dey             ;ff
0d22 : 98                       tya
0d23 : 28                       plp
0d24 : aa                       tax
                                tst_x $ff,minus
0d25 : 08              >            php         ;save flags
0d26 : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
0d28 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d2a : 68              >            pla         ;load status
0d2b : 48              >            pha
                       >            cmp_flag minus
0d2c : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0d2e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d30 : 28              >            plp         ;restore status
                        
                                next_test
0d31 : ad0002          >            lda test_case   ;previous test
0d34 : c90d            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0d36 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
000e =                 >test_num = test_num + 1
0d38 : a90e            >            lda #test_num   ;*** next tests' number
0d3a : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                             
                        ;TSX sets NZ - TXS does not
                        ;  This section also tests for proper stack wrap around.
0d3d : a201                     ldx #1          ;01
                                set_stat $ff
                       >            load_flag $ff
0d3f : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0d41 : 48              >            pha         ;use stack to load status
0d42 : 28              >            plp
                        
0d43 : 9a                       txs
0d44 : 08                       php
0d45 : ad0101                   lda $101
                                cmp_flag $ff
0d48 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0d4a : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
0d4c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0d4e : 48              >            pha         ;use stack to load status
0d4f : 28              >            plp
                        
0d50 : 9a                       txs
0d51 : 08                       php
0d52 : ad0101                   lda $101
                                cmp_flag 0
0d55 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0d57 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0d59 : ca                       dex             ;00
                                set_stat $ff
                       >            load_flag $ff
0d5a : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0d5c : 48              >            pha         ;use stack to load status
0d5d : 28              >            plp
                        
0d5e : 9a                       txs
0d5f : 08                       php
0d60 : ad0001                   lda $100
                                cmp_flag $ff
0d63 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0d65 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
0d67 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0d69 : 48              >            pha         ;use stack to load status
0d6a : 28              >            plp
                        
0d6b : 9a                       txs
0d6c : 08                       php
0d6d : ad0001                   lda $100
                                cmp_flag 0
0d70 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0d72 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0d74 : ca                       dex             ;ff
                                set_stat $ff
                       >            load_flag $ff
0d75 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0d77 : 48              >            pha         ;use stack to load status
0d78 : 28              >            plp
                        
0d79 : 9a                       txs
0d7a : 08                       php
0d7b : adff01                   lda $1ff
                                cmp_flag $ff
0d7e : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0d80 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
0d82 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0d84 : 48              >            pha         ;use stack to load status
0d85 : 28              >            plp
                        
0d86 : 9a                       txs
0d87 : 08                       php
0d88 : adff01                   lda $1ff
                                cmp_flag 0
0d8b : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                        
                                
0d8d : a201                     ldx #1
0d8f : 9a                       txs             ;sp=01
                                set_stat $ff
                       >            load_flag $ff
0d90 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0d92 : 48              >            pha         ;use stack to load status
0d93 : 28              >            plp
                        
0d94 : ba                       tsx             ;clears Z, N
0d95 : 08                       php             ;sp=00
0d96 : e001                     cpx #1
                                trap_ne
0d98 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0d9a : ad0101                   lda $101
                                cmp_flag $ff-minus-zero
0d9d : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0d9f : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
0da1 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0da3 : 48              >            pha         ;use stack to load status
0da4 : 28              >            plp
                        
0da5 : ba                       tsx             ;clears N, sets Z
0da6 : 08                       php             ;sp=ff
0da7 : e000                     cpx #0
                                trap_ne
0da9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0dab : ad0001                   lda $100
                                cmp_flag $ff-minus
0dae : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0db0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
0db2 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0db4 : 48              >            pha         ;use stack to load status
0db5 : 28              >            plp
                        
0db6 : ba                       tsx             ;clears N, sets Z
0db7 : 08                       php             ;sp=fe
0db8 : e0ff                     cpx #$ff
                                trap_ne
0dba : d0fe            >        bne *           ;failed not equal (non zero)
                        
0dbc : adff01                   lda $1ff
                                cmp_flag $ff-zero
0dbf : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0dc1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                
0dc3 : a201                     ldx #1
0dc5 : 9a                       txs             ;sp=01
                                set_stat 0
                       >            load_flag 0
0dc6 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0dc8 : 48              >            pha         ;use stack to load status
0dc9 : 28              >            plp
                        
0dca : ba                       tsx             ;clears Z, N
0dcb : 08                       php             ;sp=00
0dcc : e001                     cpx #1
                                trap_ne
0dce : d0fe            >        bne *           ;failed not equal (non zero)
                        
0dd0 : ad0101                   lda $101
                                cmp_flag 0
0dd3 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0dd5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
0dd7 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0dd9 : 48              >            pha         ;use stack to load status
0dda : 28              >            plp
                        
0ddb : ba                       tsx             ;clears N, sets Z
0ddc : 08                       php             ;sp=ff
0ddd : e000                     cpx #0
                                trap_ne
0ddf : d0fe            >        bne *           ;failed not equal (non zero)
                        
0de1 : ad0001                   lda $100
                                cmp_flag zero
0de4 : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0de6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
0de8 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0dea : 48              >            pha         ;use stack to load status
0deb : 28              >            plp
                        
0dec : ba                       tsx             ;clears N, sets Z
0ded : 08                       php             ;sp=fe
0dee : e0ff                     cpx #$ff
                                trap_ne
0df0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0df2 : adff01                   lda $1ff
                                cmp_flag minus
0df5 : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0df7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0df9 : 68                       pla             ;sp=ff
                                next_test
0dfa : ad0002          >            lda test_case   ;previous test
0dfd : c90e            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0dff : d0fe            >        bne *           ;failed not equal (non zero)
                       >
000f =                 >test_num = test_num + 1
0e01 : a90f            >            lda #test_num   ;*** next tests' number
0e03 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; testing index register load & store LDY LDX STY STX all addressing modes
                        ; LDX / STX - zp,y / abs,y
0e06 : a003                     ldy #3
0e08 :                  tldx    
                                set_stat 0
                       >            load_flag 0
0e08 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0e0a : 48              >            pha         ;use stack to load status
0e0b : 28              >            plp
                        
0e0c : b609                     ldx zp1,y
0e0e : 08                       php         ;test stores do not alter flags
0e0f : 8a                       txa
0e10 : 49c3                     eor #$c3
0e12 : 28                       plp
0e13 : 990302                   sta abst,y
0e16 : 08                       php         ;flags after load/store sequence
0e17 : 49c3                     eor #$c3
0e19 : d91702                   cmp abs1,y  ;test result
                                trap_ne
0e1c : d0fe            >        bne *           ;failed not equal (non zero)
                        
0e1e : 68                       pla         ;load status
                                eor_flag 0
0e1f : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
0e21 : d91c02                   cmp fLDx,y  ;test flags
                                trap_ne
0e24 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0e26 : 88                       dey
0e27 : 10df                     bpl tldx                  
                        
0e29 : a003                     ldy #3
0e2b :                  tldx1   
                                set_stat $ff
                       >            load_flag $ff
0e2b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0e2d : 48              >            pha         ;use stack to load status
0e2e : 28              >            plp
                        
0e2f : b609                     ldx zp1,y
0e31 : 08                       php         ;test stores do not alter flags
0e32 : 8a                       txa
0e33 : 49c3                     eor #$c3
0e35 : 28                       plp
0e36 : 990302                   sta abst,y
0e39 : 08                       php         ;flags after load/store sequence
0e3a : 49c3                     eor #$c3
0e3c : d91702                   cmp abs1,y  ;test result
                                trap_ne
0e3f : d0fe            >        bne *           ;failed not equal (non zero)
                        
0e41 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
0e42 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
0e44 : d91c02                   cmp fLDx,y  ;test flags
                                trap_ne
0e47 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0e49 : 88                       dey
0e4a : 10df                     bpl tldx1                  
                        
0e4c : a003                     ldy #3
0e4e :                  tldx2   
                                set_stat 0
                       >            load_flag 0
0e4e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0e50 : 48              >            pha         ;use stack to load status
0e51 : 28              >            plp
                        
0e52 : be1702                   ldx abs1,y
0e55 : 08                       php         ;test stores do not alter flags
0e56 : 8a                       txa
0e57 : 49c3                     eor #$c3
0e59 : aa                       tax
0e5a : 28                       plp
0e5b : 9602                     stx zpt,y
0e5d : 08                       php         ;flags after load/store sequence
0e5e : 49c3                     eor #$c3
0e60 : d90900                   cmp zp1,y   ;test result
                                trap_ne
0e63 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0e65 : 68                       pla         ;load status
                                eor_flag 0
0e66 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
0e68 : d91c02                   cmp fLDx,y  ;test flags
                                trap_ne
0e6b : d0fe            >        bne *           ;failed not equal (non zero)
                        
0e6d : 88                       dey
0e6e : 10de                     bpl tldx2                  
                        
0e70 : a003                     ldy #3
0e72 :                  tldx3   
                                set_stat $ff
                       >            load_flag $ff
0e72 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0e74 : 48              >            pha         ;use stack to load status
0e75 : 28              >            plp
                        
0e76 : be1702                   ldx abs1,y
0e79 : 08                       php         ;test stores do not alter flags
0e7a : 8a                       txa
0e7b : 49c3                     eor #$c3
0e7d : aa                       tax
0e7e : 28                       plp
0e7f : 9602                     stx zpt,y
0e81 : 08                       php         ;flags after load/store sequence
0e82 : 49c3                     eor #$c3
0e84 : d90900                   cmp zp1,y   ;test result
                                trap_ne
0e87 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0e89 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
0e8a : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
0e8c : d91c02                   cmp fLDx,y  ;test flags
                                trap_ne
0e8f : d0fe            >        bne *           ;failed not equal (non zero)
                        
0e91 : 88                       dey
0e92 : 10de                     bpl tldx3
                                
0e94 : a003                     ldy #3      ;testing store result
0e96 : a200                     ldx #0
0e98 : b90200           tstx    lda zpt,y
0e9b : 49c3                     eor #$c3
0e9d : d90900                   cmp zp1,y
                                trap_ne     ;store to zp data
0ea0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0ea2 : 9602                     stx zpt,y   ;clear                
0ea4 : b90302                   lda abst,y
0ea7 : 49c3                     eor #$c3
0ea9 : d91702                   cmp abs1,y
                                trap_ne     ;store to abs data
0eac : d0fe            >        bne *           ;failed not equal (non zero)
                        
0eae : 8a                       txa
0eaf : 990302                   sta abst,y  ;clear                
0eb2 : 88                       dey
0eb3 : 10e3                     bpl tstx
                                next_test
0eb5 : ad0002          >            lda test_case   ;previous test
0eb8 : c90f            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0eba : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0010 =                 >test_num = test_num + 1
0ebc : a910            >            lda #test_num   ;*** next tests' number
0ebe : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; indexed wraparound test (only zp should wrap)
0ec1 : a0fd                     ldy #3+$fa
0ec3 : b60f             tldx4   ldx zp1-$fa&$ff,y   ;wrap on indexed zp
0ec5 : 8a                       txa
0ec6 : 990901                   sta abst-$fa,y      ;no STX abs,y!
0ec9 : 88                       dey
0eca : c0fa                     cpy #$fa
0ecc : b0f5                     bcs tldx4                  
0ece : a0fd                     ldy #3+$fa
0ed0 : be1d01           tldx5   ldx abs1-$fa,y      ;no wrap on indexed abs
0ed3 : 9608                     stx zpt-$fa&$ff,y
0ed5 : 88                       dey
0ed6 : c0fa                     cpy #$fa
0ed8 : b0f6                     bcs tldx5                  
0eda : a003                     ldy #3      ;testing wraparound result
0edc : a200                     ldx #0
0ede : b90200           tstx1   lda zpt,y
0ee1 : d90900                   cmp zp1,y
                                trap_ne     ;store to zp data
0ee4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0ee6 : 9602                     stx zpt,y   ;clear                
0ee8 : b90302                   lda abst,y
0eeb : d91702                   cmp abs1,y
                                trap_ne     ;store to abs data
0eee : d0fe            >        bne *           ;failed not equal (non zero)
                        
0ef0 : 8a                       txa
0ef1 : 990302                   sta abst,y  ;clear                
0ef4 : 88                       dey
0ef5 : 10e7                     bpl tstx1
                                next_test
0ef7 : ad0002          >            lda test_case   ;previous test
0efa : c910            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0efc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0011 =                 >test_num = test_num + 1
0efe : a911            >            lda #test_num   ;*** next tests' number
0f00 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; LDY / STY - zp,x / abs,x
0f03 : a203                     ldx #3
0f05 :                  tldy    
                                set_stat 0
                       >            load_flag 0
0f05 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0f07 : 48              >            pha         ;use stack to load status
0f08 : 28              >            plp
                        
0f09 : b409                     ldy zp1,x
0f0b : 08                       php         ;test stores do not alter flags
0f0c : 98                       tya
0f0d : 49c3                     eor #$c3
0f0f : 28                       plp
0f10 : 9d0302                   sta abst,x
0f13 : 08                       php         ;flags after load/store sequence
0f14 : 49c3                     eor #$c3
0f16 : dd1702                   cmp abs1,x  ;test result
                                trap_ne
0f19 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0f1b : 68                       pla         ;load status
                                eor_flag 0
0f1c : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
0f1e : dd1c02                   cmp fLDx,x  ;test flags
                                trap_ne
0f21 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0f23 : ca                       dex
0f24 : 10df                     bpl tldy                  
                        
0f26 : a203                     ldx #3
0f28 :                  tldy1   
                                set_stat $ff
                       >            load_flag $ff
0f28 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0f2a : 48              >            pha         ;use stack to load status
0f2b : 28              >            plp
                        
0f2c : b409                     ldy zp1,x
0f2e : 08                       php         ;test stores do not alter flags
0f2f : 98                       tya
0f30 : 49c3                     eor #$c3
0f32 : 28                       plp
0f33 : 9d0302                   sta abst,x
0f36 : 08                       php         ;flags after load/store sequence
0f37 : 49c3                     eor #$c3
0f39 : dd1702                   cmp abs1,x  ;test result
                                trap_ne
0f3c : d0fe            >        bne *           ;failed not equal (non zero)
                        
0f3e : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
0f3f : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
0f41 : dd1c02                   cmp fLDx,x  ;test flags
                                trap_ne
0f44 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0f46 : ca                       dex
0f47 : 10df                     bpl tldy1                  
                        
0f49 : a203                     ldx #3
0f4b :                  tldy2   
                                set_stat 0
                       >            load_flag 0
0f4b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0f4d : 48              >            pha         ;use stack to load status
0f4e : 28              >            plp
                        
0f4f : bc1702                   ldy abs1,x
0f52 : 08                       php         ;test stores do not alter flags
0f53 : 98                       tya
0f54 : 49c3                     eor #$c3
0f56 : a8                       tay
0f57 : 28                       plp
0f58 : 9402                     sty zpt,x
0f5a : 08                       php         ;flags after load/store sequence
0f5b : 49c3                     eor #$c3
0f5d : d509                     cmp zp1,x   ;test result
                                trap_ne
0f5f : d0fe            >        bne *           ;failed not equal (non zero)
                        
0f61 : 68                       pla         ;load status
                                eor_flag 0
0f62 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
0f64 : dd1c02                   cmp fLDx,x  ;test flags
                                trap_ne
0f67 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0f69 : ca                       dex
0f6a : 10df                     bpl tldy2                  
                        
0f6c : a203                     ldx #3
0f6e :                  tldy3
                                set_stat $ff
                       >            load_flag $ff
0f6e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0f70 : 48              >            pha         ;use stack to load status
0f71 : 28              >            plp
                        
0f72 : bc1702                   ldy abs1,x
0f75 : 08                       php         ;test stores do not alter flags
0f76 : 98                       tya
0f77 : 49c3                     eor #$c3
0f79 : a8                       tay
0f7a : 28                       plp
0f7b : 9402                     sty zpt,x
0f7d : 08                       php         ;flags after load/store sequence
0f7e : 49c3                     eor #$c3
0f80 : d509                     cmp zp1,x   ;test result
                                trap_ne
0f82 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0f84 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
0f85 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
0f87 : dd1c02                   cmp fLDx,x  ;test flags
                                trap_ne
0f8a : d0fe            >        bne *           ;failed not equal (non zero)
                        
0f8c : ca                       dex
0f8d : 10df                     bpl tldy3
                        
0f8f : a203                     ldx #3      ;testing store result
0f91 : a000                     ldy #0
0f93 : b502             tsty    lda zpt,x
0f95 : 49c3                     eor #$c3
0f97 : d509                     cmp zp1,x
                                trap_ne     ;store to zp,x data
0f99 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0f9b : 9402                     sty zpt,x   ;clear                
0f9d : bd0302                   lda abst,x
0fa0 : 49c3                     eor #$c3
0fa2 : dd1702                   cmp abs1,x
                                trap_ne     ;store to abs,x data
0fa5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0fa7 : 8a                       txa
0fa8 : 9d0302                   sta abst,x  ;clear                
0fab : ca                       dex
0fac : 10e5                     bpl tsty
                                next_test
0fae : ad0002          >            lda test_case   ;previous test
0fb1 : c911            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0fb3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0012 =                 >test_num = test_num + 1
0fb5 : a912            >            lda #test_num   ;*** next tests' number
0fb7 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; indexed wraparound test (only zp should wrap)
0fba : a2fd                     ldx #3+$fa
0fbc : b40f             tldy4   ldy zp1-$fa&$ff,x   ;wrap on indexed zp
0fbe : 98                       tya
0fbf : 9d0901                   sta abst-$fa,x      ;no STX abs,x!
0fc2 : ca                       dex
0fc3 : e0fa                     cpx #$fa
0fc5 : b0f5                     bcs tldy4                  
0fc7 : a2fd                     ldx #3+$fa
0fc9 : bc1d01           tldy5   ldy abs1-$fa,x      ;no wrap on indexed abs
0fcc : 9408                     sty zpt-$fa&$ff,x
0fce : ca                       dex
0fcf : e0fa                     cpx #$fa
0fd1 : b0f6                     bcs tldy5                  
0fd3 : a203                     ldx #3      ;testing wraparound result
0fd5 : a000                     ldy #0
0fd7 : b502             tsty1   lda zpt,x
0fd9 : d509                     cmp zp1,x
                                trap_ne     ;store to zp,x data
0fdb : d0fe            >        bne *           ;failed not equal (non zero)
                        
0fdd : 9402                     sty zpt,x   ;clear                
0fdf : bd0302                   lda abst,x
0fe2 : dd1702                   cmp abs1,x
                                trap_ne     ;store to abs,x data
0fe5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0fe7 : 8a                       txa
0fe8 : 9d0302                   sta abst,x  ;clear                
0feb : ca                       dex
0fec : 10e9                     bpl tsty1
                                next_test
0fee : ad0002          >            lda test_case   ;previous test
0ff1 : c912            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0ff3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0013 =                 >test_num = test_num + 1
0ff5 : a913            >            lda #test_num   ;*** next tests' number
0ff7 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; LDX / STX - zp / abs / #
                                set_stat 0  
                       >            load_flag 0  
0ffa : a900            >            lda #0               ;allow test to change I-flag (no mask)
                       >
0ffc : 48              >            pha         ;use stack to load status
0ffd : 28              >            plp
                        
0ffe : a609                     ldx zp1
1000 : 08                       php         ;test stores do not alter flags
1001 : 8a                       txa
1002 : 49c3                     eor #$c3
1004 : aa                       tax
1005 : 28                       plp
1006 : 8e0302                   stx abst
1009 : 08                       php         ;flags after load/store sequence
100a : 49c3                     eor #$c3
100c : aa                       tax
100d : e0c3                     cpx #$c3    ;test result
                                trap_ne
100f : d0fe            >        bne *           ;failed not equal (non zero)
                        
1011 : 68                       pla         ;load status
                                eor_flag 0
1012 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1014 : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
1017 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1019 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
101b : 48              >            pha         ;use stack to load status
101c : 28              >            plp
                        
101d : a60a                     ldx zp1+1
101f : 08                       php         ;test stores do not alter flags
1020 : 8a                       txa
1021 : 49c3                     eor #$c3
1023 : aa                       tax
1024 : 28                       plp
1025 : 8e0402                   stx abst+1
1028 : 08                       php         ;flags after load/store sequence
1029 : 49c3                     eor #$c3
102b : aa                       tax
102c : e082                     cpx #$82    ;test result
                                trap_ne
102e : d0fe            >        bne *           ;failed not equal (non zero)
                        
1030 : 68                       pla         ;load status
                                eor_flag 0
1031 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1033 : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
1036 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1038 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
103a : 48              >            pha         ;use stack to load status
103b : 28              >            plp
                        
103c : a60b                     ldx zp1+2
103e : 08                       php         ;test stores do not alter flags
103f : 8a                       txa
1040 : 49c3                     eor #$c3
1042 : aa                       tax
1043 : 28                       plp
1044 : 8e0502                   stx abst+2
1047 : 08                       php         ;flags after load/store sequence
1048 : 49c3                     eor #$c3
104a : aa                       tax
104b : e041                     cpx #$41    ;test result
                                trap_ne
104d : d0fe            >        bne *           ;failed not equal (non zero)
                        
104f : 68                       pla         ;load status
                                eor_flag 0
1050 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1052 : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
1055 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1057 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1059 : 48              >            pha         ;use stack to load status
105a : 28              >            plp
                        
105b : a60c                     ldx zp1+3
105d : 08                       php         ;test stores do not alter flags
105e : 8a                       txa
105f : 49c3                     eor #$c3
1061 : aa                       tax
1062 : 28                       plp
1063 : 8e0602                   stx abst+3
1066 : 08                       php         ;flags after load/store sequence
1067 : 49c3                     eor #$c3
1069 : aa                       tax
106a : e000                     cpx #0      ;test result
                                trap_ne
106c : d0fe            >        bne *           ;failed not equal (non zero)
                        
106e : 68                       pla         ;load status
                                eor_flag 0
106f : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1071 : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
1074 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
1076 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1078 : 48              >            pha         ;use stack to load status
1079 : 28              >            plp
                        
107a : a609                     ldx zp1  
107c : 08                       php         ;test stores do not alter flags
107d : 8a                       txa
107e : 49c3                     eor #$c3
1080 : aa                       tax
1081 : 28                       plp
1082 : 8e0302                   stx abst  
1085 : 08                       php         ;flags after load/store sequence
1086 : 49c3                     eor #$c3
1088 : aa                       tax
1089 : e0c3                     cpx #$c3    ;test result
                                trap_ne     ;
108b : d0fe            >        bne *           ;failed not equal (non zero)
                        
108d : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
108e : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1090 : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
1093 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1095 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1097 : 48              >            pha         ;use stack to load status
1098 : 28              >            plp
                        
1099 : a60a                     ldx zp1+1
109b : 08                       php         ;test stores do not alter flags
109c : 8a                       txa
109d : 49c3                     eor #$c3
109f : aa                       tax
10a0 : 28                       plp
10a1 : 8e0402                   stx abst+1
10a4 : 08                       php         ;flags after load/store sequence
10a5 : 49c3                     eor #$c3
10a7 : aa                       tax
10a8 : e082                     cpx #$82    ;test result
                                trap_ne
10aa : d0fe            >        bne *           ;failed not equal (non zero)
                        
10ac : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
10ad : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
10af : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
10b2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
10b4 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
10b6 : 48              >            pha         ;use stack to load status
10b7 : 28              >            plp
                        
10b8 : a60b                     ldx zp1+2
10ba : 08                       php         ;test stores do not alter flags
10bb : 8a                       txa
10bc : 49c3                     eor #$c3
10be : aa                       tax
10bf : 28                       plp
10c0 : 8e0502                   stx abst+2
10c3 : 08                       php         ;flags after load/store sequence
10c4 : 49c3                     eor #$c3
10c6 : aa                       tax
10c7 : e041                     cpx #$41    ;test result
                                trap_ne     ;
10c9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
10cb : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
10cc : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
10ce : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
10d1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
10d3 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
10d5 : 48              >            pha         ;use stack to load status
10d6 : 28              >            plp
                        
10d7 : a60c                     ldx zp1+3
10d9 : 08                       php         ;test stores do not alter flags
10da : 8a                       txa
10db : 49c3                     eor #$c3
10dd : aa                       tax
10de : 28                       plp
10df : 8e0602                   stx abst+3
10e2 : 08                       php         ;flags after load/store sequence
10e3 : 49c3                     eor #$c3
10e5 : aa                       tax
10e6 : e000                     cpx #0      ;test result
                                trap_ne
10e8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
10ea : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
10eb : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
10ed : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
10f0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat 0
                       >            load_flag 0
10f2 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
10f4 : 48              >            pha         ;use stack to load status
10f5 : 28              >            plp
                        
10f6 : ae1702                   ldx abs1  
10f9 : 08                       php         ;test stores do not alter flags
10fa : 8a                       txa
10fb : 49c3                     eor #$c3
10fd : aa                       tax
10fe : 28                       plp
10ff : 8602                     stx zpt  
1101 : 08                       php         ;flags after load/store sequence
1102 : 49c3                     eor #$c3
1104 : c509                     cmp zp1     ;test result
                                trap_ne
1106 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1108 : 68                       pla         ;load status
                                eor_flag 0
1109 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
110b : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
110e : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1110 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1112 : 48              >            pha         ;use stack to load status
1113 : 28              >            plp
                        
1114 : ae1802                   ldx abs1+1
1117 : 08                       php         ;test stores do not alter flags
1118 : 8a                       txa
1119 : 49c3                     eor #$c3
111b : aa                       tax
111c : 28                       plp
111d : 8603                     stx zpt+1
111f : 08                       php         ;flags after load/store sequence
1120 : 49c3                     eor #$c3
1122 : c50a                     cmp zp1+1   ;test result
                                trap_ne
1124 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1126 : 68                       pla         ;load status
                                eor_flag 0
1127 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1129 : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
112c : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
112e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1130 : 48              >            pha         ;use stack to load status
1131 : 28              >            plp
                        
1132 : ae1902                   ldx abs1+2
1135 : 08                       php         ;test stores do not alter flags
1136 : 8a                       txa
1137 : 49c3                     eor #$c3
1139 : aa                       tax
113a : 28                       plp
113b : 8604                     stx zpt+2
113d : 08                       php         ;flags after load/store sequence
113e : 49c3                     eor #$c3
1140 : c50b                     cmp zp1+2   ;test result
                                trap_ne
1142 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1144 : 68                       pla         ;load status
                                eor_flag 0
1145 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1147 : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
114a : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
114c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
114e : 48              >            pha         ;use stack to load status
114f : 28              >            plp
                        
1150 : ae1a02                   ldx abs1+3
1153 : 08                       php         ;test stores do not alter flags
1154 : 8a                       txa
1155 : 49c3                     eor #$c3
1157 : aa                       tax
1158 : 28                       plp
1159 : 8605                     stx zpt+3
115b : 08                       php         ;flags after load/store sequence
115c : 49c3                     eor #$c3
115e : c50c                     cmp zp1+3   ;test result
                                trap_ne
1160 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1162 : 68                       pla         ;load status
                                eor_flag 0
1163 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1165 : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
1168 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
116a : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
116c : 48              >            pha         ;use stack to load status
116d : 28              >            plp
                        
116e : ae1702                   ldx abs1  
1171 : 08                       php         ;test stores do not alter flags
1172 : 8a                       txa
1173 : 49c3                     eor #$c3
1175 : aa                       tax
1176 : 28                       plp
1177 : 8602                     stx zpt  
1179 : 08                       php         ;flags after load/store sequence
117a : 49c3                     eor #$c3
117c : aa                       tax
117d : e409                     cpx zp1     ;test result
                                trap_ne
117f : d0fe            >        bne *           ;failed not equal (non zero)
                        
1181 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1182 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1184 : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
1187 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1189 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
118b : 48              >            pha         ;use stack to load status
118c : 28              >            plp
                        
118d : ae1802                   ldx abs1+1
1190 : 08                       php         ;test stores do not alter flags
1191 : 8a                       txa
1192 : 49c3                     eor #$c3
1194 : aa                       tax
1195 : 28                       plp
1196 : 8603                     stx zpt+1
1198 : 08                       php         ;flags after load/store sequence
1199 : 49c3                     eor #$c3
119b : aa                       tax
119c : e40a                     cpx zp1+1   ;test result
                                trap_ne
119e : d0fe            >        bne *           ;failed not equal (non zero)
                        
11a0 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
11a1 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
11a3 : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
11a6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
11a8 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
11aa : 48              >            pha         ;use stack to load status
11ab : 28              >            plp
                        
11ac : ae1902                   ldx abs1+2
11af : 08                       php         ;test stores do not alter flags
11b0 : 8a                       txa
11b1 : 49c3                     eor #$c3
11b3 : aa                       tax
11b4 : 28                       plp
11b5 : 8604                     stx zpt+2
11b7 : 08                       php         ;flags after load/store sequence
11b8 : 49c3                     eor #$c3
11ba : aa                       tax
11bb : e40b                     cpx zp1+2   ;test result
                                trap_ne
11bd : d0fe            >        bne *           ;failed not equal (non zero)
                        
11bf : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
11c0 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
11c2 : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
11c5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
11c7 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
11c9 : 48              >            pha         ;use stack to load status
11ca : 28              >            plp
                        
11cb : ae1a02                   ldx abs1+3
11ce : 08                       php         ;test stores do not alter flags
11cf : 8a                       txa
11d0 : 49c3                     eor #$c3
11d2 : aa                       tax
11d3 : 28                       plp
11d4 : 8605                     stx zpt+3
11d6 : 08                       php         ;flags after load/store sequence
11d7 : 49c3                     eor #$c3
11d9 : aa                       tax
11da : e40c                     cpx zp1+3   ;test result
                                trap_ne
11dc : d0fe            >        bne *           ;failed not equal (non zero)
                        
11de : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
11df : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
11e1 : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
11e4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat 0  
                       >            load_flag 0  
11e6 : a900            >            lda #0               ;allow test to change I-flag (no mask)
                       >
11e8 : 48              >            pha         ;use stack to load status
11e9 : 28              >            plp
                        
11ea : a2c3                     ldx #$c3
11ec : 08                       php
11ed : ec1702                   cpx abs1    ;test result
                                trap_ne
11f0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
11f2 : 68                       pla         ;load status
                                eor_flag 0
11f3 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
11f5 : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
11f8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
11fa : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
11fc : 48              >            pha         ;use stack to load status
11fd : 28              >            plp
                        
11fe : a282                     ldx #$82
1200 : 08                       php
1201 : ec1802                   cpx abs1+1  ;test result
                                trap_ne
1204 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1206 : 68                       pla         ;load status
                                eor_flag 0
1207 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1209 : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
120c : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
120e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1210 : 48              >            pha         ;use stack to load status
1211 : 28              >            plp
                        
1212 : a241                     ldx #$41
1214 : 08                       php
1215 : ec1902                   cpx abs1+2  ;test result
                                trap_ne
1218 : d0fe            >        bne *           ;failed not equal (non zero)
                        
121a : 68                       pla         ;load status
                                eor_flag 0
121b : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
121d : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
1220 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1222 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1224 : 48              >            pha         ;use stack to load status
1225 : 28              >            plp
                        
1226 : a200                     ldx #0
1228 : 08                       php
1229 : ec1a02                   cpx abs1+3  ;test result
                                trap_ne
122c : d0fe            >        bne *           ;failed not equal (non zero)
                        
122e : 68                       pla         ;load status
                                eor_flag 0
122f : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1231 : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
1234 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
1236 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1238 : 48              >            pha         ;use stack to load status
1239 : 28              >            plp
                        
123a : a2c3                     ldx #$c3  
123c : 08                       php
123d : ec1702                   cpx abs1    ;test result
                                trap_ne
1240 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1242 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1243 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1245 : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
1248 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
124a : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
124c : 48              >            pha         ;use stack to load status
124d : 28              >            plp
                        
124e : a282                     ldx #$82
1250 : 08                       php
1251 : ec1802                   cpx abs1+1  ;test result
                                trap_ne
1254 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1256 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1257 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1259 : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
125c : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
125e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1260 : 48              >            pha         ;use stack to load status
1261 : 28              >            plp
                        
1262 : a241                     ldx #$41
1264 : 08                       php
1265 : ec1902                   cpx abs1+2  ;test result
                                trap_ne
1268 : d0fe            >        bne *           ;failed not equal (non zero)
                        
126a : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
126b : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
126d : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
1270 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1272 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1274 : 48              >            pha         ;use stack to load status
1275 : 28              >            plp
                        
1276 : a200                     ldx #0
1278 : 08                       php
1279 : ec1a02                   cpx abs1+3  ;test result
                                trap_ne
127c : d0fe            >        bne *           ;failed not equal (non zero)
                        
127e : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
127f : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1281 : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
1284 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
1286 : a200                     ldx #0
1288 : a502                     lda zpt  
128a : 49c3                     eor #$c3
128c : c509                     cmp zp1  
                                trap_ne     ;store to zp data
128e : d0fe            >        bne *           ;failed not equal (non zero)
                        
1290 : 8602                     stx zpt     ;clear                
1292 : ad0302                   lda abst  
1295 : 49c3                     eor #$c3
1297 : cd1702                   cmp abs1  
                                trap_ne     ;store to abs data
129a : d0fe            >        bne *           ;failed not equal (non zero)
                        
129c : 8e0302                   stx abst    ;clear                
129f : a503                     lda zpt+1
12a1 : 49c3                     eor #$c3
12a3 : c50a                     cmp zp1+1
                                trap_ne     ;store to zp data
12a5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
12a7 : 8603                     stx zpt+1   ;clear                
12a9 : ad0402                   lda abst+1
12ac : 49c3                     eor #$c3
12ae : cd1802                   cmp abs1+1
                                trap_ne     ;store to abs data
12b1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
12b3 : 8e0402                   stx abst+1  ;clear                
12b6 : a504                     lda zpt+2
12b8 : 49c3                     eor #$c3
12ba : c50b                     cmp zp1+2
                                trap_ne     ;store to zp data
12bc : d0fe            >        bne *           ;failed not equal (non zero)
                        
12be : 8604                     stx zpt+2   ;clear                
12c0 : ad0502                   lda abst+2
12c3 : 49c3                     eor #$c3
12c5 : cd1902                   cmp abs1+2
                                trap_ne     ;store to abs data
12c8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
12ca : 8e0502                   stx abst+2  ;clear                
12cd : a505                     lda zpt+3
12cf : 49c3                     eor #$c3
12d1 : c50c                     cmp zp1+3
                                trap_ne     ;store to zp data
12d3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
12d5 : 8605                     stx zpt+3   ;clear                
12d7 : ad0602                   lda abst+3
12da : 49c3                     eor #$c3
12dc : cd1a02                   cmp abs1+3
                                trap_ne     ;store to abs data
12df : d0fe            >        bne *           ;failed not equal (non zero)
                        
12e1 : 8e0602                   stx abst+3  ;clear                
                                next_test
12e4 : ad0002          >            lda test_case   ;previous test
12e7 : c913            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
12e9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0014 =                 >test_num = test_num + 1
12eb : a914            >            lda #test_num   ;*** next tests' number
12ed : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; LDY / STY - zp / abs / #
                                set_stat 0
                       >            load_flag 0
12f0 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
12f2 : 48              >            pha         ;use stack to load status
12f3 : 28              >            plp
                        
12f4 : a409                     ldy zp1  
12f6 : 08                       php         ;test stores do not alter flags
12f7 : 98                       tya
12f8 : 49c3                     eor #$c3
12fa : a8                       tay
12fb : 28                       plp
12fc : 8c0302                   sty abst  
12ff : 08                       php         ;flags after load/store sequence
1300 : 49c3                     eor #$c3
1302 : a8                       tay
1303 : c0c3                     cpy #$c3    ;test result
                                trap_ne
1305 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1307 : 68                       pla         ;load status
                                eor_flag 0
1308 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
130a : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
130d : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
130f : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1311 : 48              >            pha         ;use stack to load status
1312 : 28              >            plp
                        
1313 : a40a                     ldy zp1+1
1315 : 08                       php         ;test stores do not alter flags
1316 : 98                       tya
1317 : 49c3                     eor #$c3
1319 : a8                       tay
131a : 28                       plp
131b : 8c0402                   sty abst+1
131e : 08                       php         ;flags after load/store sequence
131f : 49c3                     eor #$c3
1321 : a8                       tay
1322 : c082                     cpy #$82    ;test result
                                trap_ne
1324 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1326 : 68                       pla         ;load status
                                eor_flag 0
1327 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1329 : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
132c : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
132e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1330 : 48              >            pha         ;use stack to load status
1331 : 28              >            plp
                        
1332 : a40b                     ldy zp1+2
1334 : 08                       php         ;test stores do not alter flags
1335 : 98                       tya
1336 : 49c3                     eor #$c3
1338 : a8                       tay
1339 : 28                       plp
133a : 8c0502                   sty abst+2
133d : 08                       php         ;flags after load/store sequence
133e : 49c3                     eor #$c3
1340 : a8                       tay
1341 : c041                     cpy #$41    ;test result
                                trap_ne
1343 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1345 : 68                       pla         ;load status
                                eor_flag 0
1346 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1348 : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
134b : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
134d : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
134f : 48              >            pha         ;use stack to load status
1350 : 28              >            plp
                        
1351 : a40c                     ldy zp1+3
1353 : 08                       php         ;test stores do not alter flags
1354 : 98                       tya
1355 : 49c3                     eor #$c3
1357 : a8                       tay
1358 : 28                       plp
1359 : 8c0602                   sty abst+3
135c : 08                       php         ;flags after load/store sequence
135d : 49c3                     eor #$c3
135f : a8                       tay
1360 : c000                     cpy #0      ;test result
                                trap_ne
1362 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1364 : 68                       pla         ;load status
                                eor_flag 0
1365 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1367 : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
136a : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
136c : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
136e : 48              >            pha         ;use stack to load status
136f : 28              >            plp
                        
1370 : a409                     ldy zp1  
1372 : 08                       php         ;test stores do not alter flags
1373 : 98                       tya
1374 : 49c3                     eor #$c3
1376 : a8                       tay
1377 : 28                       plp
1378 : 8c0302                   sty abst  
137b : 08                       php         ;flags after load/store sequence
137c : 49c3                     eor #$c3
137e : a8                       tay
137f : c0c3                     cpy #$c3    ;test result
                                trap_ne
1381 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1383 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1384 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1386 : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
1389 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
138b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
138d : 48              >            pha         ;use stack to load status
138e : 28              >            plp
                        
138f : a40a                     ldy zp1+1
1391 : 08                       php         ;test stores do not alter flags
1392 : 98                       tya
1393 : 49c3                     eor #$c3
1395 : a8                       tay
1396 : 28                       plp
1397 : 8c0402                   sty abst+1
139a : 08                       php         ;flags after load/store sequence
139b : 49c3                     eor #$c3
139d : a8                       tay
139e : c082                     cpy #$82   ;test result
                                trap_ne
13a0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
13a2 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
13a3 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
13a5 : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
13a8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
13aa : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
13ac : 48              >            pha         ;use stack to load status
13ad : 28              >            plp
                        
13ae : a40b                     ldy zp1+2
13b0 : 08                       php         ;test stores do not alter flags
13b1 : 98                       tya
13b2 : 49c3                     eor #$c3
13b4 : a8                       tay
13b5 : 28                       plp
13b6 : 8c0502                   sty abst+2
13b9 : 08                       php         ;flags after load/store sequence
13ba : 49c3                     eor #$c3
13bc : a8                       tay
13bd : c041                     cpy #$41    ;test result
                                trap_ne
13bf : d0fe            >        bne *           ;failed not equal (non zero)
                        
13c1 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
13c2 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
13c4 : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
13c7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
13c9 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
13cb : 48              >            pha         ;use stack to load status
13cc : 28              >            plp
                        
13cd : a40c                     ldy zp1+3
13cf : 08                       php         ;test stores do not alter flags
13d0 : 98                       tya
13d1 : 49c3                     eor #$c3
13d3 : a8                       tay
13d4 : 28                       plp
13d5 : 8c0602                   sty abst+3
13d8 : 08                       php         ;flags after load/store sequence
13d9 : 49c3                     eor #$c3
13db : a8                       tay
13dc : c000                     cpy #0      ;test result
                                trap_ne
13de : d0fe            >        bne *           ;failed not equal (non zero)
                        
13e0 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
13e1 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
13e3 : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
13e6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                
                                set_stat 0
                       >            load_flag 0
13e8 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
13ea : 48              >            pha         ;use stack to load status
13eb : 28              >            plp
                        
13ec : ac1702                   ldy abs1  
13ef : 08                       php         ;test stores do not alter flags
13f0 : 98                       tya
13f1 : 49c3                     eor #$c3
13f3 : a8                       tay
13f4 : 28                       plp
13f5 : 8402                     sty zpt  
13f7 : 08                       php         ;flags after load/store sequence
13f8 : 49c3                     eor #$c3
13fa : a8                       tay
13fb : c409                     cpy zp1     ;test result
                                trap_ne
13fd : d0fe            >        bne *           ;failed not equal (non zero)
                        
13ff : 68                       pla         ;load status
                                eor_flag 0
1400 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1402 : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
1405 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1407 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1409 : 48              >            pha         ;use stack to load status
140a : 28              >            plp
                        
140b : ac1802                   ldy abs1+1
140e : 08                       php         ;test stores do not alter flags
140f : 98                       tya
1410 : 49c3                     eor #$c3
1412 : a8                       tay
1413 : 28                       plp
1414 : 8403                     sty zpt+1
1416 : 08                       php         ;flags after load/store sequence
1417 : 49c3                     eor #$c3
1419 : a8                       tay
141a : c40a                     cpy zp1+1   ;test result
                                trap_ne
141c : d0fe            >        bne *           ;failed not equal (non zero)
                        
141e : 68                       pla         ;load status
                                eor_flag 0
141f : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1421 : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
1424 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1426 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1428 : 48              >            pha         ;use stack to load status
1429 : 28              >            plp
                        
142a : ac1902                   ldy abs1+2
142d : 08                       php         ;test stores do not alter flags
142e : 98                       tya
142f : 49c3                     eor #$c3
1431 : a8                       tay
1432 : 28                       plp
1433 : 8404                     sty zpt+2
1435 : 08                       php         ;flags after load/store sequence
1436 : 49c3                     eor #$c3
1438 : a8                       tay
1439 : c40b                     cpy zp1+2   ;test result
                                trap_ne
143b : d0fe            >        bne *           ;failed not equal (non zero)
                        
143d : 68                       pla         ;load status
                                eor_flag 0
143e : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1440 : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
1443 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1445 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1447 : 48              >            pha         ;use stack to load status
1448 : 28              >            plp
                        
1449 : ac1a02                   ldy abs1+3
144c : 08                       php         ;test stores do not alter flags
144d : 98                       tya
144e : 49c3                     eor #$c3
1450 : a8                       tay
1451 : 28                       plp
1452 : 8405                     sty zpt+3
1454 : 08                       php         ;flags after load/store sequence
1455 : 49c3                     eor #$c3
1457 : a8                       tay
1458 : c40c                     cpy zp1+3   ;test result
                                trap_ne
145a : d0fe            >        bne *           ;failed not equal (non zero)
                        
145c : 68                       pla         ;load status
                                eor_flag 0
145d : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
145f : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
1462 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
1464 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1466 : 48              >            pha         ;use stack to load status
1467 : 28              >            plp
                        
1468 : ac1702                   ldy abs1  
146b : 08                       php         ;test stores do not alter flags
146c : 98                       tya
146d : 49c3                     eor #$c3
146f : a8                       tay
1470 : 28                       plp
1471 : 8402                     sty zpt  
1473 : 08                       php         ;flags after load/store sequence
1474 : 49c3                     eor #$c3
1476 : a8                       tay
1477 : c509                     cmp zp1     ;test result
                                trap_ne
1479 : d0fe            >        bne *           ;failed not equal (non zero)
                        
147b : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
147c : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
147e : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
1481 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1483 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1485 : 48              >            pha         ;use stack to load status
1486 : 28              >            plp
                        
1487 : ac1802                   ldy abs1+1
148a : 08                       php         ;test stores do not alter flags
148b : 98                       tya
148c : 49c3                     eor #$c3
148e : a8                       tay
148f : 28                       plp
1490 : 8403                     sty zpt+1
1492 : 08                       php         ;flags after load/store sequence
1493 : 49c3                     eor #$c3
1495 : a8                       tay
1496 : c50a                     cmp zp1+1   ;test result
                                trap_ne
1498 : d0fe            >        bne *           ;failed not equal (non zero)
                        
149a : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
149b : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
149d : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
14a0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
14a2 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
14a4 : 48              >            pha         ;use stack to load status
14a5 : 28              >            plp
                        
14a6 : ac1902                   ldy abs1+2
14a9 : 08                       php         ;test stores do not alter flags
14aa : 98                       tya
14ab : 49c3                     eor #$c3
14ad : a8                       tay
14ae : 28                       plp
14af : 8404                     sty zpt+2
14b1 : 08                       php         ;flags after load/store sequence
14b2 : 49c3                     eor #$c3
14b4 : a8                       tay
14b5 : c50b                     cmp zp1+2   ;test result
                                trap_ne
14b7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
14b9 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
14ba : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
14bc : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
14bf : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
14c1 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
14c3 : 48              >            pha         ;use stack to load status
14c4 : 28              >            plp
                        
14c5 : ac1a02                   ldy abs1+3
14c8 : 08                       php         ;test stores do not alter flags
14c9 : 98                       tya
14ca : 49c3                     eor #$c3
14cc : a8                       tay
14cd : 28                       plp
14ce : 8405                     sty zpt+3
14d0 : 08                       php         ;flags after load/store sequence
14d1 : 49c3                     eor #$c3
14d3 : a8                       tay
14d4 : c50c                     cmp zp1+3   ;test result
                                trap_ne
14d6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
14d8 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
14d9 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
14db : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
14de : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                        
                                set_stat 0
                       >            load_flag 0
14e0 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
14e2 : 48              >            pha         ;use stack to load status
14e3 : 28              >            plp
                        
14e4 : a0c3                     ldy #$c3  
14e6 : 08                       php
14e7 : cc1702                   cpy abs1    ;test result
                                trap_ne
14ea : d0fe            >        bne *           ;failed not equal (non zero)
                        
14ec : 68                       pla         ;load status
                                eor_flag 0
14ed : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
14ef : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
14f2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
14f4 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
14f6 : 48              >            pha         ;use stack to load status
14f7 : 28              >            plp
                        
14f8 : a082                     ldy #$82
14fa : 08                       php
14fb : cc1802                   cpy abs1+1  ;test result
                                trap_ne
14fe : d0fe            >        bne *           ;failed not equal (non zero)
                        
1500 : 68                       pla         ;load status
                                eor_flag 0
1501 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1503 : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
1506 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1508 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
150a : 48              >            pha         ;use stack to load status
150b : 28              >            plp
                        
150c : a041                     ldy #$41
150e : 08                       php
150f : cc1902                   cpy abs1+2  ;test result
                                trap_ne
1512 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1514 : 68                       pla         ;load status
                                eor_flag 0
1515 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1517 : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
151a : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
151c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
151e : 48              >            pha         ;use stack to load status
151f : 28              >            plp
                        
1520 : a000                     ldy #0
1522 : 08                       php
1523 : cc1a02                   cpy abs1+3  ;test result
                                trap_ne
1526 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1528 : 68                       pla         ;load status
                                eor_flag 0
1529 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
152b : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
152e : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
1530 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1532 : 48              >            pha         ;use stack to load status
1533 : 28              >            plp
                        
1534 : a0c3                     ldy #$c3  
1536 : 08                       php
1537 : cc1702                   cpy abs1    ;test result
                                trap_ne
153a : d0fe            >        bne *           ;failed not equal (non zero)
                        
153c : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
153d : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
153f : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
1542 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1544 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1546 : 48              >            pha         ;use stack to load status
1547 : 28              >            plp
                        
1548 : a082                     ldy #$82
154a : 08                       php
154b : cc1802                   cpy abs1+1  ;test result
                                trap_ne
154e : d0fe            >        bne *           ;failed not equal (non zero)
                        
1550 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1551 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1553 : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
1556 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1558 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
155a : 48              >            pha         ;use stack to load status
155b : 28              >            plp
                        
155c : a041                     ldy #$41
155e : 08                       php
155f : cc1902                   cpy abs1+2   ;test result
                                trap_ne
1562 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1564 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1565 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1567 : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
156a : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
156c : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
156e : 48              >            pha         ;use stack to load status
156f : 28              >            plp
                        
1570 : a000                     ldy #0
1572 : 08                       php
1573 : cc1a02                   cpy abs1+3  ;test result
                                trap_ne
1576 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1578 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1579 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
157b : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
157e : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                
1580 : a000                     ldy #0
1582 : a502                     lda zpt  
1584 : 49c3                     eor #$c3
1586 : c509                     cmp zp1  
                                trap_ne     ;store to zp   data
1588 : d0fe            >        bne *           ;failed not equal (non zero)
                        
158a : 8402                     sty zpt     ;clear                
158c : ad0302                   lda abst  
158f : 49c3                     eor #$c3
1591 : cd1702                   cmp abs1  
                                trap_ne     ;store to abs   data
1594 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1596 : 8c0302                   sty abst    ;clear                
1599 : a503                     lda zpt+1
159b : 49c3                     eor #$c3
159d : c50a                     cmp zp1+1
                                trap_ne     ;store to zp+1 data
159f : d0fe            >        bne *           ;failed not equal (non zero)
                        
15a1 : 8403                     sty zpt+1   ;clear                
15a3 : ad0402                   lda abst+1
15a6 : 49c3                     eor #$c3
15a8 : cd1802                   cmp abs1+1
                                trap_ne     ;store to abs+1 data
15ab : d0fe            >        bne *           ;failed not equal (non zero)
                        
15ad : 8c0402                   sty abst+1  ;clear                
15b0 : a504                     lda zpt+2
15b2 : 49c3                     eor #$c3
15b4 : c50b                     cmp zp1+2
                                trap_ne     ;store to zp+2 data
15b6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
15b8 : 8404                     sty zpt+2   ;clear                
15ba : ad0502                   lda abst+2
15bd : 49c3                     eor #$c3
15bf : cd1902                   cmp abs1+2
                                trap_ne     ;store to abs+2 data
15c2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
15c4 : 8c0502                   sty abst+2  ;clear                
15c7 : a505                     lda zpt+3
15c9 : 49c3                     eor #$c3
15cb : c50c                     cmp zp1+3
                                trap_ne     ;store to zp+3 data
15cd : d0fe            >        bne *           ;failed not equal (non zero)
                        
15cf : 8405                     sty zpt+3   ;clear                
15d1 : ad0602                   lda abst+3
15d4 : 49c3                     eor #$c3
15d6 : cd1a02                   cmp abs1+3
                                trap_ne     ;store to abs+3 data
15d9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
15db : 8c0602                   sty abst+3  ;clear                
                                next_test
15de : ad0002          >            lda test_case   ;previous test
15e1 : c914            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
15e3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0015 =                 >test_num = test_num + 1
15e5 : a915            >            lda #test_num   ;*** next tests' number
15e7 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing load / store accumulator LDA / STA all addressing modes
                        ; LDA / STA - zp,x / abs,x
15ea : a203                     ldx #3
15ec :                  tldax    
                                set_stat 0
                       >            load_flag 0
15ec : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
15ee : 48              >            pha         ;use stack to load status
15ef : 28              >            plp
                        
15f0 : b509                     lda zp1,x
15f2 : 08                       php         ;test stores do not alter flags
15f3 : 49c3                     eor #$c3
15f5 : 28                       plp
15f6 : 9d0302                   sta abst,x
15f9 : 08                       php         ;flags after load/store sequence
15fa : 49c3                     eor #$c3
15fc : dd1702                   cmp abs1,x  ;test result
                                trap_ne
15ff : d0fe            >        bne *           ;failed not equal (non zero)
                        
1601 : 68                       pla         ;load status
                                eor_flag 0
1602 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1604 : dd1c02                   cmp fLDx,x  ;test flags
                                trap_ne
1607 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1609 : ca                       dex
160a : 10e0                     bpl tldax                  
                        
160c : a203                     ldx #3
160e :                  tldax1   
                                set_stat $ff
                       >            load_flag $ff
160e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1610 : 48              >            pha         ;use stack to load status
1611 : 28              >            plp
                        
1612 : b509                     lda zp1,x
1614 : 08                       php         ;test stores do not alter flags
1615 : 49c3                     eor #$c3
1617 : 28                       plp
1618 : 9d0302                   sta abst,x
161b : 08                       php         ;flags after load/store sequence
161c : 49c3                     eor #$c3
161e : dd1702                   cmp abs1,x   ;test result
                                trap_ne
1621 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1623 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1624 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1626 : dd1c02                   cmp fLDx,x  ;test flags
                                trap_ne
1629 : d0fe            >        bne *           ;failed not equal (non zero)
                        
162b : ca                       dex
162c : 10e0                     bpl tldax1                  
                        
162e : a203                     ldx #3
1630 :                  tldax2   
                                set_stat 0
                       >            load_flag 0
1630 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1632 : 48              >            pha         ;use stack to load status
1633 : 28              >            plp
                        
1634 : bd1702                   lda abs1,x
1637 : 08                       php         ;test stores do not alter flags
1638 : 49c3                     eor #$c3
163a : 28                       plp
163b : 9502                     sta zpt,x
163d : 08                       php         ;flags after load/store sequence
163e : 49c3                     eor #$c3
1640 : d509                     cmp zp1,x   ;test result
                                trap_ne
1642 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1644 : 68                       pla         ;load status
                                eor_flag 0
1645 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1647 : dd1c02                   cmp fLDx,x  ;test flags
                                trap_ne
164a : d0fe            >        bne *           ;failed not equal (non zero)
                        
164c : ca                       dex
164d : 10e1                     bpl tldax2                  
                        
164f : a203                     ldx #3
1651 :                  tldax3
                                set_stat $ff
                       >            load_flag $ff
1651 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1653 : 48              >            pha         ;use stack to load status
1654 : 28              >            plp
                        
1655 : bd1702                   lda abs1,x
1658 : 08                       php         ;test stores do not alter flags
1659 : 49c3                     eor #$c3
165b : 28                       plp
165c : 9502                     sta zpt,x
165e : 08                       php         ;flags after load/store sequence
165f : 49c3                     eor #$c3
1661 : d509                     cmp zp1,x   ;test result
                                trap_ne
1663 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1665 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1666 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1668 : dd1c02                   cmp fLDx,x  ;test flags
                                trap_ne
166b : d0fe            >        bne *           ;failed not equal (non zero)
                        
166d : ca                       dex
166e : 10e1                     bpl tldax3
                        
1670 : a203                     ldx #3      ;testing store result
1672 : a000                     ldy #0
1674 : b502             tstax   lda zpt,x
1676 : 49c3                     eor #$c3
1678 : d509                     cmp zp1,x
                                trap_ne     ;store to zp,x data
167a : d0fe            >        bne *           ;failed not equal (non zero)
                        
167c : 9402                     sty zpt,x   ;clear                
167e : bd0302                   lda abst,x
1681 : 49c3                     eor #$c3
1683 : dd1702                   cmp abs1,x
                                trap_ne     ;store to abs,x data
1686 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1688 : 8a                       txa
1689 : 9d0302                   sta abst,x  ;clear                
168c : ca                       dex
168d : 10e5                     bpl tstax
                                next_test
168f : ad0002          >            lda test_case   ;previous test
1692 : c915            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
1694 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0016 =                 >test_num = test_num + 1
1696 : a916            >            lda #test_num   ;*** next tests' number
1698 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; LDA / STA - (zp),y / abs,y / (zp,x)
169b : a003                     ldy #3
169d :                  tlday    
                                set_stat 0
                       >            load_flag 0
169d : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
169f : 48              >            pha         ;use stack to load status
16a0 : 28              >            plp
                        
16a1 : b11a                     lda (ind1),y
16a3 : 08                       php         ;test stores do not alter flags
16a4 : 49c3                     eor #$c3
16a6 : 28                       plp
16a7 : 990302                   sta abst,y
16aa : 08                       php         ;flags after load/store sequence
16ab : 49c3                     eor #$c3
16ad : d91702                   cmp abs1,y  ;test result
                                trap_ne
16b0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
16b2 : 68                       pla         ;load status
                                eor_flag 0
16b3 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
16b5 : d91c02                   cmp fLDx,y  ;test flags
                                trap_ne
16b8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
16ba : 88                       dey
16bb : 10e0                     bpl tlday                  
                        
16bd : a003                     ldy #3
16bf :                  tlday1   
                                set_stat $ff
                       >            load_flag $ff
16bf : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
16c1 : 48              >            pha         ;use stack to load status
16c2 : 28              >            plp
                        
16c3 : b11a                     lda (ind1),y
16c5 : 08                       php         ;test stores do not alter flags
16c6 : 49c3                     eor #$c3
16c8 : 28                       plp
16c9 : 990302                   sta abst,y
16cc : 08                       php         ;flags after load/store sequence
16cd : 49c3                     eor #$c3
16cf : d91702                   cmp abs1,y  ;test result
                                trap_ne
16d2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
16d4 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
16d5 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
16d7 : d91c02                   cmp fLDx,y  ;test flags
                                trap_ne
16da : d0fe            >        bne *           ;failed not equal (non zero)
                        
16dc : 88                       dey
16dd : 10e0                     bpl tlday1                  
                        
16df : a003                     ldy #3      ;testing store result
16e1 : a200                     ldx #0
16e3 : b90302           tstay   lda abst,y
16e6 : 49c3                     eor #$c3
16e8 : d91702                   cmp abs1,y
                                trap_ne     ;store to abs data
16eb : d0fe            >        bne *           ;failed not equal (non zero)
                        
16ed : 8a                       txa
16ee : 990302                   sta abst,y  ;clear                
16f1 : 88                       dey
16f2 : 10ef                     bpl tstay
                        
16f4 : a003                     ldy #3
16f6 :                  tlday2   
                                set_stat 0
                       >            load_flag 0
16f6 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
16f8 : 48              >            pha         ;use stack to load status
16f9 : 28              >            plp
                        
16fa : b91702                   lda abs1,y
16fd : 08                       php         ;test stores do not alter flags
16fe : 49c3                     eor #$c3
1700 : 28                       plp
1701 : 9126                     sta (indt),y
1703 : 08                       php         ;flags after load/store sequence
1704 : 49c3                     eor #$c3
1706 : d11a                     cmp (ind1),y    ;test result
                                trap_ne
1708 : d0fe            >        bne *           ;failed not equal (non zero)
                        
170a : 68                       pla         ;load status
                                eor_flag 0
170b : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
170d : d91c02                   cmp fLDx,y  ;test flags
                                trap_ne
1710 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1712 : 88                       dey
1713 : 10e1                     bpl tlday2                  
                        
1715 : a003                     ldy #3
1717 :                  tlday3   
                                set_stat $ff
                       >            load_flag $ff
1717 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1719 : 48              >            pha         ;use stack to load status
171a : 28              >            plp
                        
171b : b91702                   lda abs1,y
171e : 08                       php         ;test stores do not alter flags
171f : 49c3                     eor #$c3
1721 : 28                       plp
1722 : 9126                     sta (indt),y
1724 : 08                       php         ;flags after load/store sequence
1725 : 49c3                     eor #$c3
1727 : d11a                     cmp (ind1),y   ;test result
                                trap_ne
1729 : d0fe            >        bne *           ;failed not equal (non zero)
                        
172b : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
172c : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
172e : d91c02                   cmp fLDx,y  ;test flags
                                trap_ne
1731 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1733 : 88                       dey
1734 : 10e1                     bpl tlday3
                                
1736 : a003                     ldy #3      ;testing store result
1738 : a200                     ldx #0
173a : b90302           tstay1  lda abst,y
173d : 49c3                     eor #$c3
173f : d91702                   cmp abs1,y
                                trap_ne     ;store to abs data
1742 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1744 : 8a                       txa
1745 : 990302                   sta abst,y  ;clear                
1748 : 88                       dey
1749 : 10ef                     bpl tstay1
                                
174b : a206                     ldx #6
174d : a003                     ldy #3
174f :                  tldax4   
                                set_stat 0
                       >            load_flag 0
174f : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1751 : 48              >            pha         ;use stack to load status
1752 : 28              >            plp
                        
1753 : a11a                     lda (ind1,x)
1755 : 08                       php         ;test stores do not alter flags
1756 : 49c3                     eor #$c3
1758 : 28                       plp
1759 : 8126                     sta (indt,x)
175b : 08                       php         ;flags after load/store sequence
175c : 49c3                     eor #$c3
175e : d91702                   cmp abs1,y  ;test result
                                trap_ne
1761 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1763 : 68                       pla         ;load status
                                eor_flag 0
1764 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1766 : d91c02                   cmp fLDx,y  ;test flags
                                trap_ne
1769 : d0fe            >        bne *           ;failed not equal (non zero)
                        
176b : ca                       dex
176c : ca                       dex
176d : 88                       dey
176e : 10df                     bpl tldax4                  
                        
1770 : a206                     ldx #6
1772 : a003                     ldy #3
1774 :                  tldax5
                                set_stat $ff
                       >            load_flag $ff
1774 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1776 : 48              >            pha         ;use stack to load status
1777 : 28              >            plp
                        
1778 : a11a                     lda (ind1,x)
177a : 08                       php         ;test stores do not alter flags
177b : 49c3                     eor #$c3
177d : 28                       plp
177e : 8126                     sta (indt,x)
1780 : 08                       php         ;flags after load/store sequence
1781 : 49c3                     eor #$c3
1783 : d91702                   cmp abs1,y  ;test result
                                trap_ne
1786 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1788 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1789 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
178b : d91c02                   cmp fLDx,y  ;test flags
                                trap_ne
178e : d0fe            >        bne *           ;failed not equal (non zero)
                        
1790 : ca                       dex
1791 : ca                       dex
1792 : 88                       dey
1793 : 10df                     bpl tldax5
                        
1795 : a003                     ldy #3      ;testing store result
1797 : a200                     ldx #0
1799 : b90302           tstay2  lda abst,y
179c : 49c3                     eor #$c3
179e : d91702                   cmp abs1,y
                                trap_ne     ;store to abs data
17a1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
17a3 : 8a                       txa
17a4 : 990302                   sta abst,y  ;clear                
17a7 : 88                       dey
17a8 : 10ef                     bpl tstay2
                                next_test
17aa : ad0002          >            lda test_case   ;previous test
17ad : c916            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
17af : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0017 =                 >test_num = test_num + 1
17b1 : a917            >            lda #test_num   ;*** next tests' number
17b3 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; indexed wraparound test (only zp should wrap)
17b6 : a2fd                     ldx #3+$fa
17b8 : b50f             tldax6  lda zp1-$fa&$ff,x   ;wrap on indexed zp
17ba : 9d0901                   sta abst-$fa,x      ;no STX abs,x!
17bd : ca                       dex
17be : e0fa                     cpx #$fa
17c0 : b0f6                     bcs tldax6                  
17c2 : a2fd                     ldx #3+$fa
17c4 : bd1d01           tldax7  lda abs1-$fa,x      ;no wrap on indexed abs
17c7 : 9508                     sta zpt-$fa&$ff,x
17c9 : ca                       dex
17ca : e0fa                     cpx #$fa
17cc : b0f6                     bcs tldax7
                                                  
17ce : a203                     ldx #3      ;testing wraparound result
17d0 : a000                     ldy #0
17d2 : b502             tstax1  lda zpt,x
17d4 : d509                     cmp zp1,x
                                trap_ne     ;store to zp,x data
17d6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
17d8 : 9402                     sty zpt,x   ;clear                
17da : bd0302                   lda abst,x
17dd : dd1702                   cmp abs1,x
                                trap_ne     ;store to abs,x data
17e0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
17e2 : 8a                       txa
17e3 : 9d0302                   sta abst,x  ;clear                
17e6 : ca                       dex
17e7 : 10e9                     bpl tstax1
                        
17e9 : a0fb                     ldy #3+$f8
17eb : a2fe                     ldx #6+$f8
17ed : a122             tlday4  lda (ind1-$f8&$ff,x) ;wrap on indexed zp indirect
17ef : 990b01                   sta abst-$f8,y
17f2 : ca                       dex
17f3 : ca                       dex
17f4 : 88                       dey
17f5 : c0f8                     cpy #$f8
17f7 : b0f4                     bcs tlday4
17f9 : a003                     ldy #3      ;testing wraparound result
17fb : a200                     ldx #0
17fd : b90302           tstay4  lda abst,y
1800 : d91702                   cmp abs1,y
                                trap_ne     ;store to abs data
1803 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1805 : 8a                       txa
1806 : 990302                   sta abst,y  ;clear                
1809 : 88                       dey
180a : 10f1                     bpl tstay4
                                
180c : a0fb                     ldy #3+$f8
180e : b91f01           tlday5  lda abs1-$f8,y  ;no wrap on indexed abs
1811 : 912e                     sta (inwt),y
1813 : 88                       dey
1814 : c0f8                     cpy #$f8
1816 : b0f6                     bcs tlday5                  
1818 : a003                     ldy #3      ;testing wraparound result
181a : a200                     ldx #0
181c : b90302           tstay5  lda abst,y
181f : d91702                   cmp abs1,y
                                trap_ne     ;store to abs data
1822 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1824 : 8a                       txa
1825 : 990302                   sta abst,y  ;clear                
1828 : 88                       dey
1829 : 10f1                     bpl tstay5
                        
182b : a0fb                     ldy #3+$f8
182d : a2fe                     ldx #6+$f8
182f : b124             tlday6  lda (inw1),y    ;no wrap on zp indirect indexed 
1831 : 812e                     sta (indt-$f8&$ff,x)
1833 : ca                       dex
1834 : ca                       dex
1835 : 88                       dey
1836 : c0f8                     cpy #$f8
1838 : b0f5                     bcs tlday6
183a : a003                     ldy #3      ;testing wraparound result
183c : a200                     ldx #0
183e : b90302           tstay6  lda abst,y
1841 : d91702                   cmp abs1,y
                                trap_ne     ;store to abs data
1844 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1846 : 8a                       txa
1847 : 990302                   sta abst,y  ;clear                
184a : 88                       dey
184b : 10f1                     bpl tstay6
                                next_test
184d : ad0002          >            lda test_case   ;previous test
1850 : c917            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
1852 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0018 =                 >test_num = test_num + 1
1854 : a918            >            lda #test_num   ;*** next tests' number
1856 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; LDA / STA - zp / abs / #
                                set_stat 0  
                       >            load_flag 0  
1859 : a900            >            lda #0               ;allow test to change I-flag (no mask)
                       >
185b : 48              >            pha         ;use stack to load status
185c : 28              >            plp
                        
185d : a509                     lda zp1
185f : 08                       php         ;test stores do not alter flags
1860 : 49c3                     eor #$c3
1862 : 28                       plp
1863 : 8d0302                   sta abst
1866 : 08                       php         ;flags after load/store sequence
1867 : 49c3                     eor #$c3
1869 : c9c3                     cmp #$c3    ;test result
                                trap_ne
186b : d0fe            >        bne *           ;failed not equal (non zero)
                        
186d : 68                       pla         ;load status
                                eor_flag 0
186e : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1870 : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
1873 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1875 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1877 : 48              >            pha         ;use stack to load status
1878 : 28              >            plp
                        
1879 : a50a                     lda zp1+1
187b : 08                       php         ;test stores do not alter flags
187c : 49c3                     eor #$c3
187e : 28                       plp
187f : 8d0402                   sta abst+1
1882 : 08                       php         ;flags after load/store sequence
1883 : 49c3                     eor #$c3
1885 : c982                     cmp #$82    ;test result
                                trap_ne
1887 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1889 : 68                       pla         ;load status
                                eor_flag 0
188a : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
188c : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
188f : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1891 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1893 : 48              >            pha         ;use stack to load status
1894 : 28              >            plp
                        
1895 : a50b                     lda zp1+2
1897 : 08                       php         ;test stores do not alter flags
1898 : 49c3                     eor #$c3
189a : 28                       plp
189b : 8d0502                   sta abst+2
189e : 08                       php         ;flags after load/store sequence
189f : 49c3                     eor #$c3
18a1 : c941                     cmp #$41    ;test result
                                trap_ne
18a3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
18a5 : 68                       pla         ;load status
                                eor_flag 0
18a6 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
18a8 : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
18ab : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
18ad : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
18af : 48              >            pha         ;use stack to load status
18b0 : 28              >            plp
                        
18b1 : a50c                     lda zp1+3
18b3 : 08                       php         ;test stores do not alter flags
18b4 : 49c3                     eor #$c3
18b6 : 28                       plp
18b7 : 8d0602                   sta abst+3
18ba : 08                       php         ;flags after load/store sequence
18bb : 49c3                     eor #$c3
18bd : c900                     cmp #0      ;test result
                                trap_ne
18bf : d0fe            >        bne *           ;failed not equal (non zero)
                        
18c1 : 68                       pla         ;load status
                                eor_flag 0
18c2 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
18c4 : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
18c7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
18c9 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
18cb : 48              >            pha         ;use stack to load status
18cc : 28              >            plp
                        
18cd : a509                     lda zp1  
18cf : 08                       php         ;test stores do not alter flags
18d0 : 49c3                     eor #$c3
18d2 : 28                       plp
18d3 : 8d0302                   sta abst  
18d6 : 08                       php         ;flags after load/store sequence
18d7 : 49c3                     eor #$c3
18d9 : c9c3                     cmp #$c3    ;test result
                                trap_ne
18db : d0fe            >        bne *           ;failed not equal (non zero)
                        
18dd : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
18de : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
18e0 : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
18e3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
18e5 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
18e7 : 48              >            pha         ;use stack to load status
18e8 : 28              >            plp
                        
18e9 : a50a                     lda zp1+1
18eb : 08                       php         ;test stores do not alter flags
18ec : 49c3                     eor #$c3
18ee : 28                       plp
18ef : 8d0402                   sta abst+1
18f2 : 08                       php         ;flags after load/store sequence
18f3 : 49c3                     eor #$c3
18f5 : c982                     cmp #$82    ;test result
                                trap_ne
18f7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
18f9 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
18fa : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
18fc : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
18ff : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1901 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1903 : 48              >            pha         ;use stack to load status
1904 : 28              >            plp
                        
1905 : a50b                     lda zp1+2
1907 : 08                       php         ;test stores do not alter flags
1908 : 49c3                     eor #$c3
190a : 28                       plp
190b : 8d0502                   sta abst+2
190e : 08                       php         ;flags after load/store sequence
190f : 49c3                     eor #$c3
1911 : c941                     cmp #$41    ;test result
                                trap_ne
1913 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1915 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1916 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1918 : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
191b : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
191d : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
191f : 48              >            pha         ;use stack to load status
1920 : 28              >            plp
                        
1921 : a50c                     lda zp1+3
1923 : 08                       php         ;test stores do not alter flags
1924 : 49c3                     eor #$c3
1926 : 28                       plp
1927 : 8d0602                   sta abst+3
192a : 08                       php         ;flags after load/store sequence
192b : 49c3                     eor #$c3
192d : c900                     cmp #0      ;test result
                                trap_ne
192f : d0fe            >        bne *           ;failed not equal (non zero)
                        
1931 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1932 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1934 : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
1937 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1939 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
193b : 48              >            pha         ;use stack to load status
193c : 28              >            plp
                        
193d : ad1702                   lda abs1  
1940 : 08                       php         ;test stores do not alter flags
1941 : 49c3                     eor #$c3
1943 : 28                       plp
1944 : 8502                     sta zpt  
1946 : 08                       php         ;flags after load/store sequence
1947 : 49c3                     eor #$c3
1949 : c509                     cmp zp1     ;test result
                                trap_ne
194b : d0fe            >        bne *           ;failed not equal (non zero)
                        
194d : 68                       pla         ;load status
                                eor_flag 0
194e : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1950 : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
1953 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1955 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1957 : 48              >            pha         ;use stack to load status
1958 : 28              >            plp
                        
1959 : ad1802                   lda abs1+1
195c : 08                       php         ;test stores do not alter flags
195d : 49c3                     eor #$c3
195f : 28                       plp
1960 : 8503                     sta zpt+1
1962 : 08                       php         ;flags after load/store sequence
1963 : 49c3                     eor #$c3
1965 : c50a                     cmp zp1+1   ;test result
                                trap_ne
1967 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1969 : 68                       pla         ;load status
                                eor_flag 0
196a : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
196c : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
196f : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1971 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1973 : 48              >            pha         ;use stack to load status
1974 : 28              >            plp
                        
1975 : ad1902                   lda abs1+2
1978 : 08                       php         ;test stores do not alter flags
1979 : 49c3                     eor #$c3
197b : 28                       plp
197c : 8504                     sta zpt+2
197e : 08                       php         ;flags after load/store sequence
197f : 49c3                     eor #$c3
1981 : c50b                     cmp zp1+2   ;test result
                                trap_ne
1983 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1985 : 68                       pla         ;load status
                                eor_flag 0
1986 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1988 : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
198b : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
198d : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
198f : 48              >            pha         ;use stack to load status
1990 : 28              >            plp
                        
1991 : ad1a02                   lda abs1+3
1994 : 08                       php         ;test stores do not alter flags
1995 : 49c3                     eor #$c3
1997 : 28                       plp
1998 : 8505                     sta zpt+3
199a : 08                       php         ;flags after load/store sequence
199b : 49c3                     eor #$c3
199d : c50c                     cmp zp1+3   ;test result
                                trap_ne
199f : d0fe            >        bne *           ;failed not equal (non zero)
                        
19a1 : 68                       pla         ;load status
                                eor_flag 0
19a2 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
19a4 : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
19a7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
19a9 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
19ab : 48              >            pha         ;use stack to load status
19ac : 28              >            plp
                        
19ad : ad1702                   lda abs1  
19b0 : 08                       php         ;test stores do not alter flags
19b1 : 49c3                     eor #$c3
19b3 : 28                       plp
19b4 : 8502                     sta zpt  
19b6 : 08                       php         ;flags after load/store sequence
19b7 : 49c3                     eor #$c3
19b9 : c509                     cmp zp1     ;test result
                                trap_ne
19bb : d0fe            >        bne *           ;failed not equal (non zero)
                        
19bd : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
19be : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
19c0 : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
19c3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
19c5 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
19c7 : 48              >            pha         ;use stack to load status
19c8 : 28              >            plp
                        
19c9 : ad1802                   lda abs1+1
19cc : 08                       php         ;test stores do not alter flags
19cd : 49c3                     eor #$c3
19cf : 28                       plp
19d0 : 8503                     sta zpt+1
19d2 : 08                       php         ;flags after load/store sequence
19d3 : 49c3                     eor #$c3
19d5 : c50a                     cmp zp1+1   ;test result
                                trap_ne
19d7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
19d9 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
19da : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
19dc : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
19df : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
19e1 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
19e3 : 48              >            pha         ;use stack to load status
19e4 : 28              >            plp
                        
19e5 : ad1902                   lda abs1+2
19e8 : 08                       php         ;test stores do not alter flags
19e9 : 49c3                     eor #$c3
19eb : 28                       plp
19ec : 8504                     sta zpt+2
19ee : 08                       php         ;flags after load/store sequence
19ef : 49c3                     eor #$c3
19f1 : c50b                     cmp zp1+2   ;test result
                                trap_ne
19f3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
19f5 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
19f6 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
19f8 : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
19fb : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
19fd : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
19ff : 48              >            pha         ;use stack to load status
1a00 : 28              >            plp
                        
1a01 : ad1a02                   lda abs1+3
1a04 : 08                       php         ;test stores do not alter flags
1a05 : 49c3                     eor #$c3
1a07 : 28                       plp
1a08 : 8505                     sta zpt+3
1a0a : 08                       php         ;flags after load/store sequence
1a0b : 49c3                     eor #$c3
1a0d : c50c                     cmp zp1+3   ;test result
                                trap_ne
1a0f : d0fe            >        bne *           ;failed not equal (non zero)
                        
1a11 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1a12 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1a14 : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
1a17 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0  
                       >            load_flag 0  
1a19 : a900            >            lda #0               ;allow test to change I-flag (no mask)
                       >
1a1b : 48              >            pha         ;use stack to load status
1a1c : 28              >            plp
                        
1a1d : a9c3                     lda #$c3
1a1f : 08                       php
1a20 : cd1702                   cmp abs1    ;test result
                                trap_ne
1a23 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1a25 : 68                       pla         ;load status
                                eor_flag 0
1a26 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1a28 : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
1a2b : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1a2d : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1a2f : 48              >            pha         ;use stack to load status
1a30 : 28              >            plp
                        
1a31 : a982                     lda #$82
1a33 : 08                       php
1a34 : cd1802                   cmp abs1+1  ;test result
                                trap_ne
1a37 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1a39 : 68                       pla         ;load status
                                eor_flag 0
1a3a : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1a3c : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
1a3f : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1a41 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1a43 : 48              >            pha         ;use stack to load status
1a44 : 28              >            plp
                        
1a45 : a941                     lda #$41
1a47 : 08                       php
1a48 : cd1902                   cmp abs1+2  ;test result
                                trap_ne
1a4b : d0fe            >        bne *           ;failed not equal (non zero)
                        
1a4d : 68                       pla         ;load status
                                eor_flag 0
1a4e : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1a50 : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
1a53 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1a55 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1a57 : 48              >            pha         ;use stack to load status
1a58 : 28              >            plp
                        
1a59 : a900                     lda #0
1a5b : 08                       php
1a5c : cd1a02                   cmp abs1+3  ;test result
                                trap_ne
1a5f : d0fe            >        bne *           ;failed not equal (non zero)
                        
1a61 : 68                       pla         ;load status
                                eor_flag 0
1a62 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1a64 : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
1a67 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
1a69 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1a6b : 48              >            pha         ;use stack to load status
1a6c : 28              >            plp
                        
1a6d : a9c3                     lda #$c3  
1a6f : 08                       php
1a70 : cd1702                   cmp abs1    ;test result
                                trap_ne
1a73 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1a75 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1a76 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1a78 : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
1a7b : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1a7d : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1a7f : 48              >            pha         ;use stack to load status
1a80 : 28              >            plp
                        
1a81 : a982                     lda #$82
1a83 : 08                       php
1a84 : cd1802                   cmp abs1+1  ;test result
                                trap_ne
1a87 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1a89 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1a8a : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1a8c : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
1a8f : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1a91 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1a93 : 48              >            pha         ;use stack to load status
1a94 : 28              >            plp
                        
1a95 : a941                     lda #$41
1a97 : 08                       php
1a98 : cd1902                   cmp abs1+2  ;test result
                                trap_ne
1a9b : d0fe            >        bne *           ;failed not equal (non zero)
                        
1a9d : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1a9e : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1aa0 : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
1aa3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1aa5 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1aa7 : 48              >            pha         ;use stack to load status
1aa8 : 28              >            plp
                        
1aa9 : a900                     lda #0
1aab : 08                       php
1aac : cd1a02                   cmp abs1+3  ;test result
                                trap_ne
1aaf : d0fe            >        bne *           ;failed not equal (non zero)
                        
1ab1 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1ab2 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1ab4 : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
1ab7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
1ab9 : a200                     ldx #0
1abb : a502                     lda zpt  
1abd : 49c3                     eor #$c3
1abf : c509                     cmp zp1  
                                trap_ne     ;store to zp data
1ac1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1ac3 : 8602                     stx zpt     ;clear                
1ac5 : ad0302                   lda abst  
1ac8 : 49c3                     eor #$c3
1aca : cd1702                   cmp abs1  
                                trap_ne     ;store to abs data
1acd : d0fe            >        bne *           ;failed not equal (non zero)
                        
1acf : 8e0302                   stx abst    ;clear                
1ad2 : a503                     lda zpt+1
1ad4 : 49c3                     eor #$c3
1ad6 : c50a                     cmp zp1+1
                                trap_ne     ;store to zp data
1ad8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1ada : 8603                     stx zpt+1   ;clear                
1adc : ad0402                   lda abst+1
1adf : 49c3                     eor #$c3
1ae1 : cd1802                   cmp abs1+1
                                trap_ne     ;store to abs data
1ae4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1ae6 : 8e0402                   stx abst+1  ;clear                
1ae9 : a504                     lda zpt+2
1aeb : 49c3                     eor #$c3
1aed : c50b                     cmp zp1+2
                                trap_ne     ;store to zp data
1aef : d0fe            >        bne *           ;failed not equal (non zero)
                        
1af1 : 8604                     stx zpt+2   ;clear                
1af3 : ad0502                   lda abst+2
1af6 : 49c3                     eor #$c3
1af8 : cd1902                   cmp abs1+2
                                trap_ne     ;store to abs data
1afb : d0fe            >        bne *           ;failed not equal (non zero)
                        
1afd : 8e0502                   stx abst+2  ;clear                
1b00 : a505                     lda zpt+3
1b02 : 49c3                     eor #$c3
1b04 : c50c                     cmp zp1+3
                                trap_ne     ;store to zp data
1b06 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1b08 : 8605                     stx zpt+3   ;clear                
1b0a : ad0602                   lda abst+3
1b0d : 49c3                     eor #$c3
1b0f : cd1a02                   cmp abs1+3
                                trap_ne     ;store to abs data
1b12 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1b14 : 8e0602                   stx abst+3  ;clear                
                                next_test
1b17 : ad0002          >            lda test_case   ;previous test
1b1a : c918            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
1b1c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0019 =                 >test_num = test_num + 1
1b1e : a919            >            lda #test_num   ;*** next tests' number
1b20 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing bit test & compares BIT CPX CPY CMP all addressing modes
                        ; BIT - zp / abs
                                set_a $ff,0
                       >            load_flag 0
1b23 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1b25 : 48              >            pha         ;use stack to load status
1b26 : a9ff            >            lda #$ff     ;precharge accu
1b28 : 28              >            plp
                        
1b29 : 240c                     bit zp1+3   ;00 - should set Z / clear  NV
                                tst_a $ff,fz 
1b2b : 08              >            php         ;save flags
1b2c : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
1b2e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1b30 : 68              >            pla         ;load status
1b31 : 48              >            pha
                       >            cmp_flag fz 
1b32 : c932            >            cmp #(fz |fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1b34 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1b36 : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
1b37 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1b39 : 48              >            pha         ;use stack to load status
1b3a : a901            >            lda #1     ;precharge accu
1b3c : 28              >            plp
                        
1b3d : 240b                     bit zp1+2   ;41 - should set V (M6) / clear NZ
                                tst_a 1,fv
1b3f : 08              >            php         ;save flags
1b40 : c901            >            cmp #1     ;test result
                       >            trap_ne
1b42 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1b44 : 68              >            pla         ;load status
1b45 : 48              >            pha
                       >            cmp_flag fv
1b46 : c970            >            cmp #(fv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1b48 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1b4a : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
1b4b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1b4d : 48              >            pha         ;use stack to load status
1b4e : a901            >            lda #1     ;precharge accu
1b50 : 28              >            plp
                        
1b51 : 240a                     bit zp1+1   ;82 - should set N (M7) & Z / clear V
                                tst_a 1,fnz
1b53 : 08              >            php         ;save flags
1b54 : c901            >            cmp #1     ;test result
                       >            trap_ne
1b56 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1b58 : 68              >            pla         ;load status
1b59 : 48              >            pha
                       >            cmp_flag fnz
1b5a : c9b2            >            cmp #(fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1b5c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1b5e : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
1b5f : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1b61 : 48              >            pha         ;use stack to load status
1b62 : a901            >            lda #1     ;precharge accu
1b64 : 28              >            plp
                        
1b65 : 2409                     bit zp1     ;c3 - should set N (M7) & V (M6) / clear Z
                                tst_a 1,fnv
1b67 : 08              >            php         ;save flags
1b68 : c901            >            cmp #1     ;test result
                       >            trap_ne
1b6a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1b6c : 68              >            pla         ;load status
1b6d : 48              >            pha
                       >            cmp_flag fnv
1b6e : c9f0            >            cmp #(fnv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1b70 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1b72 : 28              >            plp         ;restore status
                        
                                
                                set_a $ff,$ff
                       >            load_flag $ff
1b73 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1b75 : 48              >            pha         ;use stack to load status
1b76 : a9ff            >            lda #$ff     ;precharge accu
1b78 : 28              >            plp
                        
1b79 : 240c                     bit zp1+3   ;00 - should set Z / clear  NV
                                tst_a $ff,~fnv 
1b7b : 08              >            php         ;save flags
1b7c : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
1b7e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1b80 : 68              >            pla         ;load status
1b81 : 48              >            pha
                       >            cmp_flag ~fnv 
1b82 : c93f            >            cmp #(~fnv |fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1b84 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1b86 : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
1b87 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1b89 : 48              >            pha         ;use stack to load status
1b8a : a901            >            lda #1     ;precharge accu
1b8c : 28              >            plp
                        
1b8d : 240b                     bit zp1+2   ;41 - should set V (M6) / clear NZ
                                tst_a 1,~fnz
1b8f : 08              >            php         ;save flags
1b90 : c901            >            cmp #1     ;test result
                       >            trap_ne
1b92 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1b94 : 68              >            pla         ;load status
1b95 : 48              >            pha
                       >            cmp_flag ~fnz
1b96 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1b98 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1b9a : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
1b9b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1b9d : 48              >            pha         ;use stack to load status
1b9e : a901            >            lda #1     ;precharge accu
1ba0 : 28              >            plp
                        
1ba1 : 240a                     bit zp1+1   ;82 - should set N (M7) & Z / clear V
                                tst_a 1,~fv
1ba3 : 08              >            php         ;save flags
1ba4 : c901            >            cmp #1     ;test result
                       >            trap_ne
1ba6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ba8 : 68              >            pla         ;load status
1ba9 : 48              >            pha
                       >            cmp_flag ~fv
1baa : c9bf            >            cmp #(~fv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1bac : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1bae : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
1baf : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1bb1 : 48              >            pha         ;use stack to load status
1bb2 : a901            >            lda #1     ;precharge accu
1bb4 : 28              >            plp
                        
1bb5 : 2409                     bit zp1     ;c3 - should set N (M7) & V (M6) / clear Z
                                tst_a 1,~fz
1bb7 : 08              >            php         ;save flags
1bb8 : c901            >            cmp #1     ;test result
                       >            trap_ne
1bba : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1bbc : 68              >            pla         ;load status
1bbd : 48              >            pha
                       >            cmp_flag ~fz
1bbe : c9fd            >            cmp #(~fz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1bc0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1bc2 : 28              >            plp         ;restore status
                        
                                
                                set_a $ff,0
                       >            load_flag 0
1bc3 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1bc5 : 48              >            pha         ;use stack to load status
1bc6 : a9ff            >            lda #$ff     ;precharge accu
1bc8 : 28              >            plp
                        
1bc9 : 2c1a02                   bit abs1+3  ;00 - should set Z / clear  NV
                                tst_a $ff,fz 
1bcc : 08              >            php         ;save flags
1bcd : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
1bcf : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1bd1 : 68              >            pla         ;load status
1bd2 : 48              >            pha
                       >            cmp_flag fz 
1bd3 : c932            >            cmp #(fz |fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1bd5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1bd7 : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
1bd8 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1bda : 48              >            pha         ;use stack to load status
1bdb : a901            >            lda #1     ;precharge accu
1bdd : 28              >            plp
                        
1bde : 2c1902                   bit abs1+2  ;41 - should set V (M6) / clear NZ
                                tst_a 1,fv
1be1 : 08              >            php         ;save flags
1be2 : c901            >            cmp #1     ;test result
                       >            trap_ne
1be4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1be6 : 68              >            pla         ;load status
1be7 : 48              >            pha
                       >            cmp_flag fv
1be8 : c970            >            cmp #(fv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1bea : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1bec : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
1bed : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1bef : 48              >            pha         ;use stack to load status
1bf0 : a901            >            lda #1     ;precharge accu
1bf2 : 28              >            plp
                        
1bf3 : 2c1802                   bit abs1+1  ;82 - should set N (M7) & Z / clear V
                                tst_a 1,fnz
1bf6 : 08              >            php         ;save flags
1bf7 : c901            >            cmp #1     ;test result
                       >            trap_ne
1bf9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1bfb : 68              >            pla         ;load status
1bfc : 48              >            pha
                       >            cmp_flag fnz
1bfd : c9b2            >            cmp #(fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1bff : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c01 : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
1c02 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1c04 : 48              >            pha         ;use stack to load status
1c05 : a901            >            lda #1     ;precharge accu
1c07 : 28              >            plp
                        
1c08 : 2c1702                   bit abs1    ;c3 - should set N (M7) & V (M6) / clear Z
                                tst_a 1,fnv
1c0b : 08              >            php         ;save flags
1c0c : c901            >            cmp #1     ;test result
                       >            trap_ne
1c0e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c10 : 68              >            pla         ;load status
1c11 : 48              >            pha
                       >            cmp_flag fnv
1c12 : c9f0            >            cmp #(fnv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1c14 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c16 : 28              >            plp         ;restore status
                        
                                
                                set_a $ff,$ff
                       >            load_flag $ff
1c17 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1c19 : 48              >            pha         ;use stack to load status
1c1a : a9ff            >            lda #$ff     ;precharge accu
1c1c : 28              >            plp
                        
1c1d : 2c1a02                   bit abs1+3  ;00 - should set Z / clear  NV
                                tst_a $ff,~fnv 
1c20 : 08              >            php         ;save flags
1c21 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
1c23 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c25 : 68              >            pla         ;load status
1c26 : 48              >            pha
                       >            cmp_flag ~fnv 
1c27 : c93f            >            cmp #(~fnv |fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1c29 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c2b : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
1c2c : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1c2e : 48              >            pha         ;use stack to load status
1c2f : a901            >            lda #1     ;precharge accu
1c31 : 28              >            plp
                        
1c32 : 2c1902                   bit abs1+2  ;41 - should set V (M6) / clear NZ
                                tst_a 1,~fnz
1c35 : 08              >            php         ;save flags
1c36 : c901            >            cmp #1     ;test result
                       >            trap_ne
1c38 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c3a : 68              >            pla         ;load status
1c3b : 48              >            pha
                       >            cmp_flag ~fnz
1c3c : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1c3e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c40 : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
1c41 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1c43 : 48              >            pha         ;use stack to load status
1c44 : a901            >            lda #1     ;precharge accu
1c46 : 28              >            plp
                        
1c47 : 2c1802                   bit abs1+1  ;82 - should set N (M7) & Z / clear V
                                tst_a 1,~fv
1c4a : 08              >            php         ;save flags
1c4b : c901            >            cmp #1     ;test result
                       >            trap_ne
1c4d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c4f : 68              >            pla         ;load status
1c50 : 48              >            pha
                       >            cmp_flag ~fv
1c51 : c9bf            >            cmp #(~fv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1c53 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c55 : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
1c56 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1c58 : 48              >            pha         ;use stack to load status
1c59 : a901            >            lda #1     ;precharge accu
1c5b : 28              >            plp
                        
1c5c : 2c1702                   bit abs1    ;c3 - should set N (M7) & V (M6) / clear Z
                                tst_a 1,~fz
1c5f : 08              >            php         ;save flags
1c60 : c901            >            cmp #1     ;test result
                       >            trap_ne
1c62 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c64 : 68              >            pla         ;load status
1c65 : 48              >            pha
                       >            cmp_flag ~fz
1c66 : c9fd            >            cmp #(~fz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1c68 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c6a : 28              >            plp         ;restore status
                        
                                next_test
1c6b : ad0002          >            lda test_case   ;previous test
1c6e : c919            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
1c70 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
001a =                 >test_num = test_num + 1
1c72 : a91a            >            lda #test_num   ;*** next tests' number
1c74 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; CPX - zp / abs / #         
                                set_x $80,0
                       >            load_flag 0
1c77 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1c79 : 48              >            pha         ;use stack to load status
1c7a : a280            >            ldx #$80     ;precharge index x
1c7c : 28              >            plp
                        
1c7d : e40d                     cpx zp7f
                                tst_stat fc
1c7f : 08              >            php         ;save status
1c80 : 68              >            pla         ;use stack to retrieve status
1c81 : 48              >            pha
                       >            cmp_flag fc
1c82 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1c84 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c86 : 28              >            plp         ;restore status
                        
1c87 : ca                       dex
1c88 : e40d                     cpx zp7f
                                tst_stat fzc
1c8a : 08              >            php         ;save status
1c8b : 68              >            pla         ;use stack to retrieve status
1c8c : 48              >            pha
                       >            cmp_flag fzc
1c8d : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1c8f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c91 : 28              >            plp         ;restore status
                        
1c92 : ca                       dex
1c93 : e40d                     cpx zp7f
                                tst_x $7e,fn
1c95 : 08              >            php         ;save flags
1c96 : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
1c98 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c9a : 68              >            pla         ;load status
1c9b : 48              >            pha
                       >            cmp_flag fn
1c9c : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1c9e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ca0 : 28              >            plp         ;restore status
                        
                                set_x $80,$ff
                       >            load_flag $ff
1ca1 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1ca3 : 48              >            pha         ;use stack to load status
1ca4 : a280            >            ldx #$80     ;precharge index x
1ca6 : 28              >            plp
                        
1ca7 : e40d                     cpx zp7f
                                tst_stat ~fnz
1ca9 : 08              >            php         ;save status
1caa : 68              >            pla         ;use stack to retrieve status
1cab : 48              >            pha
                       >            cmp_flag ~fnz
1cac : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1cae : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1cb0 : 28              >            plp         ;restore status
                        
1cb1 : ca                       dex
1cb2 : e40d                     cpx zp7f
                                tst_stat ~fn
1cb4 : 08              >            php         ;save status
1cb5 : 68              >            pla         ;use stack to retrieve status
1cb6 : 48              >            pha
                       >            cmp_flag ~fn
1cb7 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1cb9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1cbb : 28              >            plp         ;restore status
                        
1cbc : ca                       dex
1cbd : e40d                     cpx zp7f
                                tst_x $7e,~fzc
1cbf : 08              >            php         ;save flags
1cc0 : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
1cc2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1cc4 : 68              >            pla         ;load status
1cc5 : 48              >            pha
                       >            cmp_flag ~fzc
1cc6 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1cc8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1cca : 28              >            plp         ;restore status
                        
                        
                                set_x $80,0
                       >            load_flag 0
1ccb : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1ccd : 48              >            pha         ;use stack to load status
1cce : a280            >            ldx #$80     ;precharge index x
1cd0 : 28              >            plp
                        
1cd1 : ec1b02                   cpx abs7f
                                tst_stat fc
1cd4 : 08              >            php         ;save status
1cd5 : 68              >            pla         ;use stack to retrieve status
1cd6 : 48              >            pha
                       >            cmp_flag fc
1cd7 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1cd9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1cdb : 28              >            plp         ;restore status
                        
1cdc : ca                       dex
1cdd : ec1b02                   cpx abs7f
                                tst_stat fzc
1ce0 : 08              >            php         ;save status
1ce1 : 68              >            pla         ;use stack to retrieve status
1ce2 : 48              >            pha
                       >            cmp_flag fzc
1ce3 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1ce5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ce7 : 28              >            plp         ;restore status
                        
1ce8 : ca                       dex
1ce9 : ec1b02                   cpx abs7f
                                tst_x $7e,fn
1cec : 08              >            php         ;save flags
1ced : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
1cef : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1cf1 : 68              >            pla         ;load status
1cf2 : 48              >            pha
                       >            cmp_flag fn
1cf3 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1cf5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1cf7 : 28              >            plp         ;restore status
                        
                                set_x $80,$ff
                       >            load_flag $ff
1cf8 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1cfa : 48              >            pha         ;use stack to load status
1cfb : a280            >            ldx #$80     ;precharge index x
1cfd : 28              >            plp
                        
1cfe : ec1b02                   cpx abs7f
                                tst_stat ~fnz
1d01 : 08              >            php         ;save status
1d02 : 68              >            pla         ;use stack to retrieve status
1d03 : 48              >            pha
                       >            cmp_flag ~fnz
1d04 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d06 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d08 : 28              >            plp         ;restore status
                        
1d09 : ca                       dex
1d0a : ec1b02                   cpx abs7f
                                tst_stat ~fn
1d0d : 08              >            php         ;save status
1d0e : 68              >            pla         ;use stack to retrieve status
1d0f : 48              >            pha
                       >            cmp_flag ~fn
1d10 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d12 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d14 : 28              >            plp         ;restore status
                        
1d15 : ca                       dex
1d16 : ec1b02                   cpx abs7f
                                tst_x $7e,~fzc
1d19 : 08              >            php         ;save flags
1d1a : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
1d1c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d1e : 68              >            pla         ;load status
1d1f : 48              >            pha
                       >            cmp_flag ~fzc
1d20 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d22 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d24 : 28              >            plp         ;restore status
                        
                        
                                set_x $80,0
                       >            load_flag 0
1d25 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1d27 : 48              >            pha         ;use stack to load status
1d28 : a280            >            ldx #$80     ;precharge index x
1d2a : 28              >            plp
                        
1d2b : e07f                     cpx #$7f
                                tst_stat fc
1d2d : 08              >            php         ;save status
1d2e : 68              >            pla         ;use stack to retrieve status
1d2f : 48              >            pha
                       >            cmp_flag fc
1d30 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d32 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d34 : 28              >            plp         ;restore status
                        
1d35 : ca                       dex
1d36 : e07f                     cpx #$7f
                                tst_stat fzc
1d38 : 08              >            php         ;save status
1d39 : 68              >            pla         ;use stack to retrieve status
1d3a : 48              >            pha
                       >            cmp_flag fzc
1d3b : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d3d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d3f : 28              >            plp         ;restore status
                        
1d40 : ca                       dex
1d41 : e07f                     cpx #$7f
                                tst_x $7e,fn
1d43 : 08              >            php         ;save flags
1d44 : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
1d46 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d48 : 68              >            pla         ;load status
1d49 : 48              >            pha
                       >            cmp_flag fn
1d4a : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d4c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d4e : 28              >            plp         ;restore status
                        
                                set_x $80,$ff
                       >            load_flag $ff
1d4f : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1d51 : 48              >            pha         ;use stack to load status
1d52 : a280            >            ldx #$80     ;precharge index x
1d54 : 28              >            plp
                        
1d55 : e07f                     cpx #$7f
                                tst_stat ~fnz
1d57 : 08              >            php         ;save status
1d58 : 68              >            pla         ;use stack to retrieve status
1d59 : 48              >            pha
                       >            cmp_flag ~fnz
1d5a : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d5c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d5e : 28              >            plp         ;restore status
                        
1d5f : ca                       dex
1d60 : e07f                     cpx #$7f
                                tst_stat ~fn
1d62 : 08              >            php         ;save status
1d63 : 68              >            pla         ;use stack to retrieve status
1d64 : 48              >            pha
                       >            cmp_flag ~fn
1d65 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d67 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d69 : 28              >            plp         ;restore status
                        
1d6a : ca                       dex
1d6b : e07f                     cpx #$7f
                                tst_x $7e,~fzc
1d6d : 08              >            php         ;save flags
1d6e : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
1d70 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d72 : 68              >            pla         ;load status
1d73 : 48              >            pha
                       >            cmp_flag ~fzc
1d74 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d76 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d78 : 28              >            plp         ;restore status
                        
                                next_test
1d79 : ad0002          >            lda test_case   ;previous test
1d7c : c91a            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
1d7e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
001b =                 >test_num = test_num + 1
1d80 : a91b            >            lda #test_num   ;*** next tests' number
1d82 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; CPY - zp / abs / #         
                                set_y $80,0
                       >            load_flag 0
1d85 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1d87 : 48              >            pha         ;use stack to load status
1d88 : a080            >            ldy #$80     ;precharge index y
1d8a : 28              >            plp
                        
1d8b : c40d                     cpy zp7f
                                tst_stat fc
1d8d : 08              >            php         ;save status
1d8e : 68              >            pla         ;use stack to retrieve status
1d8f : 48              >            pha
                       >            cmp_flag fc
1d90 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d92 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d94 : 28              >            plp         ;restore status
                        
1d95 : 88                       dey
1d96 : c40d                     cpy zp7f
                                tst_stat fzc
1d98 : 08              >            php         ;save status
1d99 : 68              >            pla         ;use stack to retrieve status
1d9a : 48              >            pha
                       >            cmp_flag fzc
1d9b : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d9d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d9f : 28              >            plp         ;restore status
                        
1da0 : 88                       dey
1da1 : c40d                     cpy zp7f
                                tst_y $7e,fn
1da3 : 08              >            php         ;save flags
1da4 : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
1da6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1da8 : 68              >            pla         ;load status
1da9 : 48              >            pha
                       >            cmp_flag fn
1daa : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1dac : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1dae : 28              >            plp         ;restore status
                        
                                set_y $80,$ff
                       >            load_flag $ff
1daf : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1db1 : 48              >            pha         ;use stack to load status
1db2 : a080            >            ldy #$80     ;precharge index y
1db4 : 28              >            plp
                        
1db5 : c40d                     cpy zp7f
                                tst_stat ~fnz
1db7 : 08              >            php         ;save status
1db8 : 68              >            pla         ;use stack to retrieve status
1db9 : 48              >            pha
                       >            cmp_flag ~fnz
1dba : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1dbc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1dbe : 28              >            plp         ;restore status
                        
1dbf : 88                       dey
1dc0 : c40d                     cpy zp7f
                                tst_stat ~fn
1dc2 : 08              >            php         ;save status
1dc3 : 68              >            pla         ;use stack to retrieve status
1dc4 : 48              >            pha
                       >            cmp_flag ~fn
1dc5 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1dc7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1dc9 : 28              >            plp         ;restore status
                        
1dca : 88                       dey
1dcb : c40d                     cpy zp7f
                                tst_y $7e,~fzc
1dcd : 08              >            php         ;save flags
1dce : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
1dd0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1dd2 : 68              >            pla         ;load status
1dd3 : 48              >            pha
                       >            cmp_flag ~fzc
1dd4 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1dd6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1dd8 : 28              >            plp         ;restore status
                        
                        
                                set_y $80,0
                       >            load_flag 0
1dd9 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1ddb : 48              >            pha         ;use stack to load status
1ddc : a080            >            ldy #$80     ;precharge index y
1dde : 28              >            plp
                        
1ddf : cc1b02                   cpy abs7f
                                tst_stat fc
1de2 : 08              >            php         ;save status
1de3 : 68              >            pla         ;use stack to retrieve status
1de4 : 48              >            pha
                       >            cmp_flag fc
1de5 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1de7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1de9 : 28              >            plp         ;restore status
                        
1dea : 88                       dey
1deb : cc1b02                   cpy abs7f
                                tst_stat fzc
1dee : 08              >            php         ;save status
1def : 68              >            pla         ;use stack to retrieve status
1df0 : 48              >            pha
                       >            cmp_flag fzc
1df1 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1df3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1df5 : 28              >            plp         ;restore status
                        
1df6 : 88                       dey
1df7 : cc1b02                   cpy abs7f
                                tst_y $7e,fn
1dfa : 08              >            php         ;save flags
1dfb : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
1dfd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1dff : 68              >            pla         ;load status
1e00 : 48              >            pha
                       >            cmp_flag fn
1e01 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e03 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e05 : 28              >            plp         ;restore status
                        
                                set_y $80,$ff
                       >            load_flag $ff
1e06 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1e08 : 48              >            pha         ;use stack to load status
1e09 : a080            >            ldy #$80     ;precharge index y
1e0b : 28              >            plp
                        
1e0c : cc1b02                   cpy abs7f
                                tst_stat ~fnz
1e0f : 08              >            php         ;save status
1e10 : 68              >            pla         ;use stack to retrieve status
1e11 : 48              >            pha
                       >            cmp_flag ~fnz
1e12 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e14 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e16 : 28              >            plp         ;restore status
                        
1e17 : 88                       dey
1e18 : cc1b02                   cpy abs7f
                                tst_stat ~fn
1e1b : 08              >            php         ;save status
1e1c : 68              >            pla         ;use stack to retrieve status
1e1d : 48              >            pha
                       >            cmp_flag ~fn
1e1e : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e20 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e22 : 28              >            plp         ;restore status
                        
1e23 : 88                       dey
1e24 : cc1b02                   cpy abs7f
                                tst_y $7e,~fzc
1e27 : 08              >            php         ;save flags
1e28 : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
1e2a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e2c : 68              >            pla         ;load status
1e2d : 48              >            pha
                       >            cmp_flag ~fzc
1e2e : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e30 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e32 : 28              >            plp         ;restore status
                        
                        
                                set_y $80,0
                       >            load_flag 0
1e33 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1e35 : 48              >            pha         ;use stack to load status
1e36 : a080            >            ldy #$80     ;precharge index y
1e38 : 28              >            plp
                        
1e39 : c07f                     cpy #$7f
                                tst_stat fc
1e3b : 08              >            php         ;save status
1e3c : 68              >            pla         ;use stack to retrieve status
1e3d : 48              >            pha
                       >            cmp_flag fc
1e3e : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e40 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e42 : 28              >            plp         ;restore status
                        
1e43 : 88                       dey
1e44 : c07f                     cpy #$7f
                                tst_stat fzc
1e46 : 08              >            php         ;save status
1e47 : 68              >            pla         ;use stack to retrieve status
1e48 : 48              >            pha
                       >            cmp_flag fzc
1e49 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e4b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e4d : 28              >            plp         ;restore status
                        
1e4e : 88                       dey
1e4f : c07f                     cpy #$7f
                                tst_y $7e,fn
1e51 : 08              >            php         ;save flags
1e52 : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
1e54 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e56 : 68              >            pla         ;load status
1e57 : 48              >            pha
                       >            cmp_flag fn
1e58 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e5a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e5c : 28              >            plp         ;restore status
                        
                                set_y $80,$ff
                       >            load_flag $ff
1e5d : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1e5f : 48              >            pha         ;use stack to load status
1e60 : a080            >            ldy #$80     ;precharge index y
1e62 : 28              >            plp
                        
1e63 : c07f                     cpy #$7f
                                tst_stat ~fnz
1e65 : 08              >            php         ;save status
1e66 : 68              >            pla         ;use stack to retrieve status
1e67 : 48              >            pha
                       >            cmp_flag ~fnz
1e68 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e6a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e6c : 28              >            plp         ;restore status
                        
1e6d : 88                       dey
1e6e : c07f                     cpy #$7f
                                tst_stat ~fn
1e70 : 08              >            php         ;save status
1e71 : 68              >            pla         ;use stack to retrieve status
1e72 : 48              >            pha
                       >            cmp_flag ~fn
1e73 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e75 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e77 : 28              >            plp         ;restore status
                        
1e78 : 88                       dey
1e79 : c07f                     cpy #$7f
                                tst_y $7e,~fzc
1e7b : 08              >            php         ;save flags
1e7c : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
1e7e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e80 : 68              >            pla         ;load status
1e81 : 48              >            pha
                       >            cmp_flag ~fzc
1e82 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e84 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e86 : 28              >            plp         ;restore status
                        
                                next_test
1e87 : ad0002          >            lda test_case   ;previous test
1e8a : c91b            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
1e8c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
001c =                 >test_num = test_num + 1
1e8e : a91c            >            lda #test_num   ;*** next tests' number
1e90 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; CMP - zp / abs / #         
                                set_a $80,0
                       >            load_flag 0
1e93 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1e95 : 48              >            pha         ;use stack to load status
1e96 : a980            >            lda #$80     ;precharge accu
1e98 : 28              >            plp
                        
1e99 : c50d                     cmp zp7f
                                tst_a $80,fc
1e9b : 08              >            php         ;save flags
1e9c : c980            >            cmp #$80     ;test result
                       >            trap_ne
1e9e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ea0 : 68              >            pla         ;load status
1ea1 : 48              >            pha
                       >            cmp_flag fc
1ea2 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1ea4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ea6 : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
1ea7 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1ea9 : 48              >            pha         ;use stack to load status
1eaa : a97f            >            lda #$7f     ;precharge accu
1eac : 28              >            plp
                        
1ead : c50d                     cmp zp7f
                                tst_a $7f,fzc
1eaf : 08              >            php         ;save flags
1eb0 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
1eb2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1eb4 : 68              >            pla         ;load status
1eb5 : 48              >            pha
                       >            cmp_flag fzc
1eb6 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1eb8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1eba : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
1ebb : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1ebd : 48              >            pha         ;use stack to load status
1ebe : a97e            >            lda #$7e     ;precharge accu
1ec0 : 28              >            plp
                        
1ec1 : c50d                     cmp zp7f
                                tst_a $7e,fn
1ec3 : 08              >            php         ;save flags
1ec4 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
1ec6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ec8 : 68              >            pla         ;load status
1ec9 : 48              >            pha
                       >            cmp_flag fn
1eca : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1ecc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ece : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
1ecf : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1ed1 : 48              >            pha         ;use stack to load status
1ed2 : a980            >            lda #$80     ;precharge accu
1ed4 : 28              >            plp
                        
1ed5 : c50d                     cmp zp7f
                                tst_a $80,~fnz
1ed7 : 08              >            php         ;save flags
1ed8 : c980            >            cmp #$80     ;test result
                       >            trap_ne
1eda : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1edc : 68              >            pla         ;load status
1edd : 48              >            pha
                       >            cmp_flag ~fnz
1ede : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1ee0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ee2 : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
1ee3 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1ee5 : 48              >            pha         ;use stack to load status
1ee6 : a97f            >            lda #$7f     ;precharge accu
1ee8 : 28              >            plp
                        
1ee9 : c50d                     cmp zp7f
                                tst_a $7f,~fn
1eeb : 08              >            php         ;save flags
1eec : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
1eee : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ef0 : 68              >            pla         ;load status
1ef1 : 48              >            pha
                       >            cmp_flag ~fn
1ef2 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1ef4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ef6 : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
1ef7 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1ef9 : 48              >            pha         ;use stack to load status
1efa : a97e            >            lda #$7e     ;precharge accu
1efc : 28              >            plp
                        
1efd : c50d                     cmp zp7f
                                tst_a $7e,~fzc
1eff : 08              >            php         ;save flags
1f00 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
1f02 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f04 : 68              >            pla         ;load status
1f05 : 48              >            pha
                       >            cmp_flag ~fzc
1f06 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1f08 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f0a : 28              >            plp         ;restore status
                        
                        
                                set_a $80,0
                       >            load_flag 0
1f0b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1f0d : 48              >            pha         ;use stack to load status
1f0e : a980            >            lda #$80     ;precharge accu
1f10 : 28              >            plp
                        
1f11 : cd1b02                   cmp abs7f
                                tst_a $80,fc
1f14 : 08              >            php         ;save flags
1f15 : c980            >            cmp #$80     ;test result
                       >            trap_ne
1f17 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f19 : 68              >            pla         ;load status
1f1a : 48              >            pha
                       >            cmp_flag fc
1f1b : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1f1d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f1f : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
1f20 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1f22 : 48              >            pha         ;use stack to load status
1f23 : a97f            >            lda #$7f     ;precharge accu
1f25 : 28              >            plp
                        
1f26 : cd1b02                   cmp abs7f
                                tst_a $7f,fzc
1f29 : 08              >            php         ;save flags
1f2a : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
1f2c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f2e : 68              >            pla         ;load status
1f2f : 48              >            pha
                       >            cmp_flag fzc
1f30 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1f32 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f34 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
1f35 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1f37 : 48              >            pha         ;use stack to load status
1f38 : a97e            >            lda #$7e     ;precharge accu
1f3a : 28              >            plp
                        
1f3b : cd1b02                   cmp abs7f
                                tst_a $7e,fn
1f3e : 08              >            php         ;save flags
1f3f : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
1f41 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f43 : 68              >            pla         ;load status
1f44 : 48              >            pha
                       >            cmp_flag fn
1f45 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1f47 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f49 : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
1f4a : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1f4c : 48              >            pha         ;use stack to load status
1f4d : a980            >            lda #$80     ;precharge accu
1f4f : 28              >            plp
                        
1f50 : cd1b02                   cmp abs7f
                                tst_a $80,~fnz
1f53 : 08              >            php         ;save flags
1f54 : c980            >            cmp #$80     ;test result
                       >            trap_ne
1f56 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f58 : 68              >            pla         ;load status
1f59 : 48              >            pha
                       >            cmp_flag ~fnz
1f5a : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1f5c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f5e : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
1f5f : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1f61 : 48              >            pha         ;use stack to load status
1f62 : a97f            >            lda #$7f     ;precharge accu
1f64 : 28              >            plp
                        
1f65 : cd1b02                   cmp abs7f
                                tst_a $7f,~fn
1f68 : 08              >            php         ;save flags
1f69 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
1f6b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f6d : 68              >            pla         ;load status
1f6e : 48              >            pha
                       >            cmp_flag ~fn
1f6f : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1f71 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f73 : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
1f74 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1f76 : 48              >            pha         ;use stack to load status
1f77 : a97e            >            lda #$7e     ;precharge accu
1f79 : 28              >            plp
                        
1f7a : cd1b02                   cmp abs7f
                                tst_a $7e,~fzc
1f7d : 08              >            php         ;save flags
1f7e : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
1f80 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f82 : 68              >            pla         ;load status
1f83 : 48              >            pha
                       >            cmp_flag ~fzc
1f84 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1f86 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f88 : 28              >            plp         ;restore status
                        
                        
                                set_a $80,0
                       >            load_flag 0
1f89 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1f8b : 48              >            pha         ;use stack to load status
1f8c : a980            >            lda #$80     ;precharge accu
1f8e : 28              >            plp
                        
1f8f : c97f                     cmp #$7f
                                tst_a $80,fc
1f91 : 08              >            php         ;save flags
1f92 : c980            >            cmp #$80     ;test result
                       >            trap_ne
1f94 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f96 : 68              >            pla         ;load status
1f97 : 48              >            pha
                       >            cmp_flag fc
1f98 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1f9a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f9c : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
1f9d : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1f9f : 48              >            pha         ;use stack to load status
1fa0 : a97f            >            lda #$7f     ;precharge accu
1fa2 : 28              >            plp
                        
1fa3 : c97f                     cmp #$7f
                                tst_a $7f,fzc
1fa5 : 08              >            php         ;save flags
1fa6 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
1fa8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1faa : 68              >            pla         ;load status
1fab : 48              >            pha
                       >            cmp_flag fzc
1fac : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1fae : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1fb0 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
1fb1 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1fb3 : 48              >            pha         ;use stack to load status
1fb4 : a97e            >            lda #$7e     ;precharge accu
1fb6 : 28              >            plp
                        
1fb7 : c97f                     cmp #$7f
                                tst_a $7e,fn
1fb9 : 08              >            php         ;save flags
1fba : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
1fbc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1fbe : 68              >            pla         ;load status
1fbf : 48              >            pha
                       >            cmp_flag fn
1fc0 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1fc2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1fc4 : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
1fc5 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1fc7 : 48              >            pha         ;use stack to load status
1fc8 : a980            >            lda #$80     ;precharge accu
1fca : 28              >            plp
                        
1fcb : c97f                     cmp #$7f
                                tst_a $80,~fnz
1fcd : 08              >            php         ;save flags
1fce : c980            >            cmp #$80     ;test result
                       >            trap_ne
1fd0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1fd2 : 68              >            pla         ;load status
1fd3 : 48              >            pha
                       >            cmp_flag ~fnz
1fd4 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1fd6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1fd8 : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
1fd9 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1fdb : 48              >            pha         ;use stack to load status
1fdc : a97f            >            lda #$7f     ;precharge accu
1fde : 28              >            plp
                        
1fdf : c97f                     cmp #$7f
                                tst_a $7f,~fn
1fe1 : 08              >            php         ;save flags
1fe2 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
1fe4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1fe6 : 68              >            pla         ;load status
1fe7 : 48              >            pha
                       >            cmp_flag ~fn
1fe8 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1fea : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1fec : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
1fed : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1fef : 48              >            pha         ;use stack to load status
1ff0 : a97e            >            lda #$7e     ;precharge accu
1ff2 : 28              >            plp
                        
1ff3 : c97f                     cmp #$7f
                                tst_a $7e,~fzc
1ff5 : 08              >            php         ;save flags
1ff6 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
1ff8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ffa : 68              >            pla         ;load status
1ffb : 48              >            pha
                       >            cmp_flag ~fzc
1ffc : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1ffe : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2000 : 28              >            plp         ;restore status
                        
                        
2001 : a204                     ldx #4          ;with indexing by X
                                set_a $80,0
                       >            load_flag 0
2003 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2005 : 48              >            pha         ;use stack to load status
2006 : a980            >            lda #$80     ;precharge accu
2008 : 28              >            plp
                        
2009 : d509                     cmp zp1,x
                                tst_a $80,fc
200b : 08              >            php         ;save flags
200c : c980            >            cmp #$80     ;test result
                       >            trap_ne
200e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2010 : 68              >            pla         ;load status
2011 : 48              >            pha
                       >            cmp_flag fc
2012 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2014 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2016 : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
2017 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2019 : 48              >            pha         ;use stack to load status
201a : a97f            >            lda #$7f     ;precharge accu
201c : 28              >            plp
                        
201d : d509                     cmp zp1,x
                                tst_a $7f,fzc
201f : 08              >            php         ;save flags
2020 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
2022 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2024 : 68              >            pla         ;load status
2025 : 48              >            pha
                       >            cmp_flag fzc
2026 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2028 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
202a : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
202b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
202d : 48              >            pha         ;use stack to load status
202e : a97e            >            lda #$7e     ;precharge accu
2030 : 28              >            plp
                        
2031 : d509                     cmp zp1,x
                                tst_a $7e,fn
2033 : 08              >            php         ;save flags
2034 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
2036 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2038 : 68              >            pla         ;load status
2039 : 48              >            pha
                       >            cmp_flag fn
203a : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
203c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
203e : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
203f : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2041 : 48              >            pha         ;use stack to load status
2042 : a980            >            lda #$80     ;precharge accu
2044 : 28              >            plp
                        
2045 : d509                     cmp zp1,x
                                tst_a $80,~fnz
2047 : 08              >            php         ;save flags
2048 : c980            >            cmp #$80     ;test result
                       >            trap_ne
204a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
204c : 68              >            pla         ;load status
204d : 48              >            pha
                       >            cmp_flag ~fnz
204e : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2050 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2052 : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
2053 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2055 : 48              >            pha         ;use stack to load status
2056 : a97f            >            lda #$7f     ;precharge accu
2058 : 28              >            plp
                        
2059 : d509                     cmp zp1,x
                                tst_a $7f,~fn
205b : 08              >            php         ;save flags
205c : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
205e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2060 : 68              >            pla         ;load status
2061 : 48              >            pha
                       >            cmp_flag ~fn
2062 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2064 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2066 : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
2067 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2069 : 48              >            pha         ;use stack to load status
206a : a97e            >            lda #$7e     ;precharge accu
206c : 28              >            plp
                        
206d : d509                     cmp zp1,x
                                tst_a $7e,~fzc
206f : 08              >            php         ;save flags
2070 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
2072 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2074 : 68              >            pla         ;load status
2075 : 48              >            pha
                       >            cmp_flag ~fzc
2076 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2078 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
207a : 28              >            plp         ;restore status
                        
                        
                                set_a $80,0
                       >            load_flag 0
207b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
207d : 48              >            pha         ;use stack to load status
207e : a980            >            lda #$80     ;precharge accu
2080 : 28              >            plp
                        
2081 : dd1702                   cmp abs1,x
                                tst_a $80,fc
2084 : 08              >            php         ;save flags
2085 : c980            >            cmp #$80     ;test result
                       >            trap_ne
2087 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2089 : 68              >            pla         ;load status
208a : 48              >            pha
                       >            cmp_flag fc
208b : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
208d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
208f : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
2090 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2092 : 48              >            pha         ;use stack to load status
2093 : a97f            >            lda #$7f     ;precharge accu
2095 : 28              >            plp
                        
2096 : dd1702                   cmp abs1,x
                                tst_a $7f,fzc
2099 : 08              >            php         ;save flags
209a : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
209c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
209e : 68              >            pla         ;load status
209f : 48              >            pha
                       >            cmp_flag fzc
20a0 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
20a2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20a4 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
20a5 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
20a7 : 48              >            pha         ;use stack to load status
20a8 : a97e            >            lda #$7e     ;precharge accu
20aa : 28              >            plp
                        
20ab : dd1702                   cmp abs1,x
                                tst_a $7e,fn
20ae : 08              >            php         ;save flags
20af : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
20b1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20b3 : 68              >            pla         ;load status
20b4 : 48              >            pha
                       >            cmp_flag fn
20b5 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
20b7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20b9 : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
20ba : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
20bc : 48              >            pha         ;use stack to load status
20bd : a980            >            lda #$80     ;precharge accu
20bf : 28              >            plp
                        
20c0 : dd1702                   cmp abs1,x
                                tst_a $80,~fnz
20c3 : 08              >            php         ;save flags
20c4 : c980            >            cmp #$80     ;test result
                       >            trap_ne
20c6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20c8 : 68              >            pla         ;load status
20c9 : 48              >            pha
                       >            cmp_flag ~fnz
20ca : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
20cc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20ce : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
20cf : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
20d1 : 48              >            pha         ;use stack to load status
20d2 : a97f            >            lda #$7f     ;precharge accu
20d4 : 28              >            plp
                        
20d5 : dd1702                   cmp abs1,x
                                tst_a $7f,~fn
20d8 : 08              >            php         ;save flags
20d9 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
20db : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20dd : 68              >            pla         ;load status
20de : 48              >            pha
                       >            cmp_flag ~fn
20df : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
20e1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20e3 : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
20e4 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
20e6 : 48              >            pha         ;use stack to load status
20e7 : a97e            >            lda #$7e     ;precharge accu
20e9 : 28              >            plp
                        
20ea : dd1702                   cmp abs1,x
                                tst_a $7e,~fzc
20ed : 08              >            php         ;save flags
20ee : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
20f0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20f2 : 68              >            pla         ;load status
20f3 : 48              >            pha
                       >            cmp_flag ~fzc
20f4 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
20f6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20f8 : 28              >            plp         ;restore status
                        
                        
20f9 : a004                     ldy #4          ;with indexing by Y
20fb : a208                     ldx #8          ;with indexed indirect
                                set_a $80,0
                       >            load_flag 0
20fd : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
20ff : 48              >            pha         ;use stack to load status
2100 : a980            >            lda #$80     ;precharge accu
2102 : 28              >            plp
                        
2103 : d91702                   cmp abs1,y
                                tst_a $80,fc
2106 : 08              >            php         ;save flags
2107 : c980            >            cmp #$80     ;test result
                       >            trap_ne
2109 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
210b : 68              >            pla         ;load status
210c : 48              >            pha
                       >            cmp_flag fc
210d : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
210f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2111 : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
2112 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2114 : 48              >            pha         ;use stack to load status
2115 : a97f            >            lda #$7f     ;precharge accu
2117 : 28              >            plp
                        
2118 : d91702                   cmp abs1,y
                                tst_a $7f,fzc
211b : 08              >            php         ;save flags
211c : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
211e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2120 : 68              >            pla         ;load status
2121 : 48              >            pha
                       >            cmp_flag fzc
2122 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2124 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2126 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
2127 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2129 : 48              >            pha         ;use stack to load status
212a : a97e            >            lda #$7e     ;precharge accu
212c : 28              >            plp
                        
212d : d91702                   cmp abs1,y
                                tst_a $7e,fn
2130 : 08              >            php         ;save flags
2131 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
2133 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2135 : 68              >            pla         ;load status
2136 : 48              >            pha
                       >            cmp_flag fn
2137 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2139 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
213b : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
213c : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
213e : 48              >            pha         ;use stack to load status
213f : a980            >            lda #$80     ;precharge accu
2141 : 28              >            plp
                        
2142 : d91702                   cmp abs1,y
                                tst_a $80,~fnz
2145 : 08              >            php         ;save flags
2146 : c980            >            cmp #$80     ;test result
                       >            trap_ne
2148 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
214a : 68              >            pla         ;load status
214b : 48              >            pha
                       >            cmp_flag ~fnz
214c : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
214e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2150 : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
2151 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2153 : 48              >            pha         ;use stack to load status
2154 : a97f            >            lda #$7f     ;precharge accu
2156 : 28              >            plp
                        
2157 : d91702                   cmp abs1,y
                                tst_a $7f,~fn
215a : 08              >            php         ;save flags
215b : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
215d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
215f : 68              >            pla         ;load status
2160 : 48              >            pha
                       >            cmp_flag ~fn
2161 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2163 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2165 : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
2166 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2168 : 48              >            pha         ;use stack to load status
2169 : a97e            >            lda #$7e     ;precharge accu
216b : 28              >            plp
                        
216c : d91702                   cmp abs1,y
                                tst_a $7e,~fzc
216f : 08              >            php         ;save flags
2170 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
2172 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2174 : 68              >            pla         ;load status
2175 : 48              >            pha
                       >            cmp_flag ~fzc
2176 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2178 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
217a : 28              >            plp         ;restore status
                        
                        
                                set_a $80,0
                       >            load_flag 0
217b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
217d : 48              >            pha         ;use stack to load status
217e : a980            >            lda #$80     ;precharge accu
2180 : 28              >            plp
                        
2181 : c11a                     cmp (ind1,x)
                                tst_a $80,fc
2183 : 08              >            php         ;save flags
2184 : c980            >            cmp #$80     ;test result
                       >            trap_ne
2186 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2188 : 68              >            pla         ;load status
2189 : 48              >            pha
                       >            cmp_flag fc
218a : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
218c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
218e : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
218f : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2191 : 48              >            pha         ;use stack to load status
2192 : a97f            >            lda #$7f     ;precharge accu
2194 : 28              >            plp
                        
2195 : c11a                     cmp (ind1,x)
                                tst_a $7f,fzc
2197 : 08              >            php         ;save flags
2198 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
219a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
219c : 68              >            pla         ;load status
219d : 48              >            pha
                       >            cmp_flag fzc
219e : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
21a0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21a2 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
21a3 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
21a5 : 48              >            pha         ;use stack to load status
21a6 : a97e            >            lda #$7e     ;precharge accu
21a8 : 28              >            plp
                        
21a9 : c11a                     cmp (ind1,x)
                                tst_a $7e,fn
21ab : 08              >            php         ;save flags
21ac : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
21ae : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21b0 : 68              >            pla         ;load status
21b1 : 48              >            pha
                       >            cmp_flag fn
21b2 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
21b4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21b6 : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
21b7 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
21b9 : 48              >            pha         ;use stack to load status
21ba : a980            >            lda #$80     ;precharge accu
21bc : 28              >            plp
                        
21bd : c11a                     cmp (ind1,x)
                                tst_a $80,~fnz
21bf : 08              >            php         ;save flags
21c0 : c980            >            cmp #$80     ;test result
                       >            trap_ne
21c2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21c4 : 68              >            pla         ;load status
21c5 : 48              >            pha
                       >            cmp_flag ~fnz
21c6 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
21c8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21ca : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
21cb : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
21cd : 48              >            pha         ;use stack to load status
21ce : a97f            >            lda #$7f     ;precharge accu
21d0 : 28              >            plp
                        
21d1 : c11a                     cmp (ind1,x)
                                tst_a $7f,~fn
21d3 : 08              >            php         ;save flags
21d4 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
21d6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21d8 : 68              >            pla         ;load status
21d9 : 48              >            pha
                       >            cmp_flag ~fn
21da : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
21dc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21de : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
21df : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
21e1 : 48              >            pha         ;use stack to load status
21e2 : a97e            >            lda #$7e     ;precharge accu
21e4 : 28              >            plp
                        
21e5 : c11a                     cmp (ind1,x)
                                tst_a $7e,~fzc
21e7 : 08              >            php         ;save flags
21e8 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
21ea : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21ec : 68              >            pla         ;load status
21ed : 48              >            pha
                       >            cmp_flag ~fzc
21ee : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
21f0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21f2 : 28              >            plp         ;restore status
                        
                        
                                set_a $80,0
                       >            load_flag 0
21f3 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
21f5 : 48              >            pha         ;use stack to load status
21f6 : a980            >            lda #$80     ;precharge accu
21f8 : 28              >            plp
                        
21f9 : d11a                     cmp (ind1),y
                                tst_a $80,fc
21fb : 08              >            php         ;save flags
21fc : c980            >            cmp #$80     ;test result
                       >            trap_ne
21fe : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2200 : 68              >            pla         ;load status
2201 : 48              >            pha
                       >            cmp_flag fc
2202 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2204 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2206 : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
2207 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2209 : 48              >            pha         ;use stack to load status
220a : a97f            >            lda #$7f     ;precharge accu
220c : 28              >            plp
                        
220d : d11a                     cmp (ind1),y
                                tst_a $7f,fzc
220f : 08              >            php         ;save flags
2210 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
2212 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2214 : 68              >            pla         ;load status
2215 : 48              >            pha
                       >            cmp_flag fzc
2216 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2218 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
221a : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
221b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
221d : 48              >            pha         ;use stack to load status
221e : a97e            >            lda #$7e     ;precharge accu
2220 : 28              >            plp
                        
2221 : d11a                     cmp (ind1),y
                                tst_a $7e,fn
2223 : 08              >            php         ;save flags
2224 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
2226 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2228 : 68              >            pla         ;load status
2229 : 48              >            pha
                       >            cmp_flag fn
222a : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
222c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
222e : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
222f : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2231 : 48              >            pha         ;use stack to load status
2232 : a980            >            lda #$80     ;precharge accu
2234 : 28              >            plp
                        
2235 : d11a                     cmp (ind1),y
                                tst_a $80,~fnz
2237 : 08              >            php         ;save flags
2238 : c980            >            cmp #$80     ;test result
                       >            trap_ne
223a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
223c : 68              >            pla         ;load status
223d : 48              >            pha
                       >            cmp_flag ~fnz
223e : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2240 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2242 : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
2243 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2245 : 48              >            pha         ;use stack to load status
2246 : a97f            >            lda #$7f     ;precharge accu
2248 : 28              >            plp
                        
2249 : d11a                     cmp (ind1),y
                                tst_a $7f,~fn
224b : 08              >            php         ;save flags
224c : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
224e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2250 : 68              >            pla         ;load status
2251 : 48              >            pha
                       >            cmp_flag ~fn
2252 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2254 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2256 : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
2257 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2259 : 48              >            pha         ;use stack to load status
225a : a97e            >            lda #$7e     ;precharge accu
225c : 28              >            plp
                        
225d : d11a                     cmp (ind1),y
                                tst_a $7e,~fzc
225f : 08              >            php         ;save flags
2260 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
2262 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2264 : 68              >            pla         ;load status
2265 : 48              >            pha
                       >            cmp_flag ~fzc
2266 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2268 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
226a : 28              >            plp         ;restore status
                        
                                next_test
226b : ad0002          >            lda test_case   ;previous test
226e : c91c            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2270 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
001d =                 >test_num = test_num + 1
2272 : a91d            >            lda #test_num   ;*** next tests' number
2274 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing shifts - ASL LSR ROL ROR all addressing modes
                        ; shifts - accumulator
2277 : a203                     ldx #3
2279 :                  tasl
                                set_ax zp1,0
                       >            load_flag 0
2279 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
227b : 48              >            pha         ;use stack to load status
227c : b509            >            lda zp1,x    ;precharge accu
227e : 28              >            plp
                        
227f : 0a                       asl a
                                tst_ax rASL,fASL,0
2280 : 08              >            php         ;save flags
2281 : dd2002          >            cmp rASL,x    ;test result
                       >            trap_ne
2284 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2286 : 68              >            pla         ;load status
                       >            eor_flag 0
2287 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2289 : dd3002          >            cmp fASL,x    ;test flags
                       >            trap_ne     ;
228c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
228e : ca                       dex
228f : 10e8                     bpl tasl
2291 : a203                     ldx #3
2293 :                  tasl1
                                set_ax zp1,$ff
                       >            load_flag $ff
2293 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2295 : 48              >            pha         ;use stack to load status
2296 : b509            >            lda zp1,x    ;precharge accu
2298 : 28              >            plp
                        
2299 : 0a                       asl a
                                tst_ax rASL,fASL,$ff-fnzc
229a : 08              >            php         ;save flags
229b : dd2002          >            cmp rASL,x    ;test result
                       >            trap_ne
229e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
22a0 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
22a1 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
22a3 : dd3002          >            cmp fASL,x    ;test flags
                       >            trap_ne     ;
22a6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
22a8 : ca                       dex
22a9 : 10e8                     bpl tasl1
                        
22ab : a203                     ldx #3
22ad :                  tlsr
                                set_ax zp1,0
                       >            load_flag 0
22ad : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
22af : 48              >            pha         ;use stack to load status
22b0 : b509            >            lda zp1,x    ;precharge accu
22b2 : 28              >            plp
                        
22b3 : 4a                       lsr a
                                tst_ax rLSR,fLSR,0
22b4 : 08              >            php         ;save flags
22b5 : dd2802          >            cmp rLSR,x    ;test result
                       >            trap_ne
22b8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
22ba : 68              >            pla         ;load status
                       >            eor_flag 0
22bb : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
22bd : dd3802          >            cmp fLSR,x    ;test flags
                       >            trap_ne     ;
22c0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
22c2 : ca                       dex
22c3 : 10e8                     bpl tlsr
22c5 : a203                     ldx #3
22c7 :                  tlsr1
                                set_ax zp1,$ff
                       >            load_flag $ff
22c7 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
22c9 : 48              >            pha         ;use stack to load status
22ca : b509            >            lda zp1,x    ;precharge accu
22cc : 28              >            plp
                        
22cd : 4a                       lsr a
                                tst_ax rLSR,fLSR,$ff-fnzc
22ce : 08              >            php         ;save flags
22cf : dd2802          >            cmp rLSR,x    ;test result
                       >            trap_ne
22d2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
22d4 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
22d5 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
22d7 : dd3802          >            cmp fLSR,x    ;test flags
                       >            trap_ne     ;
22da : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
22dc : ca                       dex
22dd : 10e8                     bpl tlsr1
                        
22df : a203                     ldx #3
22e1 :                  trol
                                set_ax zp1,0
                       >            load_flag 0
22e1 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
22e3 : 48              >            pha         ;use stack to load status
22e4 : b509            >            lda zp1,x    ;precharge accu
22e6 : 28              >            plp
                        
22e7 : 2a                       rol a
                                tst_ax rROL,fROL,0
22e8 : 08              >            php         ;save flags
22e9 : dd2002          >            cmp rROL,x    ;test result
                       >            trap_ne
22ec : d0fe            >        bne *           ;failed not equal (non zero)
                       >
22ee : 68              >            pla         ;load status
                       >            eor_flag 0
22ef : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
22f1 : dd3002          >            cmp fROL,x    ;test flags
                       >            trap_ne     ;
22f4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
22f6 : ca                       dex
22f7 : 10e8                     bpl trol
22f9 : a203                     ldx #3
22fb :                  trol1
                                set_ax zp1,$ff-fc
                       >            load_flag $ff-fc
22fb : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
22fd : 48              >            pha         ;use stack to load status
22fe : b509            >            lda zp1,x    ;precharge accu
2300 : 28              >            plp
                        
2301 : 2a                       rol a
                                tst_ax rROL,fROL,$ff-fnzc
2302 : 08              >            php         ;save flags
2303 : dd2002          >            cmp rROL,x    ;test result
                       >            trap_ne
2306 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2308 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2309 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
230b : dd3002          >            cmp fROL,x    ;test flags
                       >            trap_ne     ;
230e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2310 : ca                       dex
2311 : 10e8                     bpl trol1
                        
2313 : a203                     ldx #3
2315 :                  trolc
                                set_ax zp1,fc
                       >            load_flag fc
2315 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
2317 : 48              >            pha         ;use stack to load status
2318 : b509            >            lda zp1,x    ;precharge accu
231a : 28              >            plp
                        
231b : 2a                       rol a
                                tst_ax rROLc,fROLc,0
231c : 08              >            php         ;save flags
231d : dd2402          >            cmp rROLc,x    ;test result
                       >            trap_ne
2320 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2322 : 68              >            pla         ;load status
                       >            eor_flag 0
2323 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2325 : dd3402          >            cmp fROLc,x    ;test flags
                       >            trap_ne     ;
2328 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
232a : ca                       dex
232b : 10e8                     bpl trolc
232d : a203                     ldx #3
232f :                  trolc1
                                set_ax zp1,$ff
                       >            load_flag $ff
232f : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2331 : 48              >            pha         ;use stack to load status
2332 : b509            >            lda zp1,x    ;precharge accu
2334 : 28              >            plp
                        
2335 : 2a                       rol a
                                tst_ax rROLc,fROLc,$ff-fnzc
2336 : 08              >            php         ;save flags
2337 : dd2402          >            cmp rROLc,x    ;test result
                       >            trap_ne
233a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
233c : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
233d : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
233f : dd3402          >            cmp fROLc,x    ;test flags
                       >            trap_ne     ;
2342 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2344 : ca                       dex
2345 : 10e8                     bpl trolc1
                        
2347 : a203                     ldx #3
2349 :                  tror
                                set_ax zp1,0
                       >            load_flag 0
2349 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
234b : 48              >            pha         ;use stack to load status
234c : b509            >            lda zp1,x    ;precharge accu
234e : 28              >            plp
                        
234f : 6a                       ror a
                                tst_ax rROR,fROR,0
2350 : 08              >            php         ;save flags
2351 : dd2802          >            cmp rROR,x    ;test result
                       >            trap_ne
2354 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2356 : 68              >            pla         ;load status
                       >            eor_flag 0
2357 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2359 : dd3802          >            cmp fROR,x    ;test flags
                       >            trap_ne     ;
235c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
235e : ca                       dex
235f : 10e8                     bpl tror
2361 : a203                     ldx #3
2363 :                  tror1
                                set_ax zp1,$ff-fc
                       >            load_flag $ff-fc
2363 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
2365 : 48              >            pha         ;use stack to load status
2366 : b509            >            lda zp1,x    ;precharge accu
2368 : 28              >            plp
                        
2369 : 6a                       ror a
                                tst_ax rROR,fROR,$ff-fnzc
236a : 08              >            php         ;save flags
236b : dd2802          >            cmp rROR,x    ;test result
                       >            trap_ne
236e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2370 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2371 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2373 : dd3802          >            cmp fROR,x    ;test flags
                       >            trap_ne     ;
2376 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2378 : ca                       dex
2379 : 10e8                     bpl tror1
                        
237b : a203                     ldx #3
237d :                  trorc
                                set_ax zp1,fc
                       >            load_flag fc
237d : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
237f : 48              >            pha         ;use stack to load status
2380 : b509            >            lda zp1,x    ;precharge accu
2382 : 28              >            plp
                        
2383 : 6a                       ror a
                                tst_ax rRORc,fRORc,0
2384 : 08              >            php         ;save flags
2385 : dd2c02          >            cmp rRORc,x    ;test result
                       >            trap_ne
2388 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
238a : 68              >            pla         ;load status
                       >            eor_flag 0
238b : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
238d : dd3c02          >            cmp fRORc,x    ;test flags
                       >            trap_ne     ;
2390 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2392 : ca                       dex
2393 : 10e8                     bpl trorc
2395 : a203                     ldx #3
2397 :                  trorc1
                                set_ax zp1,$ff
                       >            load_flag $ff
2397 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2399 : 48              >            pha         ;use stack to load status
239a : b509            >            lda zp1,x    ;precharge accu
239c : 28              >            plp
                        
239d : 6a                       ror a
                                tst_ax rRORc,fRORc,$ff-fnzc
239e : 08              >            php         ;save flags
239f : dd2c02          >            cmp rRORc,x    ;test result
                       >            trap_ne
23a2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
23a4 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
23a5 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
23a7 : dd3c02          >            cmp fRORc,x    ;test flags
                       >            trap_ne     ;
23aa : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
23ac : ca                       dex
23ad : 10e8                     bpl trorc1
                                next_test
23af : ad0002          >            lda test_case   ;previous test
23b2 : c91d            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
23b4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
001e =                 >test_num = test_num + 1
23b6 : a91e            >            lda #test_num   ;*** next tests' number
23b8 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; shifts - zeropage
23bb : a203                     ldx #3
23bd :                  tasl2
                                set_z zp1,0
                       >            load_flag 0
23bd : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
23bf : 48              >            pha         ;use stack to load status
23c0 : b509            >            lda zp1,x    ;load to zeropage
23c2 : 8502            >            sta zpt
23c4 : 28              >            plp
                        
23c5 : 0602                     asl zpt
                                tst_z rASL,fASL,0
23c7 : 08              >            php         ;save flags
23c8 : a502            >            lda zpt
23ca : dd2002          >            cmp rASL,x    ;test result
                       >            trap_ne
23cd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
23cf : 68              >            pla         ;load status
                       >            eor_flag 0
23d0 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
23d2 : dd3002          >            cmp fASL,x    ;test flags
                       >            trap_ne
23d5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
23d7 : ca                       dex
23d8 : 10e3                     bpl tasl2
23da : a203                     ldx #3
23dc :                  tasl3
                                set_z zp1,$ff
                       >            load_flag $ff
23dc : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
23de : 48              >            pha         ;use stack to load status
23df : b509            >            lda zp1,x    ;load to zeropage
23e1 : 8502            >            sta zpt
23e3 : 28              >            plp
                        
23e4 : 0602                     asl zpt
                                tst_z rASL,fASL,$ff-fnzc
23e6 : 08              >            php         ;save flags
23e7 : a502            >            lda zpt
23e9 : dd2002          >            cmp rASL,x    ;test result
                       >            trap_ne
23ec : d0fe            >        bne *           ;failed not equal (non zero)
                       >
23ee : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
23ef : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
23f1 : dd3002          >            cmp fASL,x    ;test flags
                       >            trap_ne
23f4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
23f6 : ca                       dex
23f7 : 10e3                     bpl tasl3
                        
23f9 : a203                     ldx #3
23fb :                  tlsr2
                                set_z zp1,0
                       >            load_flag 0
23fb : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
23fd : 48              >            pha         ;use stack to load status
23fe : b509            >            lda zp1,x    ;load to zeropage
2400 : 8502            >            sta zpt
2402 : 28              >            plp
                        
2403 : 4602                     lsr zpt
                                tst_z rLSR,fLSR,0
2405 : 08              >            php         ;save flags
2406 : a502            >            lda zpt
2408 : dd2802          >            cmp rLSR,x    ;test result
                       >            trap_ne
240b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
240d : 68              >            pla         ;load status
                       >            eor_flag 0
240e : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2410 : dd3802          >            cmp fLSR,x    ;test flags
                       >            trap_ne
2413 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2415 : ca                       dex
2416 : 10e3                     bpl tlsr2
2418 : a203                     ldx #3
241a :                  tlsr3
                                set_z zp1,$ff
                       >            load_flag $ff
241a : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
241c : 48              >            pha         ;use stack to load status
241d : b509            >            lda zp1,x    ;load to zeropage
241f : 8502            >            sta zpt
2421 : 28              >            plp
                        
2422 : 4602                     lsr zpt
                                tst_z rLSR,fLSR,$ff-fnzc
2424 : 08              >            php         ;save flags
2425 : a502            >            lda zpt
2427 : dd2802          >            cmp rLSR,x    ;test result
                       >            trap_ne
242a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
242c : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
242d : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
242f : dd3802          >            cmp fLSR,x    ;test flags
                       >            trap_ne
2432 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2434 : ca                       dex
2435 : 10e3                     bpl tlsr3
                        
2437 : a203                     ldx #3
2439 :                  trol2
                                set_z zp1,0
                       >            load_flag 0
2439 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
243b : 48              >            pha         ;use stack to load status
243c : b509            >            lda zp1,x    ;load to zeropage
243e : 8502            >            sta zpt
2440 : 28              >            plp
                        
2441 : 2602                     rol zpt
                                tst_z rROL,fROL,0
2443 : 08              >            php         ;save flags
2444 : a502            >            lda zpt
2446 : dd2002          >            cmp rROL,x    ;test result
                       >            trap_ne
2449 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
244b : 68              >            pla         ;load status
                       >            eor_flag 0
244c : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
244e : dd3002          >            cmp fROL,x    ;test flags
                       >            trap_ne
2451 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2453 : ca                       dex
2454 : 10e3                     bpl trol2
2456 : a203                     ldx #3
2458 :                  trol3
                                set_z zp1,$ff-fc
                       >            load_flag $ff-fc
2458 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
245a : 48              >            pha         ;use stack to load status
245b : b509            >            lda zp1,x    ;load to zeropage
245d : 8502            >            sta zpt
245f : 28              >            plp
                        
2460 : 2602                     rol zpt
                                tst_z rROL,fROL,$ff-fnzc
2462 : 08              >            php         ;save flags
2463 : a502            >            lda zpt
2465 : dd2002          >            cmp rROL,x    ;test result
                       >            trap_ne
2468 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
246a : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
246b : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
246d : dd3002          >            cmp fROL,x    ;test flags
                       >            trap_ne
2470 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2472 : ca                       dex
2473 : 10e3                     bpl trol3
                        
2475 : a203                     ldx #3
2477 :                  trolc2
                                set_z zp1,fc
                       >            load_flag fc
2477 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
2479 : 48              >            pha         ;use stack to load status
247a : b509            >            lda zp1,x    ;load to zeropage
247c : 8502            >            sta zpt
247e : 28              >            plp
                        
247f : 2602                     rol zpt
                                tst_z rROLc,fROLc,0
2481 : 08              >            php         ;save flags
2482 : a502            >            lda zpt
2484 : dd2402          >            cmp rROLc,x    ;test result
                       >            trap_ne
2487 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2489 : 68              >            pla         ;load status
                       >            eor_flag 0
248a : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
248c : dd3402          >            cmp fROLc,x    ;test flags
                       >            trap_ne
248f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2491 : ca                       dex
2492 : 10e3                     bpl trolc2
2494 : a203                     ldx #3
2496 :                  trolc3
                                set_z zp1,$ff
                       >            load_flag $ff
2496 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2498 : 48              >            pha         ;use stack to load status
2499 : b509            >            lda zp1,x    ;load to zeropage
249b : 8502            >            sta zpt
249d : 28              >            plp
                        
249e : 2602                     rol zpt
                                tst_z rROLc,fROLc,$ff-fnzc
24a0 : 08              >            php         ;save flags
24a1 : a502            >            lda zpt
24a3 : dd2402          >            cmp rROLc,x    ;test result
                       >            trap_ne
24a6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
24a8 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
24a9 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
24ab : dd3402          >            cmp fROLc,x    ;test flags
                       >            trap_ne
24ae : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
24b0 : ca                       dex
24b1 : 10e3                     bpl trolc3
                        
24b3 : a203                     ldx #3
24b5 :                  tror2
                                set_z zp1,0
                       >            load_flag 0
24b5 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
24b7 : 48              >            pha         ;use stack to load status
24b8 : b509            >            lda zp1,x    ;load to zeropage
24ba : 8502            >            sta zpt
24bc : 28              >            plp
                        
24bd : 6602                     ror zpt
                                tst_z rROR,fROR,0
24bf : 08              >            php         ;save flags
24c0 : a502            >            lda zpt
24c2 : dd2802          >            cmp rROR,x    ;test result
                       >            trap_ne
24c5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
24c7 : 68              >            pla         ;load status
                       >            eor_flag 0
24c8 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
24ca : dd3802          >            cmp fROR,x    ;test flags
                       >            trap_ne
24cd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
24cf : ca                       dex
24d0 : 10e3                     bpl tror2
24d2 : a203                     ldx #3
24d4 :                  tror3
                                set_z zp1,$ff-fc
                       >            load_flag $ff-fc
24d4 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
24d6 : 48              >            pha         ;use stack to load status
24d7 : b509            >            lda zp1,x    ;load to zeropage
24d9 : 8502            >            sta zpt
24db : 28              >            plp
                        
24dc : 6602                     ror zpt
                                tst_z rROR,fROR,$ff-fnzc
24de : 08              >            php         ;save flags
24df : a502            >            lda zpt
24e1 : dd2802          >            cmp rROR,x    ;test result
                       >            trap_ne
24e4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
24e6 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
24e7 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
24e9 : dd3802          >            cmp fROR,x    ;test flags
                       >            trap_ne
24ec : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
24ee : ca                       dex
24ef : 10e3                     bpl tror3
                        
24f1 : a203                     ldx #3
24f3 :                  trorc2
                                set_z zp1,fc
                       >            load_flag fc
24f3 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
24f5 : 48              >            pha         ;use stack to load status
24f6 : b509            >            lda zp1,x    ;load to zeropage
24f8 : 8502            >            sta zpt
24fa : 28              >            plp
                        
24fb : 6602                     ror zpt
                                tst_z rRORc,fRORc,0
24fd : 08              >            php         ;save flags
24fe : a502            >            lda zpt
2500 : dd2c02          >            cmp rRORc,x    ;test result
                       >            trap_ne
2503 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2505 : 68              >            pla         ;load status
                       >            eor_flag 0
2506 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2508 : dd3c02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
250b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
250d : ca                       dex
250e : 10e3                     bpl trorc2
2510 : a203                     ldx #3
2512 :                  trorc3
                                set_z zp1,$ff
                       >            load_flag $ff
2512 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2514 : 48              >            pha         ;use stack to load status
2515 : b509            >            lda zp1,x    ;load to zeropage
2517 : 8502            >            sta zpt
2519 : 28              >            plp
                        
251a : 6602                     ror zpt
                                tst_z rRORc,fRORc,$ff-fnzc
251c : 08              >            php         ;save flags
251d : a502            >            lda zpt
251f : dd2c02          >            cmp rRORc,x    ;test result
                       >            trap_ne
2522 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2524 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2525 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2527 : dd3c02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
252a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
252c : ca                       dex
252d : 10e3                     bpl trorc3
                                next_test
252f : ad0002          >            lda test_case   ;previous test
2532 : c91e            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2534 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
001f =                 >test_num = test_num + 1
2536 : a91f            >            lda #test_num   ;*** next tests' number
2538 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; shifts - absolute
253b : a203                     ldx #3
253d :                  tasl4
                                set_abs zp1,0
                       >            load_flag 0
253d : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
253f : 48              >            pha         ;use stack to load status
2540 : b509            >            lda zp1,x    ;load to memory
2542 : 8d0302          >            sta abst
2545 : 28              >            plp
                        
2546 : 0e0302                   asl abst
                                tst_abs rASL,fASL,0
2549 : 08              >            php         ;save flags
254a : ad0302          >            lda abst
254d : dd2002          >            cmp rASL,x    ;test result
                       >            trap_ne
2550 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2552 : 68              >            pla         ;load status
                       >            eor_flag 0
2553 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2555 : dd3002          >            cmp fASL,x    ;test flags
                       >            trap_ne
2558 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
255a : ca                       dex
255b : 10e0                     bpl tasl4
255d : a203                     ldx #3
255f :                  tasl5
                                set_abs zp1,$ff
                       >            load_flag $ff
255f : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2561 : 48              >            pha         ;use stack to load status
2562 : b509            >            lda zp1,x    ;load to memory
2564 : 8d0302          >            sta abst
2567 : 28              >            plp
                        
2568 : 0e0302                   asl abst
                                tst_abs rASL,fASL,$ff-fnzc
256b : 08              >            php         ;save flags
256c : ad0302          >            lda abst
256f : dd2002          >            cmp rASL,x    ;test result
                       >            trap_ne
2572 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2574 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2575 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2577 : dd3002          >            cmp fASL,x    ;test flags
                       >            trap_ne
257a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
257c : ca                       dex
257d : 10e0                     bpl tasl5
                        
257f : a203                     ldx #3
2581 :                  tlsr4
                                set_abs zp1,0
                       >            load_flag 0
2581 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2583 : 48              >            pha         ;use stack to load status
2584 : b509            >            lda zp1,x    ;load to memory
2586 : 8d0302          >            sta abst
2589 : 28              >            plp
                        
258a : 4e0302                   lsr abst
                                tst_abs rLSR,fLSR,0
258d : 08              >            php         ;save flags
258e : ad0302          >            lda abst
2591 : dd2802          >            cmp rLSR,x    ;test result
                       >            trap_ne
2594 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2596 : 68              >            pla         ;load status
                       >            eor_flag 0
2597 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2599 : dd3802          >            cmp fLSR,x    ;test flags
                       >            trap_ne
259c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
259e : ca                       dex
259f : 10e0                     bpl tlsr4
25a1 : a203                     ldx #3
25a3 :                  tlsr5
                                set_abs zp1,$ff
                       >            load_flag $ff
25a3 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
25a5 : 48              >            pha         ;use stack to load status
25a6 : b509            >            lda zp1,x    ;load to memory
25a8 : 8d0302          >            sta abst
25ab : 28              >            plp
                        
25ac : 4e0302                   lsr abst
                                tst_abs rLSR,fLSR,$ff-fnzc
25af : 08              >            php         ;save flags
25b0 : ad0302          >            lda abst
25b3 : dd2802          >            cmp rLSR,x    ;test result
                       >            trap_ne
25b6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
25b8 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
25b9 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
25bb : dd3802          >            cmp fLSR,x    ;test flags
                       >            trap_ne
25be : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
25c0 : ca                       dex
25c1 : 10e0                     bpl tlsr5
                        
25c3 : a203                     ldx #3
25c5 :                  trol4
                                set_abs zp1,0
                       >            load_flag 0
25c5 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
25c7 : 48              >            pha         ;use stack to load status
25c8 : b509            >            lda zp1,x    ;load to memory
25ca : 8d0302          >            sta abst
25cd : 28              >            plp
                        
25ce : 2e0302                   rol abst
                                tst_abs rROL,fROL,0
25d1 : 08              >            php         ;save flags
25d2 : ad0302          >            lda abst
25d5 : dd2002          >            cmp rROL,x    ;test result
                       >            trap_ne
25d8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
25da : 68              >            pla         ;load status
                       >            eor_flag 0
25db : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
25dd : dd3002          >            cmp fROL,x    ;test flags
                       >            trap_ne
25e0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
25e2 : ca                       dex
25e3 : 10e0                     bpl trol4
25e5 : a203                     ldx #3
25e7 :                  trol5
                                set_abs zp1,$ff-fc
                       >            load_flag $ff-fc
25e7 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
25e9 : 48              >            pha         ;use stack to load status
25ea : b509            >            lda zp1,x    ;load to memory
25ec : 8d0302          >            sta abst
25ef : 28              >            plp
                        
25f0 : 2e0302                   rol abst
                                tst_abs rROL,fROL,$ff-fnzc
25f3 : 08              >            php         ;save flags
25f4 : ad0302          >            lda abst
25f7 : dd2002          >            cmp rROL,x    ;test result
                       >            trap_ne
25fa : d0fe            >        bne *           ;failed not equal (non zero)
                       >
25fc : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
25fd : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
25ff : dd3002          >            cmp fROL,x    ;test flags
                       >            trap_ne
2602 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2604 : ca                       dex
2605 : 10e0                     bpl trol5
                        
2607 : a203                     ldx #3
2609 :                  trolc4
                                set_abs zp1,fc
                       >            load_flag fc
2609 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
260b : 48              >            pha         ;use stack to load status
260c : b509            >            lda zp1,x    ;load to memory
260e : 8d0302          >            sta abst
2611 : 28              >            plp
                        
2612 : 2e0302                   rol abst
                                tst_abs rROLc,fROLc,0
2615 : 08              >            php         ;save flags
2616 : ad0302          >            lda abst
2619 : dd2402          >            cmp rROLc,x    ;test result
                       >            trap_ne
261c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
261e : 68              >            pla         ;load status
                       >            eor_flag 0
261f : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2621 : dd3402          >            cmp fROLc,x    ;test flags
                       >            trap_ne
2624 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2626 : ca                       dex
2627 : 10e0                     bpl trolc4
2629 : a203                     ldx #3
262b :                  trolc5
                                set_abs zp1,$ff
                       >            load_flag $ff
262b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
262d : 48              >            pha         ;use stack to load status
262e : b509            >            lda zp1,x    ;load to memory
2630 : 8d0302          >            sta abst
2633 : 28              >            plp
                        
2634 : 2e0302                   rol abst
                                tst_abs rROLc,fROLc,$ff-fnzc
2637 : 08              >            php         ;save flags
2638 : ad0302          >            lda abst
263b : dd2402          >            cmp rROLc,x    ;test result
                       >            trap_ne
263e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2640 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2641 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2643 : dd3402          >            cmp fROLc,x    ;test flags
                       >            trap_ne
2646 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2648 : ca                       dex
2649 : 10e0                     bpl trolc5
                        
264b : a203                     ldx #3
264d :                  tror4
                                set_abs zp1,0
                       >            load_flag 0
264d : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
264f : 48              >            pha         ;use stack to load status
2650 : b509            >            lda zp1,x    ;load to memory
2652 : 8d0302          >            sta abst
2655 : 28              >            plp
                        
2656 : 6e0302                   ror abst
                                tst_abs rROR,fROR,0
2659 : 08              >            php         ;save flags
265a : ad0302          >            lda abst
265d : dd2802          >            cmp rROR,x    ;test result
                       >            trap_ne
2660 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2662 : 68              >            pla         ;load status
                       >            eor_flag 0
2663 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2665 : dd3802          >            cmp fROR,x    ;test flags
                       >            trap_ne
2668 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
266a : ca                       dex
266b : 10e0                     bpl tror4
266d : a203                     ldx #3
266f :                  tror5
                                set_abs zp1,$ff-fc
                       >            load_flag $ff-fc
266f : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
2671 : 48              >            pha         ;use stack to load status
2672 : b509            >            lda zp1,x    ;load to memory
2674 : 8d0302          >            sta abst
2677 : 28              >            plp
                        
2678 : 6e0302                   ror abst
                                tst_abs rROR,fROR,$ff-fnzc
267b : 08              >            php         ;save flags
267c : ad0302          >            lda abst
267f : dd2802          >            cmp rROR,x    ;test result
                       >            trap_ne
2682 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2684 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2685 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2687 : dd3802          >            cmp fROR,x    ;test flags
                       >            trap_ne
268a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
268c : ca                       dex
268d : 10e0                     bpl tror5
                        
268f : a203                     ldx #3
2691 :                  trorc4
                                set_abs zp1,fc
                       >            load_flag fc
2691 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
2693 : 48              >            pha         ;use stack to load status
2694 : b509            >            lda zp1,x    ;load to memory
2696 : 8d0302          >            sta abst
2699 : 28              >            plp
                        
269a : 6e0302                   ror abst
                                tst_abs rRORc,fRORc,0
269d : 08              >            php         ;save flags
269e : ad0302          >            lda abst
26a1 : dd2c02          >            cmp rRORc,x    ;test result
                       >            trap_ne
26a4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
26a6 : 68              >            pla         ;load status
                       >            eor_flag 0
26a7 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
26a9 : dd3c02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
26ac : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
26ae : ca                       dex
26af : 10e0                     bpl trorc4
26b1 : a203                     ldx #3
26b3 :                  trorc5
                                set_abs zp1,$ff
                       >            load_flag $ff
26b3 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
26b5 : 48              >            pha         ;use stack to load status
26b6 : b509            >            lda zp1,x    ;load to memory
26b8 : 8d0302          >            sta abst
26bb : 28              >            plp
                        
26bc : 6e0302                   ror abst
                                tst_abs rRORc,fRORc,$ff-fnzc
26bf : 08              >            php         ;save flags
26c0 : ad0302          >            lda abst
26c3 : dd2c02          >            cmp rRORc,x    ;test result
                       >            trap_ne
26c6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
26c8 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
26c9 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
26cb : dd3c02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
26ce : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
26d0 : ca                       dex
26d1 : 10e0                     bpl trorc5
                                next_test
26d3 : ad0002          >            lda test_case   ;previous test
26d6 : c91f            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
26d8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0020 =                 >test_num = test_num + 1
26da : a920            >            lda #test_num   ;*** next tests' number
26dc : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; shifts - zp indexed
26df : a203                     ldx #3
26e1 :                  tasl6
                                set_zx zp1,0
                       >            load_flag 0
26e1 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
26e3 : 48              >            pha         ;use stack to load status
26e4 : b509            >            lda zp1,x    ;load to indexed zeropage
26e6 : 9502            >            sta zpt,x
26e8 : 28              >            plp
                        
26e9 : 1602                     asl zpt,x
                                tst_zx rASL,fASL,0
26eb : 08              >            php         ;save flags
26ec : b502            >            lda zpt,x
26ee : dd2002          >            cmp rASL,x    ;test result
                       >            trap_ne
26f1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
26f3 : 68              >            pla         ;load status
                       >            eor_flag 0
26f4 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
26f6 : dd3002          >            cmp fASL,x    ;test flags
                       >            trap_ne
26f9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
26fb : ca                       dex
26fc : 10e3                     bpl tasl6
26fe : a203                     ldx #3
2700 :                  tasl7
                                set_zx zp1,$ff
                       >            load_flag $ff
2700 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2702 : 48              >            pha         ;use stack to load status
2703 : b509            >            lda zp1,x    ;load to indexed zeropage
2705 : 9502            >            sta zpt,x
2707 : 28              >            plp
                        
2708 : 1602                     asl zpt,x
                                tst_zx rASL,fASL,$ff-fnzc
270a : 08              >            php         ;save flags
270b : b502            >            lda zpt,x
270d : dd2002          >            cmp rASL,x    ;test result
                       >            trap_ne
2710 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2712 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2713 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2715 : dd3002          >            cmp fASL,x    ;test flags
                       >            trap_ne
2718 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
271a : ca                       dex
271b : 10e3                     bpl tasl7
                        
271d : a203                     ldx #3
271f :                  tlsr6
                                set_zx zp1,0
                       >            load_flag 0
271f : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2721 : 48              >            pha         ;use stack to load status
2722 : b509            >            lda zp1,x    ;load to indexed zeropage
2724 : 9502            >            sta zpt,x
2726 : 28              >            plp
                        
2727 : 5602                     lsr zpt,x
                                tst_zx rLSR,fLSR,0
2729 : 08              >            php         ;save flags
272a : b502            >            lda zpt,x
272c : dd2802          >            cmp rLSR,x    ;test result
                       >            trap_ne
272f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2731 : 68              >            pla         ;load status
                       >            eor_flag 0
2732 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2734 : dd3802          >            cmp fLSR,x    ;test flags
                       >            trap_ne
2737 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2739 : ca                       dex
273a : 10e3                     bpl tlsr6
273c : a203                     ldx #3
273e :                  tlsr7
                                set_zx zp1,$ff
                       >            load_flag $ff
273e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2740 : 48              >            pha         ;use stack to load status
2741 : b509            >            lda zp1,x    ;load to indexed zeropage
2743 : 9502            >            sta zpt,x
2745 : 28              >            plp
                        
2746 : 5602                     lsr zpt,x
                                tst_zx rLSR,fLSR,$ff-fnzc
2748 : 08              >            php         ;save flags
2749 : b502            >            lda zpt,x
274b : dd2802          >            cmp rLSR,x    ;test result
                       >            trap_ne
274e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2750 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2751 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2753 : dd3802          >            cmp fLSR,x    ;test flags
                       >            trap_ne
2756 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2758 : ca                       dex
2759 : 10e3                     bpl tlsr7
                        
275b : a203                     ldx #3
275d :                  trol6
                                set_zx zp1,0
                       >            load_flag 0
275d : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
275f : 48              >            pha         ;use stack to load status
2760 : b509            >            lda zp1,x    ;load to indexed zeropage
2762 : 9502            >            sta zpt,x
2764 : 28              >            plp
                        
2765 : 3602                     rol zpt,x
                                tst_zx rROL,fROL,0
2767 : 08              >            php         ;save flags
2768 : b502            >            lda zpt,x
276a : dd2002          >            cmp rROL,x    ;test result
                       >            trap_ne
276d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
276f : 68              >            pla         ;load status
                       >            eor_flag 0
2770 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2772 : dd3002          >            cmp fROL,x    ;test flags
                       >            trap_ne
2775 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2777 : ca                       dex
2778 : 10e3                     bpl trol6
277a : a203                     ldx #3
277c :                  trol7
                                set_zx zp1,$ff-fc
                       >            load_flag $ff-fc
277c : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
277e : 48              >            pha         ;use stack to load status
277f : b509            >            lda zp1,x    ;load to indexed zeropage
2781 : 9502            >            sta zpt,x
2783 : 28              >            plp
                        
2784 : 3602                     rol zpt,x
                                tst_zx rROL,fROL,$ff-fnzc
2786 : 08              >            php         ;save flags
2787 : b502            >            lda zpt,x
2789 : dd2002          >            cmp rROL,x    ;test result
                       >            trap_ne
278c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
278e : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
278f : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2791 : dd3002          >            cmp fROL,x    ;test flags
                       >            trap_ne
2794 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2796 : ca                       dex
2797 : 10e3                     bpl trol7
                        
2799 : a203                     ldx #3
279b :                  trolc6
                                set_zx zp1,fc
                       >            load_flag fc
279b : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
279d : 48              >            pha         ;use stack to load status
279e : b509            >            lda zp1,x    ;load to indexed zeropage
27a0 : 9502            >            sta zpt,x
27a2 : 28              >            plp
                        
27a3 : 3602                     rol zpt,x
                                tst_zx rROLc,fROLc,0
27a5 : 08              >            php         ;save flags
27a6 : b502            >            lda zpt,x
27a8 : dd2402          >            cmp rROLc,x    ;test result
                       >            trap_ne
27ab : d0fe            >        bne *           ;failed not equal (non zero)
                       >
27ad : 68              >            pla         ;load status
                       >            eor_flag 0
27ae : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
27b0 : dd3402          >            cmp fROLc,x    ;test flags
                       >            trap_ne
27b3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
27b5 : ca                       dex
27b6 : 10e3                     bpl trolc6
27b8 : a203                     ldx #3
27ba :                  trolc7
                                set_zx zp1,$ff
                       >            load_flag $ff
27ba : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
27bc : 48              >            pha         ;use stack to load status
27bd : b509            >            lda zp1,x    ;load to indexed zeropage
27bf : 9502            >            sta zpt,x
27c1 : 28              >            plp
                        
27c2 : 3602                     rol zpt,x
                                tst_zx rROLc,fROLc,$ff-fnzc
27c4 : 08              >            php         ;save flags
27c5 : b502            >            lda zpt,x
27c7 : dd2402          >            cmp rROLc,x    ;test result
                       >            trap_ne
27ca : d0fe            >        bne *           ;failed not equal (non zero)
                       >
27cc : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
27cd : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
27cf : dd3402          >            cmp fROLc,x    ;test flags
                       >            trap_ne
27d2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
27d4 : ca                       dex
27d5 : 10e3                     bpl trolc7
                        
27d7 : a203                     ldx #3
27d9 :                  tror6
                                set_zx zp1,0
                       >            load_flag 0
27d9 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
27db : 48              >            pha         ;use stack to load status
27dc : b509            >            lda zp1,x    ;load to indexed zeropage
27de : 9502            >            sta zpt,x
27e0 : 28              >            plp
                        
27e1 : 7602                     ror zpt,x
                                tst_zx rROR,fROR,0
27e3 : 08              >            php         ;save flags
27e4 : b502            >            lda zpt,x
27e6 : dd2802          >            cmp rROR,x    ;test result
                       >            trap_ne
27e9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
27eb : 68              >            pla         ;load status
                       >            eor_flag 0
27ec : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
27ee : dd3802          >            cmp fROR,x    ;test flags
                       >            trap_ne
27f1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
27f3 : ca                       dex
27f4 : 10e3                     bpl tror6
27f6 : a203                     ldx #3
27f8 :                  tror7
                                set_zx zp1,$ff-fc
                       >            load_flag $ff-fc
27f8 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
27fa : 48              >            pha         ;use stack to load status
27fb : b509            >            lda zp1,x    ;load to indexed zeropage
27fd : 9502            >            sta zpt,x
27ff : 28              >            plp
                        
2800 : 7602                     ror zpt,x
                                tst_zx rROR,fROR,$ff-fnzc
2802 : 08              >            php         ;save flags
2803 : b502            >            lda zpt,x
2805 : dd2802          >            cmp rROR,x    ;test result
                       >            trap_ne
2808 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
280a : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
280b : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
280d : dd3802          >            cmp fROR,x    ;test flags
                       >            trap_ne
2810 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2812 : ca                       dex
2813 : 10e3                     bpl tror7
                        
2815 : a203                     ldx #3
2817 :                  trorc6
                                set_zx zp1,fc
                       >            load_flag fc
2817 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
2819 : 48              >            pha         ;use stack to load status
281a : b509            >            lda zp1,x    ;load to indexed zeropage
281c : 9502            >            sta zpt,x
281e : 28              >            plp
                        
281f : 7602                     ror zpt,x
                                tst_zx rRORc,fRORc,0
2821 : 08              >            php         ;save flags
2822 : b502            >            lda zpt,x
2824 : dd2c02          >            cmp rRORc,x    ;test result
                       >            trap_ne
2827 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2829 : 68              >            pla         ;load status
                       >            eor_flag 0
282a : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
282c : dd3c02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
282f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2831 : ca                       dex
2832 : 10e3                     bpl trorc6
2834 : a203                     ldx #3
2836 :                  trorc7
                                set_zx zp1,$ff
                       >            load_flag $ff
2836 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2838 : 48              >            pha         ;use stack to load status
2839 : b509            >            lda zp1,x    ;load to indexed zeropage
283b : 9502            >            sta zpt,x
283d : 28              >            plp
                        
283e : 7602                     ror zpt,x
                                tst_zx rRORc,fRORc,$ff-fnzc
2840 : 08              >            php         ;save flags
2841 : b502            >            lda zpt,x
2843 : dd2c02          >            cmp rRORc,x    ;test result
                       >            trap_ne
2846 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2848 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2849 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
284b : dd3c02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
284e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2850 : ca                       dex
2851 : 10e3                     bpl trorc7
                                next_test
2853 : ad0002          >            lda test_case   ;previous test
2856 : c920            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2858 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0021 =                 >test_num = test_num + 1
285a : a921            >            lda #test_num   ;*** next tests' number
285c : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; shifts - abs indexed
285f : a203                     ldx #3
2861 :                  tasl8
                                set_absx zp1,0
                       >            load_flag 0
2861 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2863 : 48              >            pha         ;use stack to load status
2864 : b509            >            lda zp1,x    ;load to indexed memory
2866 : 9d0302          >            sta abst,x
2869 : 28              >            plp
                        
286a : 1e0302                   asl abst,x
                                tst_absx rASL,fASL,0
286d : 08              >            php         ;save flags
286e : bd0302          >            lda abst,x
2871 : dd2002          >            cmp rASL,x    ;test result
                       >            trap_ne
2874 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2876 : 68              >            pla         ;load status
                       >            eor_flag 0
2877 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2879 : dd3002          >            cmp fASL,x    ;test flags
                       >            trap_ne
287c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
287e : ca                       dex
287f : 10e0                     bpl tasl8
2881 : a203                     ldx #3
2883 :                  tasl9
                                set_absx zp1,$ff
                       >            load_flag $ff
2883 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2885 : 48              >            pha         ;use stack to load status
2886 : b509            >            lda zp1,x    ;load to indexed memory
2888 : 9d0302          >            sta abst,x
288b : 28              >            plp
                        
288c : 1e0302                   asl abst,x
                                tst_absx rASL,fASL,$ff-fnzc
288f : 08              >            php         ;save flags
2890 : bd0302          >            lda abst,x
2893 : dd2002          >            cmp rASL,x    ;test result
                       >            trap_ne
2896 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2898 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2899 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
289b : dd3002          >            cmp fASL,x    ;test flags
                       >            trap_ne
289e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
28a0 : ca                       dex
28a1 : 10e0                     bpl tasl9
                        
28a3 : a203                     ldx #3
28a5 :                  tlsr8
                                set_absx zp1,0
                       >            load_flag 0
28a5 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
28a7 : 48              >            pha         ;use stack to load status
28a8 : b509            >            lda zp1,x    ;load to indexed memory
28aa : 9d0302          >            sta abst,x
28ad : 28              >            plp
                        
28ae : 5e0302                   lsr abst,x
                                tst_absx rLSR,fLSR,0
28b1 : 08              >            php         ;save flags
28b2 : bd0302          >            lda abst,x
28b5 : dd2802          >            cmp rLSR,x    ;test result
                       >            trap_ne
28b8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
28ba : 68              >            pla         ;load status
                       >            eor_flag 0
28bb : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
28bd : dd3802          >            cmp fLSR,x    ;test flags
                       >            trap_ne
28c0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
28c2 : ca                       dex
28c3 : 10e0                     bpl tlsr8
28c5 : a203                     ldx #3
28c7 :                  tlsr9
                                set_absx zp1,$ff
                       >            load_flag $ff
28c7 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
28c9 : 48              >            pha         ;use stack to load status
28ca : b509            >            lda zp1,x    ;load to indexed memory
28cc : 9d0302          >            sta abst,x
28cf : 28              >            plp
                        
28d0 : 5e0302                   lsr abst,x
                                tst_absx rLSR,fLSR,$ff-fnzc
28d3 : 08              >            php         ;save flags
28d4 : bd0302          >            lda abst,x
28d7 : dd2802          >            cmp rLSR,x    ;test result
                       >            trap_ne
28da : d0fe            >        bne *           ;failed not equal (non zero)
                       >
28dc : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
28dd : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
28df : dd3802          >            cmp fLSR,x    ;test flags
                       >            trap_ne
28e2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
28e4 : ca                       dex
28e5 : 10e0                     bpl tlsr9
                        
28e7 : a203                     ldx #3
28e9 :                  trol8
                                set_absx zp1,0
                       >            load_flag 0
28e9 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
28eb : 48              >            pha         ;use stack to load status
28ec : b509            >            lda zp1,x    ;load to indexed memory
28ee : 9d0302          >            sta abst,x
28f1 : 28              >            plp
                        
28f2 : 3e0302                   rol abst,x
                                tst_absx rROL,fROL,0
28f5 : 08              >            php         ;save flags
28f6 : bd0302          >            lda abst,x
28f9 : dd2002          >            cmp rROL,x    ;test result
                       >            trap_ne
28fc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
28fe : 68              >            pla         ;load status
                       >            eor_flag 0
28ff : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2901 : dd3002          >            cmp fROL,x    ;test flags
                       >            trap_ne
2904 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2906 : ca                       dex
2907 : 10e0                     bpl trol8
2909 : a203                     ldx #3
290b :                  trol9
                                set_absx zp1,$ff-fc
                       >            load_flag $ff-fc
290b : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
290d : 48              >            pha         ;use stack to load status
290e : b509            >            lda zp1,x    ;load to indexed memory
2910 : 9d0302          >            sta abst,x
2913 : 28              >            plp
                        
2914 : 3e0302                   rol abst,x
                                tst_absx rROL,fROL,$ff-fnzc
2917 : 08              >            php         ;save flags
2918 : bd0302          >            lda abst,x
291b : dd2002          >            cmp rROL,x    ;test result
                       >            trap_ne
291e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2920 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2921 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2923 : dd3002          >            cmp fROL,x    ;test flags
                       >            trap_ne
2926 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2928 : ca                       dex
2929 : 10e0                     bpl trol9
                        
292b : a203                     ldx #3
292d :                  trolc8
                                set_absx zp1,fc
                       >            load_flag fc
292d : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
292f : 48              >            pha         ;use stack to load status
2930 : b509            >            lda zp1,x    ;load to indexed memory
2932 : 9d0302          >            sta abst,x
2935 : 28              >            plp
                        
2936 : 3e0302                   rol abst,x
                                tst_absx rROLc,fROLc,0
2939 : 08              >            php         ;save flags
293a : bd0302          >            lda abst,x
293d : dd2402          >            cmp rROLc,x    ;test result
                       >            trap_ne
2940 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2942 : 68              >            pla         ;load status
                       >            eor_flag 0
2943 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2945 : dd3402          >            cmp fROLc,x    ;test flags
                       >            trap_ne
2948 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
294a : ca                       dex
294b : 10e0                     bpl trolc8
294d : a203                     ldx #3
294f :                  trolc9
                                set_absx zp1,$ff
                       >            load_flag $ff
294f : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2951 : 48              >            pha         ;use stack to load status
2952 : b509            >            lda zp1,x    ;load to indexed memory
2954 : 9d0302          >            sta abst,x
2957 : 28              >            plp
                        
2958 : 3e0302                   rol abst,x
                                tst_absx rROLc,fROLc,$ff-fnzc
295b : 08              >            php         ;save flags
295c : bd0302          >            lda abst,x
295f : dd2402          >            cmp rROLc,x    ;test result
                       >            trap_ne
2962 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2964 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2965 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2967 : dd3402          >            cmp fROLc,x    ;test flags
                       >            trap_ne
296a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
296c : ca                       dex
296d : 10e0                     bpl trolc9
                        
296f : a203                     ldx #3
2971 :                  tror8
                                set_absx zp1,0
                       >            load_flag 0
2971 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2973 : 48              >            pha         ;use stack to load status
2974 : b509            >            lda zp1,x    ;load to indexed memory
2976 : 9d0302          >            sta abst,x
2979 : 28              >            plp
                        
297a : 7e0302                   ror abst,x
                                tst_absx rROR,fROR,0
297d : 08              >            php         ;save flags
297e : bd0302          >            lda abst,x
2981 : dd2802          >            cmp rROR,x    ;test result
                       >            trap_ne
2984 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2986 : 68              >            pla         ;load status
                       >            eor_flag 0
2987 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2989 : dd3802          >            cmp fROR,x    ;test flags
                       >            trap_ne
298c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
298e : ca                       dex
298f : 10e0                     bpl tror8
2991 : a203                     ldx #3
2993 :                  tror9
                                set_absx zp1,$ff-fc
                       >            load_flag $ff-fc
2993 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
2995 : 48              >            pha         ;use stack to load status
2996 : b509            >            lda zp1,x    ;load to indexed memory
2998 : 9d0302          >            sta abst,x
299b : 28              >            plp
                        
299c : 7e0302                   ror abst,x
                                tst_absx rROR,fROR,$ff-fnzc
299f : 08              >            php         ;save flags
29a0 : bd0302          >            lda abst,x
29a3 : dd2802          >            cmp rROR,x    ;test result
                       >            trap_ne
29a6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
29a8 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
29a9 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
29ab : dd3802          >            cmp fROR,x    ;test flags
                       >            trap_ne
29ae : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
29b0 : ca                       dex
29b1 : 10e0                     bpl tror9
                        
29b3 : a203                     ldx #3
29b5 :                  trorc8
                                set_absx zp1,fc
                       >            load_flag fc
29b5 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
29b7 : 48              >            pha         ;use stack to load status
29b8 : b509            >            lda zp1,x    ;load to indexed memory
29ba : 9d0302          >            sta abst,x
29bd : 28              >            plp
                        
29be : 7e0302                   ror abst,x
                                tst_absx rRORc,fRORc,0
29c1 : 08              >            php         ;save flags
29c2 : bd0302          >            lda abst,x
29c5 : dd2c02          >            cmp rRORc,x    ;test result
                       >            trap_ne
29c8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
29ca : 68              >            pla         ;load status
                       >            eor_flag 0
29cb : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
29cd : dd3c02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
29d0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
29d2 : ca                       dex
29d3 : 10e0                     bpl trorc8
29d5 : a203                     ldx #3
29d7 :                  trorc9
                                set_absx zp1,$ff
                       >            load_flag $ff
29d7 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
29d9 : 48              >            pha         ;use stack to load status
29da : b509            >            lda zp1,x    ;load to indexed memory
29dc : 9d0302          >            sta abst,x
29df : 28              >            plp
                        
29e0 : 7e0302                   ror abst,x
                                tst_absx rRORc,fRORc,$ff-fnzc
29e3 : 08              >            php         ;save flags
29e4 : bd0302          >            lda abst,x
29e7 : dd2c02          >            cmp rRORc,x    ;test result
                       >            trap_ne
29ea : d0fe            >        bne *           ;failed not equal (non zero)
                       >
29ec : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
29ed : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
29ef : dd3c02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
29f2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
29f4 : ca                       dex
29f5 : 10e0                     bpl trorc9
                                next_test
29f7 : ad0002          >            lda test_case   ;previous test
29fa : c921            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
29fc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0022 =                 >test_num = test_num + 1
29fe : a922            >            lda #test_num   ;*** next tests' number
2a00 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing memory increment/decrement - INC DEC all addressing modes
                        ; zeropage
2a03 : a200                     ldx #0
2a05 : a97e                     lda #$7e
2a07 : 8502                     sta zpt
2a09 :                  tinc    
                                set_stat 0
                       >            load_flag 0
2a09 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2a0b : 48              >            pha         ;use stack to load status
2a0c : 28              >            plp
                        
2a0d : e602                     inc zpt
                                tst_z rINC,fINC,0
2a0f : 08              >            php         ;save flags
2a10 : a502            >            lda zpt
2a12 : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2a15 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2a17 : 68              >            pla         ;load status
                       >            eor_flag 0
2a18 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2a1a : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2a1d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2a1f : e8                       inx
2a20 : e002                     cpx #2
2a22 : d004                     bne tinc1
2a24 : a9fe                     lda #$fe
2a26 : 8502                     sta zpt
2a28 : e005             tinc1   cpx #5
2a2a : d0dd                     bne tinc
2a2c : ca                       dex
2a2d : e602                     inc zpt
2a2f :                  tdec    
                                set_stat 0
                       >            load_flag 0
2a2f : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2a31 : 48              >            pha         ;use stack to load status
2a32 : 28              >            plp
                        
2a33 : c602                     dec zpt
                                tst_z rINC,fINC,0
2a35 : 08              >            php         ;save flags
2a36 : a502            >            lda zpt
2a38 : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2a3b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2a3d : 68              >            pla         ;load status
                       >            eor_flag 0
2a3e : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2a40 : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2a43 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2a45 : ca                       dex
2a46 : 300a                     bmi tdec1
2a48 : e001                     cpx #1
2a4a : d0e3                     bne tdec
2a4c : a981                     lda #$81
2a4e : 8502                     sta zpt
2a50 : d0dd                     bne tdec
2a52 :                  tdec1
2a52 : a200                     ldx #0
2a54 : a97e                     lda #$7e
2a56 : 8502                     sta zpt
2a58 :                  tinc10    
                                set_stat $ff
                       >            load_flag $ff
2a58 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2a5a : 48              >            pha         ;use stack to load status
2a5b : 28              >            plp
                        
2a5c : e602                     inc zpt
                                tst_z rINC,fINC,$ff-fnz
2a5e : 08              >            php         ;save flags
2a5f : a502            >            lda zpt
2a61 : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2a64 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2a66 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2a67 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2a69 : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2a6c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2a6e : e8                       inx
2a6f : e002                     cpx #2
2a71 : d004                     bne tinc11
2a73 : a9fe                     lda #$fe
2a75 : 8502                     sta zpt
2a77 : e005             tinc11  cpx #5
2a79 : d0dd                     bne tinc10
2a7b : ca                       dex
2a7c : e602                     inc zpt
2a7e :                  tdec10    
                                set_stat $ff
                       >            load_flag $ff
2a7e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2a80 : 48              >            pha         ;use stack to load status
2a81 : 28              >            plp
                        
2a82 : c602                     dec zpt
                                tst_z rINC,fINC,$ff-fnz
2a84 : 08              >            php         ;save flags
2a85 : a502            >            lda zpt
2a87 : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2a8a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2a8c : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2a8d : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2a8f : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2a92 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2a94 : ca                       dex
2a95 : 300a                     bmi tdec11
2a97 : e001                     cpx #1
2a99 : d0e3                     bne tdec10
2a9b : a981                     lda #$81
2a9d : 8502                     sta zpt
2a9f : d0dd                     bne tdec10
2aa1 :                  tdec11
                                next_test
2aa1 : ad0002          >            lda test_case   ;previous test
2aa4 : c922            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2aa6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0023 =                 >test_num = test_num + 1
2aa8 : a923            >            lda #test_num   ;*** next tests' number
2aaa : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; absolute memory
2aad : a200                     ldx #0
2aaf : a97e                     lda #$7e
2ab1 : 8d0302                   sta abst
2ab4 :                  tinc2    
                                set_stat 0
                       >            load_flag 0
2ab4 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2ab6 : 48              >            pha         ;use stack to load status
2ab7 : 28              >            plp
                        
2ab8 : ee0302                   inc abst
                                tst_abs rINC,fINC,0
2abb : 08              >            php         ;save flags
2abc : ad0302          >            lda abst
2abf : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2ac2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2ac4 : 68              >            pla         ;load status
                       >            eor_flag 0
2ac5 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2ac7 : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2aca : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2acc : e8                       inx
2acd : e002                     cpx #2
2acf : d005                     bne tinc3
2ad1 : a9fe                     lda #$fe
2ad3 : 8d0302                   sta abst
2ad6 : e005             tinc3   cpx #5
2ad8 : d0da                     bne tinc2
2ada : ca                       dex
2adb : ee0302                   inc abst
2ade :                  tdec2    
                                set_stat 0
                       >            load_flag 0
2ade : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2ae0 : 48              >            pha         ;use stack to load status
2ae1 : 28              >            plp
                        
2ae2 : ce0302                   dec abst
                                tst_abs rINC,fINC,0
2ae5 : 08              >            php         ;save flags
2ae6 : ad0302          >            lda abst
2ae9 : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2aec : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2aee : 68              >            pla         ;load status
                       >            eor_flag 0
2aef : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2af1 : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2af4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2af6 : ca                       dex
2af7 : 300b                     bmi tdec3
2af9 : e001                     cpx #1
2afb : d0e1                     bne tdec2
2afd : a981                     lda #$81
2aff : 8d0302                   sta abst
2b02 : d0da                     bne tdec2
2b04 :                  tdec3
2b04 : a200                     ldx #0
2b06 : a97e                     lda #$7e
2b08 : 8d0302                   sta abst
2b0b :                  tinc12    
                                set_stat $ff
                       >            load_flag $ff
2b0b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2b0d : 48              >            pha         ;use stack to load status
2b0e : 28              >            plp
                        
2b0f : ee0302                   inc abst
                                tst_abs rINC,fINC,$ff-fnz
2b12 : 08              >            php         ;save flags
2b13 : ad0302          >            lda abst
2b16 : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2b19 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2b1b : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2b1c : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2b1e : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2b21 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2b23 : e8                       inx
2b24 : e002                     cpx #2
2b26 : d005                     bne tinc13
2b28 : a9fe                     lda #$fe
2b2a : 8d0302                   sta abst
2b2d : e005             tinc13   cpx #5
2b2f : d0da                     bne tinc12
2b31 : ca                       dex
2b32 : ee0302                   inc abst
2b35 :                  tdec12    
                                set_stat $ff
                       >            load_flag $ff
2b35 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2b37 : 48              >            pha         ;use stack to load status
2b38 : 28              >            plp
                        
2b39 : ce0302                   dec abst
                                tst_abs rINC,fINC,$ff-fnz
2b3c : 08              >            php         ;save flags
2b3d : ad0302          >            lda abst
2b40 : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2b43 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2b45 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2b46 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2b48 : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2b4b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2b4d : ca                       dex
2b4e : 300b                     bmi tdec13
2b50 : e001                     cpx #1
2b52 : d0e1                     bne tdec12
2b54 : a981                     lda #$81
2b56 : 8d0302                   sta abst
2b59 : d0da                     bne tdec12
2b5b :                  tdec13
                                next_test
2b5b : ad0002          >            lda test_case   ;previous test
2b5e : c923            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2b60 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0024 =                 >test_num = test_num + 1
2b62 : a924            >            lda #test_num   ;*** next tests' number
2b64 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; zeropage indexed
2b67 : a200                     ldx #0
2b69 : a97e                     lda #$7e
2b6b : 9502             tinc4   sta zpt,x
                                set_stat 0
                       >            load_flag 0
2b6d : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2b6f : 48              >            pha         ;use stack to load status
2b70 : 28              >            plp
                        
2b71 : f602                     inc zpt,x
                                tst_zx rINC,fINC,0
2b73 : 08              >            php         ;save flags
2b74 : b502            >            lda zpt,x
2b76 : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2b79 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2b7b : 68              >            pla         ;load status
                       >            eor_flag 0
2b7c : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2b7e : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2b81 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2b83 : b502                     lda zpt,x
2b85 : e8                       inx
2b86 : e002                     cpx #2
2b88 : d002                     bne tinc5
2b8a : a9fe                     lda #$fe
2b8c : e005             tinc5   cpx #5
2b8e : d0db                     bne tinc4
2b90 : ca                       dex
2b91 : a902                     lda #2
2b93 : 9502             tdec4   sta zpt,x 
                                set_stat 0
                       >            load_flag 0
2b95 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2b97 : 48              >            pha         ;use stack to load status
2b98 : 28              >            plp
                        
2b99 : d602                     dec zpt,x
                                tst_zx rINC,fINC,0
2b9b : 08              >            php         ;save flags
2b9c : b502            >            lda zpt,x
2b9e : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2ba1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2ba3 : 68              >            pla         ;load status
                       >            eor_flag 0
2ba4 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2ba6 : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2ba9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2bab : b502                     lda zpt,x
2bad : ca                       dex
2bae : 3008                     bmi tdec5
2bb0 : e001                     cpx #1
2bb2 : d0df                     bne tdec4
2bb4 : a981                     lda #$81
2bb6 : d0db                     bne tdec4
2bb8 :                  tdec5
2bb8 : a200                     ldx #0
2bba : a97e                     lda #$7e
2bbc : 9502             tinc14  sta zpt,x
                                set_stat $ff
                       >            load_flag $ff
2bbe : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2bc0 : 48              >            pha         ;use stack to load status
2bc1 : 28              >            plp
                        
2bc2 : f602                     inc zpt,x
                                tst_zx rINC,fINC,$ff-fnz
2bc4 : 08              >            php         ;save flags
2bc5 : b502            >            lda zpt,x
2bc7 : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2bca : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2bcc : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2bcd : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2bcf : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2bd2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2bd4 : b502                     lda zpt,x
2bd6 : e8                       inx
2bd7 : e002                     cpx #2
2bd9 : d002                     bne tinc15
2bdb : a9fe                     lda #$fe
2bdd : e005             tinc15  cpx #5
2bdf : d0db                     bne tinc14
2be1 : ca                       dex
2be2 : a902                     lda #2
2be4 : 9502             tdec14  sta zpt,x 
                                set_stat $ff
                       >            load_flag $ff
2be6 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2be8 : 48              >            pha         ;use stack to load status
2be9 : 28              >            plp
                        
2bea : d602                     dec zpt,x
                                tst_zx rINC,fINC,$ff-fnz
2bec : 08              >            php         ;save flags
2bed : b502            >            lda zpt,x
2bef : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2bf2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2bf4 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2bf5 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2bf7 : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2bfa : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2bfc : b502                     lda zpt,x
2bfe : ca                       dex
2bff : 3008                     bmi tdec15
2c01 : e001                     cpx #1
2c03 : d0df                     bne tdec14
2c05 : a981                     lda #$81
2c07 : d0db                     bne tdec14
2c09 :                  tdec15
                                next_test
2c09 : ad0002          >            lda test_case   ;previous test
2c0c : c924            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2c0e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0025 =                 >test_num = test_num + 1
2c10 : a925            >            lda #test_num   ;*** next tests' number
2c12 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; memory indexed
2c15 : a200                     ldx #0
2c17 : a97e                     lda #$7e
2c19 : 9d0302           tinc6   sta abst,x
                                set_stat 0
                       >            load_flag 0
2c1c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2c1e : 48              >            pha         ;use stack to load status
2c1f : 28              >            plp
                        
2c20 : fe0302                   inc abst,x
                                tst_absx rINC,fINC,0
2c23 : 08              >            php         ;save flags
2c24 : bd0302          >            lda abst,x
2c27 : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2c2a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2c2c : 68              >            pla         ;load status
                       >            eor_flag 0
2c2d : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2c2f : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2c32 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2c34 : bd0302                   lda abst,x
2c37 : e8                       inx
2c38 : e002                     cpx #2
2c3a : d002                     bne tinc7
2c3c : a9fe                     lda #$fe
2c3e : e005             tinc7   cpx #5
2c40 : d0d7                     bne tinc6
2c42 : ca                       dex
2c43 : a902                     lda #2
2c45 : 9d0302           tdec6   sta abst,x 
                                set_stat 0
                       >            load_flag 0
2c48 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2c4a : 48              >            pha         ;use stack to load status
2c4b : 28              >            plp
                        
2c4c : de0302                   dec abst,x
                                tst_absx rINC,fINC,0
2c4f : 08              >            php         ;save flags
2c50 : bd0302          >            lda abst,x
2c53 : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2c56 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2c58 : 68              >            pla         ;load status
                       >            eor_flag 0
2c59 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2c5b : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2c5e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2c60 : bd0302                   lda abst,x
2c63 : ca                       dex
2c64 : 3008                     bmi tdec7
2c66 : e001                     cpx #1
2c68 : d0db                     bne tdec6
2c6a : a981                     lda #$81
2c6c : d0d7                     bne tdec6
2c6e :                  tdec7
2c6e : a200                     ldx #0
2c70 : a97e                     lda #$7e
2c72 : 9d0302           tinc16  sta abst,x
                                set_stat $ff
                       >            load_flag $ff
2c75 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2c77 : 48              >            pha         ;use stack to load status
2c78 : 28              >            plp
                        
2c79 : fe0302                   inc abst,x
                                tst_absx rINC,fINC,$ff-fnz
2c7c : 08              >            php         ;save flags
2c7d : bd0302          >            lda abst,x
2c80 : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2c83 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2c85 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2c86 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2c88 : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2c8b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2c8d : bd0302                   lda abst,x
2c90 : e8                       inx
2c91 : e002                     cpx #2
2c93 : d002                     bne tinc17
2c95 : a9fe                     lda #$fe
2c97 : e005             tinc17  cpx #5
2c99 : d0d7                     bne tinc16
2c9b : ca                       dex
2c9c : a902                     lda #2
2c9e : 9d0302           tdec16  sta abst,x 
                                set_stat $ff
                       >            load_flag $ff
2ca1 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2ca3 : 48              >            pha         ;use stack to load status
2ca4 : 28              >            plp
                        
2ca5 : de0302                   dec abst,x
                                tst_absx rINC,fINC,$ff-fnz
2ca8 : 08              >            php         ;save flags
2ca9 : bd0302          >            lda abst,x
2cac : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2caf : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2cb1 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2cb2 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2cb4 : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2cb7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2cb9 : bd0302                   lda abst,x
2cbc : ca                       dex
2cbd : 3008                     bmi tdec17
2cbf : e001                     cpx #1
2cc1 : d0db                     bne tdec16
2cc3 : a981                     lda #$81
2cc5 : d0d7                     bne tdec16
2cc7 :                  tdec17
                                next_test
2cc7 : ad0002          >            lda test_case   ;previous test
2cca : c925            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2ccc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0026 =                 >test_num = test_num + 1
2cce : a926            >            lda #test_num   ;*** next tests' number
2cd0 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing logical instructions - AND EOR ORA all addressing modes
                        ; AND
2cd3 : a203                     ldx #3          ;immediate
2cd5 : b512             tand    lda zpAN,x
2cd7 : 8d0902                   sta ex_andi+1   ;set AND # operand
                                set_ax  absANa,0
                       >            load_flag 0
2cda : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2cdc : 48              >            pha         ;use stack to load status
2cdd : bd5a02          >            lda absANa,x    ;precharge accu
2ce0 : 28              >            plp
                        
2ce1 : 200802                   jsr ex_andi     ;execute AND # in RAM
                                tst_ax  absrlo,absflo,0
2ce4 : 08              >            php         ;save flags
2ce5 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2ce8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2cea : 68              >            pla         ;load status
                       >            eor_flag 0
2ceb : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2ced : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2cf0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2cf2 : ca                       dex
2cf3 : 10e0                     bpl tand
2cf5 : a203                     ldx #3
2cf7 : b512             tand1   lda zpAN,x
2cf9 : 8d0902                   sta ex_andi+1   ;set AND # operand
                                set_ax  absANa,$ff
                       >            load_flag $ff
2cfc : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2cfe : 48              >            pha         ;use stack to load status
2cff : bd5a02          >            lda absANa,x    ;precharge accu
2d02 : 28              >            plp
                        
2d03 : 200802                   jsr ex_andi     ;execute AND # in RAM
                                tst_ax  absrlo,absflo,$ff-fnz
2d06 : 08              >            php         ;save flags
2d07 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2d0a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2d0c : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2d0d : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2d0f : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2d12 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2d14 : ca                       dex
2d15 : 10e0                     bpl tand1
                            
2d17 : a203                     ldx #3      ;zp
2d19 : b512             tand2   lda zpAN,x
2d1b : 8502                     sta zpt
                                set_ax  absANa,0
                       >            load_flag 0
2d1d : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2d1f : 48              >            pha         ;use stack to load status
2d20 : bd5a02          >            lda absANa,x    ;precharge accu
2d23 : 28              >            plp
                        
2d24 : 2502                     and zpt
                                tst_ax  absrlo,absflo,0
2d26 : 08              >            php         ;save flags
2d27 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2d2a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2d2c : 68              >            pla         ;load status
                       >            eor_flag 0
2d2d : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2d2f : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2d32 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2d34 : ca                       dex
2d35 : 10e2                     bpl tand2
2d37 : a203                     ldx #3
2d39 : b512             tand3   lda zpAN,x
2d3b : 8502                     sta zpt
                                set_ax  absANa,$ff
                       >            load_flag $ff
2d3d : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2d3f : 48              >            pha         ;use stack to load status
2d40 : bd5a02          >            lda absANa,x    ;precharge accu
2d43 : 28              >            plp
                        
2d44 : 2502                     and zpt
                                tst_ax  absrlo,absflo,$ff-fnz
2d46 : 08              >            php         ;save flags
2d47 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2d4a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2d4c : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2d4d : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2d4f : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2d52 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2d54 : ca                       dex
2d55 : 10e2                     bpl tand3
                        
2d57 : a203                     ldx #3      ;abs
2d59 : b512             tand4   lda zpAN,x
2d5b : 8d0302                   sta abst
                                set_ax  absANa,0
                       >            load_flag 0
2d5e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2d60 : 48              >            pha         ;use stack to load status
2d61 : bd5a02          >            lda absANa,x    ;precharge accu
2d64 : 28              >            plp
                        
2d65 : 2d0302                   and abst
                                tst_ax  absrlo,absflo,0
2d68 : 08              >            php         ;save flags
2d69 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2d6c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2d6e : 68              >            pla         ;load status
                       >            eor_flag 0
2d6f : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2d71 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2d74 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2d76 : ca                       dex
2d77 : 10e0                     bpl tand4
2d79 : a203                     ldx #3
2d7b : b512             tand5   lda zpAN,x
2d7d : 8d0302                   sta abst
                                set_ax  absANa,$ff
                       >            load_flag $ff
2d80 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2d82 : 48              >            pha         ;use stack to load status
2d83 : bd5a02          >            lda absANa,x    ;precharge accu
2d86 : 28              >            plp
                        
2d87 : 2d0302                   and abst
                                tst_ax  absrlo,absflo,$ff-fnz
2d8a : 08              >            php         ;save flags
2d8b : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2d8e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2d90 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2d91 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2d93 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2d96 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2d98 : ca                       dex
2d99 : 1002                     bpl tand6
                        
2d9b : a203                     ldx #3      ;zp,x
2d9d :                  tand6
                                set_ax  absANa,0
                       >            load_flag 0
2d9d : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2d9f : 48              >            pha         ;use stack to load status
2da0 : bd5a02          >            lda absANa,x    ;precharge accu
2da3 : 28              >            plp
                        
2da4 : 3512                     and zpAN,x
                                tst_ax  absrlo,absflo,0
2da6 : 08              >            php         ;save flags
2da7 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2daa : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2dac : 68              >            pla         ;load status
                       >            eor_flag 0
2dad : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2daf : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2db2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2db4 : ca                       dex
2db5 : 10e6                     bpl tand6
2db7 : a203                     ldx #3
2db9 :                  tand7
                                set_ax  absANa,$ff
                       >            load_flag $ff
2db9 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2dbb : 48              >            pha         ;use stack to load status
2dbc : bd5a02          >            lda absANa,x    ;precharge accu
2dbf : 28              >            plp
                        
2dc0 : 3512                     and zpAN,x
                                tst_ax  absrlo,absflo,$ff-fnz
2dc2 : 08              >            php         ;save flags
2dc3 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2dc6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2dc8 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2dc9 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2dcb : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2dce : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2dd0 : ca                       dex
2dd1 : 10e6                     bpl tand7
                        
2dd3 : a203                     ldx #3      ;abs,x
2dd5 :                  tand8
                                set_ax  absANa,0
                       >            load_flag 0
2dd5 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2dd7 : 48              >            pha         ;use stack to load status
2dd8 : bd5a02          >            lda absANa,x    ;precharge accu
2ddb : 28              >            plp
                        
2ddc : 3d4e02                   and absAN,x
                                tst_ax  absrlo,absflo,0
2ddf : 08              >            php         ;save flags
2de0 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2de3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2de5 : 68              >            pla         ;load status
                       >            eor_flag 0
2de6 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2de8 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2deb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2ded : ca                       dex
2dee : 10e5                     bpl tand8
2df0 : a203                     ldx #3
2df2 :                  tand9
                                set_ax  absANa,$ff
                       >            load_flag $ff
2df2 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2df4 : 48              >            pha         ;use stack to load status
2df5 : bd5a02          >            lda absANa,x    ;precharge accu
2df8 : 28              >            plp
                        
2df9 : 3d4e02                   and absAN,x
                                tst_ax  absrlo,absflo,$ff-fnz
2dfc : 08              >            php         ;save flags
2dfd : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2e00 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2e02 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2e03 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2e05 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2e08 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2e0a : ca                       dex
2e0b : 10e5                     bpl tand9
                        
2e0d : a003                     ldy #3      ;abs,y
2e0f :                  tand10
                                set_ay  absANa,0
                       >            load_flag 0
2e0f : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2e11 : 48              >            pha         ;use stack to load status
2e12 : b95a02          >            lda absANa,y    ;precharge accu
2e15 : 28              >            plp
                        
2e16 : 394e02                   and absAN,y
                                tst_ay  absrlo,absflo,0
2e19 : 08              >            php         ;save flags
2e1a : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
2e1d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2e1f : 68              >            pla         ;load status
                       >            eor_flag 0
2e20 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2e22 : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
2e25 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2e27 : 88                       dey
2e28 : 10e5                     bpl tand10
2e2a : a003                     ldy #3
2e2c :                  tand11
                                set_ay  absANa,$ff
                       >            load_flag $ff
2e2c : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2e2e : 48              >            pha         ;use stack to load status
2e2f : b95a02          >            lda absANa,y    ;precharge accu
2e32 : 28              >            plp
                        
2e33 : 394e02                   and absAN,y
                                tst_ay  absrlo,absflo,$ff-fnz
2e36 : 08              >            php         ;save flags
2e37 : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
2e3a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2e3c : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2e3d : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2e3f : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
2e42 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2e44 : 88                       dey
2e45 : 10e5                     bpl tand11
                        
2e47 : a206                     ldx #6      ;(zp,x)
2e49 : a003                     ldy #3
2e4b :                  tand12
                                set_ay  absANa,0
                       >            load_flag 0
2e4b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2e4d : 48              >            pha         ;use stack to load status
2e4e : b95a02          >            lda absANa,y    ;precharge accu
2e51 : 28              >            plp
                        
2e52 : 2130                     and (indAN,x)
                                tst_ay  absrlo,absflo,0
2e54 : 08              >            php         ;save flags
2e55 : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
2e58 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2e5a : 68              >            pla         ;load status
                       >            eor_flag 0
2e5b : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2e5d : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
2e60 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2e62 : ca                       dex
2e63 : ca                       dex
2e64 : 88                       dey
2e65 : 10e4                     bpl tand12
2e67 : a206                     ldx #6
2e69 : a003                     ldy #3
2e6b :                  tand13
                                set_ay  absANa,$ff
                       >            load_flag $ff
2e6b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2e6d : 48              >            pha         ;use stack to load status
2e6e : b95a02          >            lda absANa,y    ;precharge accu
2e71 : 28              >            plp
                        
2e72 : 2130                     and (indAN,x)
                                tst_ay  absrlo,absflo,$ff-fnz
2e74 : 08              >            php         ;save flags
2e75 : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
2e78 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2e7a : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2e7b : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2e7d : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
2e80 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2e82 : ca                       dex
2e83 : ca                       dex
2e84 : 88                       dey
2e85 : 10e4                     bpl tand13
                        
2e87 : a003                     ldy #3      ;(zp),y
2e89 :                  tand14
                                set_ay  absANa,0
                       >            load_flag 0
2e89 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2e8b : 48              >            pha         ;use stack to load status
2e8c : b95a02          >            lda absANa,y    ;precharge accu
2e8f : 28              >            plp
                        
2e90 : 3130                     and (indAN),y
                                tst_ay  absrlo,absflo,0
2e92 : 08              >            php         ;save flags
2e93 : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
2e96 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2e98 : 68              >            pla         ;load status
                       >            eor_flag 0
2e99 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2e9b : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
2e9e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2ea0 : 88                       dey
2ea1 : 10e6                     bpl tand14
2ea3 : a003                     ldy #3
2ea5 :                  tand15
                                set_ay  absANa,$ff
                       >            load_flag $ff
2ea5 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2ea7 : 48              >            pha         ;use stack to load status
2ea8 : b95a02          >            lda absANa,y    ;precharge accu
2eab : 28              >            plp
                        
2eac : 3130                     and (indAN),y
                                tst_ay  absrlo,absflo,$ff-fnz
2eae : 08              >            php         ;save flags
2eaf : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
2eb2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2eb4 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2eb5 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2eb7 : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
2eba : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2ebc : 88                       dey
2ebd : 10e6                     bpl tand15
                                next_test
2ebf : ad0002          >            lda test_case   ;previous test
2ec2 : c926            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2ec4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0027 =                 >test_num = test_num + 1
2ec6 : a927            >            lda #test_num   ;*** next tests' number
2ec8 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; EOR
2ecb : a203                     ldx #3          ;immediate - self modifying code
2ecd : b516             teor    lda zpEO,x
2ecf : 8d0c02                   sta ex_eori+1   ;set EOR # operand
                                set_ax  absEOa,0
                       >            load_flag 0
2ed2 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2ed4 : 48              >            pha         ;use stack to load status
2ed5 : bd5e02          >            lda absEOa,x    ;precharge accu
2ed8 : 28              >            plp
                        
2ed9 : 200b02                   jsr ex_eori     ;execute EOR # in RAM
                                tst_ax  absrlo,absflo,0
2edc : 08              >            php         ;save flags
2edd : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2ee0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2ee2 : 68              >            pla         ;load status
                       >            eor_flag 0
2ee3 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2ee5 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2ee8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2eea : ca                       dex
2eeb : 10e0                     bpl teor
2eed : a203                     ldx #3
2eef : b516             teor1   lda zpEO,x
2ef1 : 8d0c02                   sta ex_eori+1   ;set EOR # operand
                                set_ax  absEOa,$ff
                       >            load_flag $ff
2ef4 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2ef6 : 48              >            pha         ;use stack to load status
2ef7 : bd5e02          >            lda absEOa,x    ;precharge accu
2efa : 28              >            plp
                        
2efb : 200b02                   jsr ex_eori     ;execute EOR # in RAM
                                tst_ax  absrlo,absflo,$ff-fnz
2efe : 08              >            php         ;save flags
2eff : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2f02 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2f04 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2f05 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2f07 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2f0a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2f0c : ca                       dex
2f0d : 10e0                     bpl teor1
                            
2f0f : a203                     ldx #3      ;zp
2f11 : b516             teor2    lda zpEO,x
2f13 : 8502                     sta zpt
                                set_ax  absEOa,0
                       >            load_flag 0
2f15 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2f17 : 48              >            pha         ;use stack to load status
2f18 : bd5e02          >            lda absEOa,x    ;precharge accu
2f1b : 28              >            plp
                        
2f1c : 4502                     eor zpt
                                tst_ax  absrlo,absflo,0
2f1e : 08              >            php         ;save flags
2f1f : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2f22 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2f24 : 68              >            pla         ;load status
                       >            eor_flag 0
2f25 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2f27 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2f2a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2f2c : ca                       dex
2f2d : 10e2                     bpl teor2
2f2f : a203                     ldx #3
2f31 : b516             teor3   lda zpEO,x
2f33 : 8502                     sta zpt
                                set_ax  absEOa,$ff
                       >            load_flag $ff
2f35 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2f37 : 48              >            pha         ;use stack to load status
2f38 : bd5e02          >            lda absEOa,x    ;precharge accu
2f3b : 28              >            plp
                        
2f3c : 4502                     eor zpt
                                tst_ax  absrlo,absflo,$ff-fnz
2f3e : 08              >            php         ;save flags
2f3f : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2f42 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2f44 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2f45 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2f47 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2f4a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2f4c : ca                       dex
2f4d : 10e2                     bpl teor3
                        
2f4f : a203                     ldx #3      ;abs
2f51 : b516             teor4   lda zpEO,x
2f53 : 8d0302                   sta abst
                                set_ax  absEOa,0
                       >            load_flag 0
2f56 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2f58 : 48              >            pha         ;use stack to load status
2f59 : bd5e02          >            lda absEOa,x    ;precharge accu
2f5c : 28              >            plp
                        
2f5d : 4d0302                   eor abst
                                tst_ax  absrlo,absflo,0
2f60 : 08              >            php         ;save flags
2f61 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2f64 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2f66 : 68              >            pla         ;load status
                       >            eor_flag 0
2f67 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2f69 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2f6c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2f6e : ca                       dex
2f6f : 10e0                     bpl teor4
2f71 : a203                     ldx #3
2f73 : b516             teor5   lda zpEO,x
2f75 : 8d0302                   sta abst
                                set_ax  absEOa,$ff
                       >            load_flag $ff
2f78 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2f7a : 48              >            pha         ;use stack to load status
2f7b : bd5e02          >            lda absEOa,x    ;precharge accu
2f7e : 28              >            plp
                        
2f7f : 4d0302                   eor abst
                                tst_ax  absrlo,absflo,$ff-fnz
2f82 : 08              >            php         ;save flags
2f83 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2f86 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2f88 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2f89 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2f8b : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2f8e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2f90 : ca                       dex
2f91 : 1002                     bpl teor6
                        
2f93 : a203                     ldx #3      ;zp,x
2f95 :                  teor6
                                set_ax  absEOa,0
                       >            load_flag 0
2f95 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2f97 : 48              >            pha         ;use stack to load status
2f98 : bd5e02          >            lda absEOa,x    ;precharge accu
2f9b : 28              >            plp
                        
2f9c : 5516                     eor zpEO,x
                                tst_ax  absrlo,absflo,0
2f9e : 08              >            php         ;save flags
2f9f : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2fa2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2fa4 : 68              >            pla         ;load status
                       >            eor_flag 0
2fa5 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2fa7 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2faa : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2fac : ca                       dex
2fad : 10e6                     bpl teor6
2faf : a203                     ldx #3
2fb1 :                  teor7
                                set_ax  absEOa,$ff
                       >            load_flag $ff
2fb1 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2fb3 : 48              >            pha         ;use stack to load status
2fb4 : bd5e02          >            lda absEOa,x    ;precharge accu
2fb7 : 28              >            plp
                        
2fb8 : 5516                     eor zpEO,x
                                tst_ax  absrlo,absflo,$ff-fnz
2fba : 08              >            php         ;save flags
2fbb : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2fbe : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2fc0 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2fc1 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2fc3 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2fc6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2fc8 : ca                       dex
2fc9 : 10e6                     bpl teor7
                        
2fcb : a203                     ldx #3      ;abs,x
2fcd :                  teor8
                                set_ax  absEOa,0
                       >            load_flag 0
2fcd : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2fcf : 48              >            pha         ;use stack to load status
2fd0 : bd5e02          >            lda absEOa,x    ;precharge accu
2fd3 : 28              >            plp
                        
2fd4 : 5d5202                   eor absEO,x
                                tst_ax  absrlo,absflo,0
2fd7 : 08              >            php         ;save flags
2fd8 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2fdb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2fdd : 68              >            pla         ;load status
                       >            eor_flag 0
2fde : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2fe0 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2fe3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2fe5 : ca                       dex
2fe6 : 10e5                     bpl teor8
2fe8 : a203                     ldx #3
2fea :                  teor9
                                set_ax  absEOa,$ff
                       >            load_flag $ff
2fea : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2fec : 48              >            pha         ;use stack to load status
2fed : bd5e02          >            lda absEOa,x    ;precharge accu
2ff0 : 28              >            plp
                        
2ff1 : 5d5202                   eor absEO,x
                                tst_ax  absrlo,absflo,$ff-fnz
2ff4 : 08              >            php         ;save flags
2ff5 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2ff8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2ffa : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2ffb : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2ffd : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
3000 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3002 : ca                       dex
3003 : 10e5                     bpl teor9
                        
3005 : a003                     ldy #3      ;abs,y
3007 :                  teor10
                                set_ay  absEOa,0
                       >            load_flag 0
3007 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
3009 : 48              >            pha         ;use stack to load status
300a : b95e02          >            lda absEOa,y    ;precharge accu
300d : 28              >            plp
                        
300e : 595202                   eor absEO,y
                                tst_ay  absrlo,absflo,0
3011 : 08              >            php         ;save flags
3012 : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
3015 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3017 : 68              >            pla         ;load status
                       >            eor_flag 0
3018 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
301a : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
301d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
301f : 88                       dey
3020 : 10e5                     bpl teor10
3022 : a003                     ldy #3
3024 :                  teor11
                                set_ay  absEOa,$ff
                       >            load_flag $ff
3024 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
3026 : 48              >            pha         ;use stack to load status
3027 : b95e02          >            lda absEOa,y    ;precharge accu
302a : 28              >            plp
                        
302b : 595202                   eor absEO,y
                                tst_ay  absrlo,absflo,$ff-fnz
302e : 08              >            php         ;save flags
302f : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
3032 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3034 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
3035 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
3037 : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
303a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
303c : 88                       dey
303d : 10e5                     bpl teor11
                        
303f : a206                     ldx #6      ;(zp,x)
3041 : a003                     ldy #3
3043 :                  teor12
                                set_ay  absEOa,0
                       >            load_flag 0
3043 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
3045 : 48              >            pha         ;use stack to load status
3046 : b95e02          >            lda absEOa,y    ;precharge accu
3049 : 28              >            plp
                        
304a : 4138                     eor (indEO,x)
                                tst_ay  absrlo,absflo,0
304c : 08              >            php         ;save flags
304d : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
3050 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3052 : 68              >            pla         ;load status
                       >            eor_flag 0
3053 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
3055 : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
3058 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
305a : ca                       dex
305b : ca                       dex
305c : 88                       dey
305d : 10e4                     bpl teor12
305f : a206                     ldx #6
3061 : a003                     ldy #3
3063 :                  teor13
                                set_ay  absEOa,$ff
                       >            load_flag $ff
3063 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
3065 : 48              >            pha         ;use stack to load status
3066 : b95e02          >            lda absEOa,y    ;precharge accu
3069 : 28              >            plp
                        
306a : 4138                     eor (indEO,x)
                                tst_ay  absrlo,absflo,$ff-fnz
306c : 08              >            php         ;save flags
306d : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
3070 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3072 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
3073 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
3075 : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
3078 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
307a : ca                       dex
307b : ca                       dex
307c : 88                       dey
307d : 10e4                     bpl teor13
                        
307f : a003                     ldy #3      ;(zp),y
3081 :                  teor14
                                set_ay  absEOa,0
                       >            load_flag 0
3081 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
3083 : 48              >            pha         ;use stack to load status
3084 : b95e02          >            lda absEOa,y    ;precharge accu
3087 : 28              >            plp
                        
3088 : 5138                     eor (indEO),y
                                tst_ay  absrlo,absflo,0
308a : 08              >            php         ;save flags
308b : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
308e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3090 : 68              >            pla         ;load status
                       >            eor_flag 0
3091 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
3093 : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
3096 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3098 : 88                       dey
3099 : 10e6                     bpl teor14
309b : a003                     ldy #3
309d :                  teor15
                                set_ay  absEOa,$ff
                       >            load_flag $ff
309d : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
309f : 48              >            pha         ;use stack to load status
30a0 : b95e02          >            lda absEOa,y    ;precharge accu
30a3 : 28              >            plp
                        
30a4 : 5138                     eor (indEO),y
                                tst_ay  absrlo,absflo,$ff-fnz
30a6 : 08              >            php         ;save flags
30a7 : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
30aa : d0fe            >        bne *           ;failed not equal (non zero)
                       >
30ac : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
30ad : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
30af : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
30b2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
30b4 : 88                       dey
30b5 : 10e6                     bpl teor15
                                next_test
30b7 : ad0002          >            lda test_case   ;previous test
30ba : c927            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
30bc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0028 =                 >test_num = test_num + 1
30be : a928            >            lda #test_num   ;*** next tests' number
30c0 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; OR
30c3 : a203                     ldx #3          ;immediate - self modifying code
30c5 : b50e             tora    lda zpOR,x
30c7 : 8d0f02                   sta ex_orai+1   ;set ORA # operand
                                set_ax  absORa,0
                       >            load_flag 0
30ca : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
30cc : 48              >            pha         ;use stack to load status
30cd : bd5602          >            lda absORa,x    ;precharge accu
30d0 : 28              >            plp
                        
30d1 : 200e02                   jsr ex_orai     ;execute ORA # in RAM
                                tst_ax  absrlo,absflo,0
30d4 : 08              >            php         ;save flags
30d5 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
30d8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
30da : 68              >            pla         ;load status
                       >            eor_flag 0
30db : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
30dd : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
30e0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
30e2 : ca                       dex
30e3 : 10e0                     bpl tora
30e5 : a203                     ldx #3
30e7 : b50e             tora1   lda zpOR,x
30e9 : 8d0f02                   sta ex_orai+1   ;set ORA # operand
                                set_ax  absORa,$ff
                       >            load_flag $ff
30ec : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
30ee : 48              >            pha         ;use stack to load status
30ef : bd5602          >            lda absORa,x    ;precharge accu
30f2 : 28              >            plp
                        
30f3 : 200e02                   jsr ex_orai     ;execute ORA # in RAM
                                tst_ax  absrlo,absflo,$ff-fnz
30f6 : 08              >            php         ;save flags
30f7 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
30fa : d0fe            >        bne *           ;failed not equal (non zero)
                       >
30fc : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
30fd : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
30ff : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
3102 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3104 : ca                       dex
3105 : 10e0                     bpl tora1
                            
3107 : a203                     ldx #3      ;zp
3109 : b50e             tora2   lda zpOR,x
310b : 8502                     sta zpt
                                set_ax  absORa,0
                       >            load_flag 0
310d : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
310f : 48              >            pha         ;use stack to load status
3110 : bd5602          >            lda absORa,x    ;precharge accu
3113 : 28              >            plp
                        
3114 : 0502                     ora zpt
                                tst_ax  absrlo,absflo,0
3116 : 08              >            php         ;save flags
3117 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
311a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
311c : 68              >            pla         ;load status
                       >            eor_flag 0
311d : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
311f : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
3122 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3124 : ca                       dex
3125 : 10e2                     bpl tora2
3127 : a203                     ldx #3
3129 : b50e             tora3   lda zpOR,x
312b : 8502                     sta zpt
                                set_ax  absORa,$ff
                       >            load_flag $ff
312d : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
312f : 48              >            pha         ;use stack to load status
3130 : bd5602          >            lda absORa,x    ;precharge accu
3133 : 28              >            plp
                        
3134 : 0502                     ora zpt
                                tst_ax  absrlo,absflo,$ff-fnz
3136 : 08              >            php         ;save flags
3137 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
313a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
313c : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
313d : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
313f : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
3142 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3144 : ca                       dex
3145 : 10e2                     bpl tora3
                        
3147 : a203                     ldx #3      ;abs
3149 : b50e             tora4   lda zpOR,x
314b : 8d0302                   sta abst
                                set_ax  absORa,0
                       >            load_flag 0
314e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
3150 : 48              >            pha         ;use stack to load status
3151 : bd5602          >            lda absORa,x    ;precharge accu
3154 : 28              >            plp
                        
3155 : 0d0302                   ora abst
                                tst_ax  absrlo,absflo,0
3158 : 08              >            php         ;save flags
3159 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
315c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
315e : 68              >            pla         ;load status
                       >            eor_flag 0
315f : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
3161 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
3164 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3166 : ca                       dex
3167 : 10e0                     bpl tora4
3169 : a203                     ldx #3
316b : b50e             tora5   lda zpOR,x
316d : 8d0302                   sta abst
                                set_ax  absORa,$ff
                       >            load_flag $ff
3170 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
3172 : 48              >            pha         ;use stack to load status
3173 : bd5602          >            lda absORa,x    ;precharge accu
3176 : 28              >            plp
                        
3177 : 0d0302                   ora abst
                                tst_ax  absrlo,absflo,$ff-fnz
317a : 08              >            php         ;save flags
317b : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
317e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3180 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
3181 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
3183 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
3186 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3188 : ca                       dex
3189 : 1002                     bpl tora6
                        
318b : a203                     ldx #3      ;zp,x
318d :                  tora6
                                set_ax  absORa,0
                       >            load_flag 0
318d : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
318f : 48              >            pha         ;use stack to load status
3190 : bd5602          >            lda absORa,x    ;precharge accu
3193 : 28              >            plp
                        
3194 : 150e                     ora zpOR,x
                                tst_ax  absrlo,absflo,0
3196 : 08              >            php         ;save flags
3197 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
319a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
319c : 68              >            pla         ;load status
                       >            eor_flag 0
319d : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
319f : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
31a2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
31a4 : ca                       dex
31a5 : 10e6                     bpl tora6
31a7 : a203                     ldx #3
31a9 :                  tora7
                                set_ax  absORa,$ff
                       >            load_flag $ff
31a9 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
31ab : 48              >            pha         ;use stack to load status
31ac : bd5602          >            lda absORa,x    ;precharge accu
31af : 28              >            plp
                        
31b0 : 150e                     ora zpOR,x
                                tst_ax  absrlo,absflo,$ff-fnz
31b2 : 08              >            php         ;save flags
31b3 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
31b6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
31b8 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
31b9 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
31bb : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
31be : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
31c0 : ca                       dex
31c1 : 10e6                     bpl tora7
                        
31c3 : a203                     ldx #3      ;abs,x
31c5 :                  tora8
                                set_ax  absORa,0
                       >            load_flag 0
31c5 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
31c7 : 48              >            pha         ;use stack to load status
31c8 : bd5602          >            lda absORa,x    ;precharge accu
31cb : 28              >            plp
                        
31cc : 1d4a02                   ora absOR,x
                                tst_ax  absrlo,absflo,0
31cf : 08              >            php         ;save flags
31d0 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
31d3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
31d5 : 68              >            pla         ;load status
                       >            eor_flag 0
31d6 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
31d8 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
31db : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
31dd : ca                       dex
31de : 10e5                     bpl tora8
31e0 : a203                     ldx #3
31e2 :                  tora9
                                set_ax  absORa,$ff
                       >            load_flag $ff
31e2 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
31e4 : 48              >            pha         ;use stack to load status
31e5 : bd5602          >            lda absORa,x    ;precharge accu
31e8 : 28              >            plp
                        
31e9 : 1d4a02                   ora absOR,x
                                tst_ax  absrlo,absflo,$ff-fnz
31ec : 08              >            php         ;save flags
31ed : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
31f0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
31f2 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
31f3 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
31f5 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
31f8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
31fa : ca                       dex
31fb : 10e5                     bpl tora9
                        
31fd : a003                     ldy #3      ;abs,y
31ff :                  tora10
                                set_ay  absORa,0
                       >            load_flag 0
31ff : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
3201 : 48              >            pha         ;use stack to load status
3202 : b95602          >            lda absORa,y    ;precharge accu
3205 : 28              >            plp
                        
3206 : 194a02                   ora absOR,y
                                tst_ay  absrlo,absflo,0
3209 : 08              >            php         ;save flags
320a : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
320d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
320f : 68              >            pla         ;load status
                       >            eor_flag 0
3210 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
3212 : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
3215 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3217 : 88                       dey
3218 : 10e5                     bpl tora10
321a : a003                     ldy #3
321c :                  tora11
                                set_ay  absORa,$ff
                       >            load_flag $ff
321c : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
321e : 48              >            pha         ;use stack to load status
321f : b95602          >            lda absORa,y    ;precharge accu
3222 : 28              >            plp
                        
3223 : 194a02                   ora absOR,y
                                tst_ay  absrlo,absflo,$ff-fnz
3226 : 08              >            php         ;save flags
3227 : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
322a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
322c : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
322d : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
322f : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
3232 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3234 : 88                       dey
3235 : 10e5                     bpl tora11
                        
3237 : a206                     ldx #6      ;(zp,x)
3239 : a003                     ldy #3
323b :                  tora12
                                set_ay  absORa,0
                       >            load_flag 0
323b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
323d : 48              >            pha         ;use stack to load status
323e : b95602          >            lda absORa,y    ;precharge accu
3241 : 28              >            plp
                        
3242 : 0140                     ora (indOR,x)
                                tst_ay  absrlo,absflo,0
3244 : 08              >            php         ;save flags
3245 : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
3248 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
324a : 68              >            pla         ;load status
                       >            eor_flag 0
324b : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
324d : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
3250 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3252 : ca                       dex
3253 : ca                       dex
3254 : 88                       dey
3255 : 10e4                     bpl tora12
3257 : a206                     ldx #6
3259 : a003                     ldy #3
325b :                  tora13
                                set_ay  absORa,$ff
                       >            load_flag $ff
325b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
325d : 48              >            pha         ;use stack to load status
325e : b95602          >            lda absORa,y    ;precharge accu
3261 : 28              >            plp
                        
3262 : 0140                     ora (indOR,x)
                                tst_ay  absrlo,absflo,$ff-fnz
3264 : 08              >            php         ;save flags
3265 : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
3268 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
326a : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
326b : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
326d : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
3270 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3272 : ca                       dex
3273 : ca                       dex
3274 : 88                       dey
3275 : 10e4                     bpl tora13
                        
3277 : a003                     ldy #3      ;(zp),y
3279 :                  tora14
                                set_ay  absORa,0
                       >            load_flag 0
3279 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
327b : 48              >            pha         ;use stack to load status
327c : b95602          >            lda absORa,y    ;precharge accu
327f : 28              >            plp
                        
3280 : 1140                     ora (indOR),y
                                tst_ay  absrlo,absflo,0
3282 : 08              >            php         ;save flags
3283 : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
3286 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3288 : 68              >            pla         ;load status
                       >            eor_flag 0
3289 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
328b : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
328e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3290 : 88                       dey
3291 : 10e6                     bpl tora14
3293 : a003                     ldy #3
3295 :                  tora15
                                set_ay  absORa,$ff
                       >            load_flag $ff
3295 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
3297 : 48              >            pha         ;use stack to load status
3298 : b95602          >            lda absORa,y    ;precharge accu
329b : 28              >            plp
                        
329c : 1140                     ora (indOR),y
                                tst_ay  absrlo,absflo,$ff-fnz
329e : 08              >            php         ;save flags
329f : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
32a2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
32a4 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
32a5 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
32a7 : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
32aa : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
32ac : 88                       dey
32ad : 10e6                     bpl tora15
                            if I_flag = 3
32af : 58                       cli
                            endif                
                                next_test
32b0 : ad0002          >            lda test_case   ;previous test
32b3 : c928            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
32b5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0029 =                 >test_num = test_num + 1
32b7 : a929            >            lda #test_num   ;*** next tests' number
32b9 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; full binary add/subtract test
                        ; iterates through all combinations of operands and carry input
                        ; uses increments/decrements to predict result & result flags
32bc : d8                       cld
32bd : a204                     ldx #ad2        ;for indexed test
32bf : a0ff                     ldy #$ff        ;max range
32c1 : a900                     lda #0          ;start with adding zeroes & no carry
32c3 : 8502                     sta adfc        ;carry in - for diag
32c5 : 8503                     sta ad1         ;operand 1 - accumulator
32c7 : 8504                     sta ad2         ;operand 2 - memory or immediate
32c9 : 8d0302                   sta ada2        ;non zp
32cc : 8505                     sta adrl        ;expected result bits 0-7
32ce : 8506                     sta adrh        ;expected result bit 8 (carry out)
32d0 : a9ff                     lda #$ff        ;complemented operand 2 for subtract
32d2 : 8508                     sta sb2
32d4 : 8d0402                   sta sba2        ;non zp
32d7 : a902                     lda #2          ;expected Z-flag
32d9 : 8507                     sta adrf
32db : 18               tadd    clc             ;test with carry clear
32dc : 202733                   jsr chkadd
32df : e602                     inc adfc        ;now with carry
32e1 : e605                     inc adrl        ;result +1
32e3 : 08                       php             ;save N & Z from low result
32e4 : 08                       php
32e5 : 68                       pla             ;accu holds expected flags
32e6 : 2982                     and #$82        ;mask N & Z
32e8 : 28                       plp
32e9 : d002                     bne tadd1
32eb : e606                     inc adrh        ;result bit 8 - carry
32ed : 0506             tadd1   ora adrh        ;merge C to expected flags
32ef : 8507                     sta adrf        ;save expected flags except overflow
32f1 : 38                       sec             ;test with carry set
32f2 : 202733                   jsr chkadd
32f5 : c602                     dec adfc        ;same for operand +1 but no carry
32f7 : e603                     inc ad1
32f9 : d0e0                     bne tadd        ;iterate op1
32fb : a900                     lda #0          ;preset result to op2 when op1 = 0
32fd : 8506                     sta adrh
32ff : ee0302                   inc ada2
3302 : e604                     inc ad2
3304 : 08                       php             ;save NZ as operand 2 becomes the new result
3305 : 68                       pla
3306 : 2982                     and #$82        ;mask N00000Z0
3308 : 8507                     sta adrf        ;no need to check carry as we are adding to 0
330a : c608                     dec sb2         ;complement subtract operand 2
330c : ce0402                   dec sba2
330f : a504                     lda ad2         
3311 : 8505                     sta adrl
3313 : d0c6                     bne tadd        ;iterate op2
                            if disable_decimal < 1
                                next_test
                        
                        ; decimal add/subtract test
                        ; *** WARNING - tests documented behavior only! ***
                        ;   only valid BCD operands are tested, N V Z flags are ignored
                        ; iterates through all valid combinations of operands and carry input
                        ; uses increments/decrements to predict result & carry flag
                                sed 
                                ldx #ad2        ;for indexed test
                                ldy #$ff        ;max range
                                lda #$99        ;start with adding 99 to 99 with carry
                                sta ad1         ;operand 1 - accumulator
                                sta ad2         ;operand 2 - memory or immediate
                                sta ada2        ;non zp
                                sta adrl        ;expected result bits 0-7
                                lda #1          ;set carry in & out
                                sta adfc        ;carry in - for diag
                                sta adrh        ;expected result bit 8 (carry out)
                                lda #0          ;complemented operand 2 for subtract
                                sta sb2
                                sta sba2        ;non zp
                        tdad    sec             ;test with carry set
                                jsr chkdad
                                dec adfc        ;now with carry clear
                                lda adrl        ;decimal adjust result
                                bne tdad1       ;skip clear carry & preset result 99 (9A-1)
                                dec adrh
                                lda #$99
                                sta adrl
                                bne tdad3
                        tdad1   and #$f         ;lower nibble mask
                                bne tdad2       ;no decimal adjust needed
                                dec adrl        ;decimal adjust (?0-6)
                                dec adrl
                                dec adrl
                                dec adrl
                                dec adrl
                                dec adrl
                        tdad2   dec adrl        ;result -1
                        tdad3   clc             ;test with carry clear
                                jsr chkdad
                                inc adfc        ;same for operand -1 but with carry
                                lda ad1         ;decimal adjust operand 1
                                beq tdad5       ;iterate operand 2
                                and #$f         ;lower nibble mask
                                bne tdad4       ;skip decimal adjust
                                dec ad1         ;decimal adjust (?0-6)
                                dec ad1
                                dec ad1
                                dec ad1
                                dec ad1
                                dec ad1
                        tdad4   dec ad1         ;operand 1 -1
                                jmp tdad        ;iterate op1
                        
                        tdad5   lda #$99        ;precharge op1 max
                                sta ad1
                                lda ad2         ;decimal adjust operand 2
                                beq tdad7       ;end of iteration
                                and #$f         ;lower nibble mask
                                bne tdad6       ;skip decimal adjust
                                dec ad2         ;decimal adjust (?0-6)
                                dec ad2
                                dec ad2
                                dec ad2
                                dec ad2
                                dec ad2
                                inc sb2         ;complemented decimal adjust for subtract (?9+6)
                                inc sb2
                                inc sb2
                                inc sb2
                                inc sb2
                                inc sb2
                        tdad6   dec ad2         ;operand 2 -1
                                inc sb2         ;complemented operand for subtract
                                lda sb2
                                sta sba2        ;copy as non zp operand
                                lda ad2
                                sta ada2        ;copy as non zp operand
                                sta adrl        ;new result since op1+carry=00+carry +op2=op2
                                inc adrh        ;result carry
                                bne tdad        ;iterate op2
                        tdad7
                                next_test
                        
                        ; decimal/binary switch test
                        ; tests CLD, SED, PLP, RTI to properly switch between decimal & binary opcode
                        ;   tables
                                clc
                                cld
                                php
                                lda #$55
                                adc #$55
                                cmp #$aa
                                trap_ne         ;expected binary result after cld
                                clc
                                sed
                                php
                                lda #$55
                                adc #$55
                                cmp #$10
                                trap_ne         ;expected decimal result after sed
                                cld
                                plp
                                lda #$55
                                adc #$55
                                cmp #$10
                                trap_ne         ;expected decimal result after plp D=1
                                plp
                                lda #$55
                                adc #$55
                                cmp #$aa
                                trap_ne         ;expected binary result after plp D=0
                                clc
                                lda #hi bin_rti_ret ;emulated interrupt for rti
                                pha
                                lda #lo bin_rti_ret
                                pha
                                php
                                sed
                                lda #hi dec_rti_ret ;emulated interrupt for rti
                                pha
                                lda #lo dec_rti_ret
                                pha
                                php
                                cld
                                rti
                        dec_rti_ret
                                lda #$55
                                adc #$55
                                cmp #$10
                                trap_ne         ;expected decimal result after rti D=1
                                rti
                        bin_rti_ret        
                                lda #$55
                                adc #$55
                                cmp #$aa
                                trap_ne         ;expected binary result after rti D=0
                            endif
                            
3315 : ad0002                   lda test_case
3318 : c929                     cmp #test_num
                                trap_ne         ;previous test is out of sequence
331a : d0fe            >        bne *           ;failed not equal (non zero)
                        
331c : a9f0                     lda #$f0        ;mark opcode testing complete
331e : 8d0002                   sta test_case
                                
                        ; final RAM integrity test
                        ;   verifies that none of the previous tests has altered RAM outside of the
                        ;   designated write areas.
                                check_ram
                       >            ;RAM check disabled - RAM size not set
                        
                        ; *** DEBUG INFO ***
                        ; to debug checksum errors uncomment check_ram in the next_test macro to
                        ; narrow down the responsible opcode.
                        ; may give false errors when monitor, OS or other background activity is
                        ; allowed during previous tests.
                        
                        
                        ; S U C C E S S ************************************************
                        ; -------------       
                                success         ;if you get here everything went well
3321 : 4c2133          >        jmp *           ;test passed, no errors
                        
                        ; -------------       
                        ; S U C C E S S ************************************************
3324 : 4c0004                   jmp start       ;run again      
                        
                            if disable_decimal < 1
                        ; core subroutine of the decimal add/subtract test
                        ; *** WARNING - tests documented behavior only! ***
                        ;   only valid BCD operands are tested, N V Z flags are ignored
                        ; iterates through all valid combinations of operands and carry input
                        ; uses increments/decrements to predict result & carry flag
                        chkdad
                        ; decimal ADC / SBC zp
                                php             ;save carry for subtract
                                lda ad1
                                adc ad2         ;perform add
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                php             ;save carry for next add
                                lda ad1
                                sbc sb2         ;perform subtract
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad flags
                                plp
                        ; decimal ADC / SBC abs
                                php             ;save carry for subtract
                                lda ad1
                                adc ada2        ;perform add
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                php             ;save carry for next add
                                lda ad1
                                sbc sba2        ;perform subtract
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                        ; decimal ADC / SBC #
                                php             ;save carry for subtract
                                lda ad2
                                sta ex_adci+1   ;set ADC # operand
                                lda ad1
                                jsr ex_adci     ;execute ADC # in RAM
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                php             ;save carry for next add
                                lda sb2
                                sta ex_sbci+1   ;set SBC # operand
                                lda ad1
                                jsr ex_sbci     ;execute SBC # in RAM
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                        ; decimal ADC / SBC zp,x
                                php             ;save carry for subtract
                                lda ad1
                                adc 0,x         ;perform add
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                php             ;save carry for next add
                                lda ad1
                                sbc sb2-ad2,x   ;perform subtract
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                        ; decimal ADC / SBC abs,x
                                php             ;save carry for subtract
                                lda ad1
                                adc ada2-ad2,x  ;perform add
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                php             ;save carry for next add
                                lda ad1
                                sbc sba2-ad2,x  ;perform subtract
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                        ; decimal ADC / SBC abs,y
                                php             ;save carry for subtract
                                lda ad1
                                adc ada2-$ff,y  ;perform add
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                php             ;save carry for next add
                                lda ad1
                                sbc sba2-$ff,y  ;perform subtract
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                        ; decimal ADC / SBC (zp,x)
                                php             ;save carry for subtract
                                lda ad1
                                adc (lo adi2-ad2,x) ;perform add
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                php             ;save carry for next add
                                lda ad1
                                sbc (lo sbi2-ad2,x) ;perform subtract
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                        ; decimal ADC / SBC (abs),y
                                php             ;save carry for subtract
                                lda ad1
                                adc (adiy2),y   ;perform add
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                php             ;save carry for next add
                                lda ad1
                                sbc (sbiy2),y   ;perform subtract
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                rts
                            endif
                        
                        ; core subroutine of the full binary add/subtract test
                        ; iterates through all combinations of operands and carry input
                        ; uses increments/decrements to predict result & result flags
3327 : a507             chkadd  lda adrf        ;add V-flag if overflow
3329 : 2983                     and #$83        ;keep N-----ZC / clear V
332b : 48                       pha
332c : a503                     lda ad1         ;test sign unequal between operands
332e : 4504                     eor ad2
3330 : 300a                     bmi ckad1       ;no overflow possible - operands have different sign
3332 : a503                     lda ad1         ;test sign equal between operands and result
3334 : 4505                     eor adrl
3336 : 1004                     bpl ckad1       ;no overflow occured - operand and result have same sign
3338 : 68                       pla
3339 : 0940                     ora #$40        ;set V
333b : 48                       pha
333c : 68               ckad1   pla
333d : 8507                     sta adrf        ;save expected flags
                        ; binary ADC / SBC zp
333f : 08                       php             ;save carry for subtract
3340 : a503                     lda ad1
3342 : 6504                     adc ad2         ;perform add
3344 : 08                       php          
3345 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
3347 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3349 : 68                       pla             ;check flags
334a : 29c3                     and #$c3        ;mask NV----ZC
334c : c507                     cmp adrf
                                trap_ne         ;bad flags
334e : d0fe            >        bne *           ;failed not equal (non zero)
                        
3350 : 28                       plp
3351 : 08                       php             ;save carry for next add
3352 : a503                     lda ad1
3354 : e508                     sbc sb2         ;perform subtract
3356 : 08                       php          
3357 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
3359 : d0fe            >        bne *           ;failed not equal (non zero)
                        
335b : 68                       pla             ;check flags
335c : 29c3                     and #$c3        ;mask NV----ZC
335e : c507                     cmp adrf
                                trap_ne         ;bad flags
3360 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3362 : 28                       plp
                        ; binary ADC / SBC abs
3363 : 08                       php             ;save carry for subtract
3364 : a503                     lda ad1
3366 : 6d0302                   adc ada2        ;perform add
3369 : 08                       php          
336a : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
336c : d0fe            >        bne *           ;failed not equal (non zero)
                        
336e : 68                       pla             ;check flags
336f : 29c3                     and #$c3        ;mask NV----ZC
3371 : c507                     cmp adrf
                                trap_ne         ;bad flags
3373 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3375 : 28                       plp
3376 : 08                       php             ;save carry for next add
3377 : a503                     lda ad1
3379 : ed0402                   sbc sba2        ;perform subtract
337c : 08                       php          
337d : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
337f : d0fe            >        bne *           ;failed not equal (non zero)
                        
3381 : 68                       pla             ;check flags
3382 : 29c3                     and #$c3        ;mask NV----ZC
3384 : c507                     cmp adrf
                                trap_ne         ;bad flags
3386 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3388 : 28                       plp
                        ; binary ADC / SBC #
3389 : 08                       php             ;save carry for subtract
338a : a504                     lda ad2
338c : 8d1202                   sta ex_adci+1   ;set ADC # operand
338f : a503                     lda ad1
3391 : 201102                   jsr ex_adci     ;execute ADC # in RAM
3394 : 08                       php          
3395 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
3397 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3399 : 68                       pla             ;check flags
339a : 29c3                     and #$c3        ;mask NV----ZC
339c : c507                     cmp adrf
                                trap_ne         ;bad flags
339e : d0fe            >        bne *           ;failed not equal (non zero)
                        
33a0 : 28                       plp
33a1 : 08                       php             ;save carry for next add
33a2 : a508                     lda sb2
33a4 : 8d1502                   sta ex_sbci+1   ;set SBC # operand
33a7 : a503                     lda ad1
33a9 : 201402                   jsr ex_sbci     ;execute SBC # in RAM
33ac : 08                       php          
33ad : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
33af : d0fe            >        bne *           ;failed not equal (non zero)
                        
33b1 : 68                       pla             ;check flags
33b2 : 29c3                     and #$c3        ;mask NV----ZC
33b4 : c507                     cmp adrf
                                trap_ne         ;bad flags
33b6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
33b8 : 28                       plp
                        ; binary ADC / SBC zp,x
33b9 : 08                       php             ;save carry for subtract
33ba : a503                     lda ad1
33bc : 7500                     adc 0,x         ;perform add
33be : 08                       php          
33bf : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
33c1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
33c3 : 68                       pla             ;check flags
33c4 : 29c3                     and #$c3        ;mask NV----ZC
33c6 : c507                     cmp adrf
                                trap_ne         ;bad flags
33c8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
33ca : 28                       plp
33cb : 08                       php             ;save carry for next add
33cc : a503                     lda ad1
33ce : f504                     sbc sb2-ad2,x   ;perform subtract
33d0 : 08                       php          
33d1 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
33d3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
33d5 : 68                       pla             ;check flags
33d6 : 29c3                     and #$c3        ;mask NV----ZC
33d8 : c507                     cmp adrf
                                trap_ne         ;bad flags
33da : d0fe            >        bne *           ;failed not equal (non zero)
                        
33dc : 28                       plp
                        ; binary ADC / SBC abs,x
33dd : 08                       php             ;save carry for subtract
33de : a503                     lda ad1
33e0 : 7dff01                   adc ada2-ad2,x  ;perform add
33e3 : 08                       php          
33e4 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
33e6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
33e8 : 68                       pla             ;check flags
33e9 : 29c3                     and #$c3        ;mask NV----ZC
33eb : c507                     cmp adrf
                                trap_ne         ;bad flags
33ed : d0fe            >        bne *           ;failed not equal (non zero)
                        
33ef : 28                       plp
33f0 : 08                       php             ;save carry for next add
33f1 : a503                     lda ad1
33f3 : fd0002                   sbc sba2-ad2,x  ;perform subtract
33f6 : 08                       php          
33f7 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
33f9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
33fb : 68                       pla             ;check flags
33fc : 29c3                     and #$c3        ;mask NV----ZC
33fe : c507                     cmp adrf
                                trap_ne         ;bad flags
3400 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3402 : 28                       plp
                        ; binary ADC / SBC abs,y
3403 : 08                       php             ;save carry for subtract
3404 : a503                     lda ad1
3406 : 790401                   adc ada2-$ff,y  ;perform add
3409 : 08                       php          
340a : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
340c : d0fe            >        bne *           ;failed not equal (non zero)
                        
340e : 68                       pla             ;check flags
340f : 29c3                     and #$c3        ;mask NV----ZC
3411 : c507                     cmp adrf
                                trap_ne         ;bad flags
3413 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3415 : 28                       plp
3416 : 08                       php             ;save carry for next add
3417 : a503                     lda ad1
3419 : f90501                   sbc sba2-$ff,y  ;perform subtract
341c : 08                       php          
341d : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
341f : d0fe            >        bne *           ;failed not equal (non zero)
                        
3421 : 68                       pla             ;check flags
3422 : 29c3                     and #$c3        ;mask NV----ZC
3424 : c507                     cmp adrf
                                trap_ne         ;bad flags
3426 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3428 : 28                       plp
                        ; binary ADC / SBC (zp,x)
3429 : 08                       php             ;save carry for subtract
342a : a503                     lda ad1
342c : 6144                     adc (lo adi2-ad2,x) ;perform add
342e : 08                       php          
342f : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
3431 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3433 : 68                       pla             ;check flags
3434 : 29c3                     and #$c3        ;mask NV----ZC
3436 : c507                     cmp adrf
                                trap_ne         ;bad flags
3438 : d0fe            >        bne *           ;failed not equal (non zero)
                        
343a : 28                       plp
343b : 08                       php             ;save carry for next add
343c : a503                     lda ad1
343e : e146                     sbc (lo sbi2-ad2,x) ;perform subtract
3440 : 08                       php          
3441 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
3443 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3445 : 68                       pla             ;check flags
3446 : 29c3                     and #$c3        ;mask NV----ZC
3448 : c507                     cmp adrf
                                trap_ne         ;bad flags
344a : d0fe            >        bne *           ;failed not equal (non zero)
                        
344c : 28                       plp
                        ; binary ADC / SBC (abs),y
344d : 08                       php             ;save carry for subtract
344e : a503                     lda ad1
3450 : 714c                     adc (adiy2),y   ;perform add
3452 : 08                       php          
3453 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
3455 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3457 : 68                       pla             ;check flags
3458 : 29c3                     and #$c3        ;mask NV----ZC
345a : c507                     cmp adrf
                                trap_ne         ;bad flags
345c : d0fe            >        bne *           ;failed not equal (non zero)
                        
345e : 28                       plp
345f : 08                       php             ;save carry for next add
3460 : a503                     lda ad1
3462 : f14e                     sbc (sbiy2),y   ;perform subtract
3464 : 08                       php          
3465 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
3467 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3469 : 68                       pla             ;check flags
346a : 29c3                     and #$c3        ;mask NV----ZC
346c : c507                     cmp adrf
                                trap_ne         ;bad flags
346e : d0fe            >        bne *           ;failed not equal (non zero)
                        
3470 : 28                       plp
3471 : 60                       rts
                        
                        ; target for the jump absolute test
3472 : 88                       dey
3473 : 88                       dey
3474 :                  test_far
3474 : 08                       php             ;either SP or Y count will fail, if we do not hit
3475 : 88                       dey
3476 : 88                       dey
3477 : 88                       dey
3478 : 28                       plp
                                trap_cs         ;flags loaded?
3479 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_vs
347b : 70fe            >        bvs *           ;failed overflow set
                        
                                trap_mi
347d : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
                                trap_eq 
347f : f0fe            >        beq *           ;failed equal (zero)
                        
3481 : c946                     cmp #'F'        ;registers loaded?
                                trap_ne
3483 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3485 : e041                     cpx #'A'
                                trap_ne        
3487 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3489 : c04f                     cpy #('R'-3)
                                trap_ne
348b : d0fe            >        bne *           ;failed not equal (non zero)
                        
348d : 48                       pha             ;save a,x
348e : 8a                       txa
348f : 48                       pha
3490 : ba                       tsx
3491 : e0fd                     cpx #$fd        ;check SP
                                trap_ne
3493 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3495 : 68                       pla             ;restore x
3496 : aa                       tax
                                set_stat $ff
                       >            load_flag $ff
3497 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
3499 : 48              >            pha         ;use stack to load status
349a : 28              >            plp
                        
349b : 68                       pla             ;restore a
349c : e8                       inx             ;return registers with modifications
349d : 49aa                     eor #$aa        ;N=1, V=1, Z=0, C=1
349f : 4c0f09                   jmp far_ret
                                
                        ; target for the jump indirect test
                                align
34a2 : ab34             ptr_tst_ind dw test_ind
34a4 : 6409             ptr_ind_ret dw ind_ret
                                trap            ;runover protection
34a6 : 4ca634          >        jmp *           ;failed anyway
                        
34a9 : 88                       dey
34aa : 88                       dey
34ab :                  test_ind
34ab : 08                       php             ;either SP or Y count will fail, if we do not hit
34ac : 88                       dey
34ad : 88                       dey
34ae : 88                       dey
34af : 28                       plp
                                trap_cs         ;flags loaded?
34b0 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_vs
34b2 : 70fe            >        bvs *           ;failed overflow set
                        
                                trap_mi
34b4 : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
                                trap_eq 
34b6 : f0fe            >        beq *           ;failed equal (zero)
                        
34b8 : c949                     cmp #'I'        ;registers loaded?
                                trap_ne
34ba : d0fe            >        bne *           ;failed not equal (non zero)
                        
34bc : e04e                     cpx #'N'
                                trap_ne        
34be : d0fe            >        bne *           ;failed not equal (non zero)
                        
34c0 : c041                     cpy #('D'-3)
                                trap_ne
34c2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
34c4 : 48                       pha             ;save a,x
34c5 : 8a                       txa
34c6 : 48                       pha
34c7 : ba                       tsx
34c8 : e0fd                     cpx #$fd        ;check SP
                                trap_ne
34ca : d0fe            >        bne *           ;failed not equal (non zero)
                        
34cc : 68                       pla             ;restore x
34cd : aa                       tax
                                set_stat $ff
                       >            load_flag $ff
34ce : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
34d0 : 48              >            pha         ;use stack to load status
34d1 : 28              >            plp
                        
34d2 : 68                       pla             ;restore a
34d3 : e8                       inx             ;return registers with modifications
34d4 : 49aa                     eor #$aa        ;N=1, V=1, Z=0, C=1
34d6 : 6ca434                   jmp (ptr_ind_ret)
                                trap            ;runover protection
34d9 : 4cd934          >        jmp *           ;failed anyway
                        
34dc : 4c0004                   jmp start       ;catastrophic error - cannot continue
                        
                        ; target for the jump subroutine test
34df : 88                       dey
34e0 : 88                       dey
34e1 :                  test_jsr
34e1 : 08                       php             ;either SP or Y count will fail, if we do not hit
34e2 : 88                       dey
34e3 : 88                       dey
34e4 : 88                       dey
34e5 : 28                       plp
                                trap_cs         ;flags loaded?
34e6 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_vs
34e8 : 70fe            >        bvs *           ;failed overflow set
                        
                                trap_mi
34ea : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
                                trap_eq 
34ec : f0fe            >        beq *           ;failed equal (zero)
                        
34ee : c94a                     cmp #'J'        ;registers loaded?
                                trap_ne
34f0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
34f2 : e053                     cpx #'S'
                                trap_ne        
34f4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
34f6 : c04f                     cpy #('R'-3)
                                trap_ne
34f8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
34fa : 48                       pha             ;save a,x
34fb : 8a                       txa
34fc : 48                       pha       
34fd : ba                       tsx             ;sp -4? (return addr,a,x)
34fe : e0fb                     cpx #$fb
                                trap_ne
3500 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3502 : adff01                   lda $1ff        ;propper return on stack
3505 : c909                     cmp #hi(jsr_ret)
                                trap_ne
3507 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3509 : adfe01                   lda $1fe
350c : c99a                     cmp #lo(jsr_ret)
                                trap_ne
350e : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
3510 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
3512 : 48              >            pha         ;use stack to load status
3513 : 28              >            plp
                        
3514 : 68                       pla             ;pull x,a
3515 : aa                       tax
3516 : 68                       pla
3517 : e8                       inx             ;return registers with modifications
3518 : 49aa                     eor #$aa        ;N=1, V=1, Z=0, C=1
351a : 60                       rts
                                trap            ;runover protection
351b : 4c1b35          >        jmp *           ;failed anyway
                        
351e : 4c0004                   jmp start       ;catastrophic error - cannot continue
                                
                        ;trap in case of unexpected IRQ, NMI, BRK, RESET - BRK test target
3521 :                  nmi_trap
                                trap            ;check stack for conditions at NMI
3521 : 4c2135          >        jmp *           ;failed anyway
                        
3524 : 4c0004                   jmp start       ;catastrophic error - cannot continue
3527 :                  res_trap
                                trap            ;unexpected RESET
3527 : 4c2735          >        jmp *           ;failed anyway
                        
352a : 4c0004                   jmp start       ;catastrophic error - cannot continue
                                
352d : 88                       dey
352e : 88                       dey
                            if RTI_test = 1
                        irq_trap                ;BRK test or unextpected BRK or IRQ
                                php             ;either SP or Y count will fail, if we do not hit
                                dey
                                dey
                                dey
                                ;next traps could be caused by unexpected BRK or IRQ
                                ;check stack for BREAK and originating location
                                ;possible jump/branch into weeds (uninitialized space)
                                cmp #$ff-'B'    ;BRK pass 2 registers loaded?
                                beq break2
                                cmp #'B'        ;BRK pass 1 registers loaded?
                                trap_ne
                                cpx #'R'
                                trap_ne        
                                cpy #'K'-3
                                trap_ne
                                sta irq_a       ;save registers during break test
                                stx irq_x
                                tsx             ;test break on stack
                                lda $102,x
                                cmp_flag 0      ;break test should have B=1 & unused=1 on stack
                                trap_ne         ; - no break flag on stack
                                pla
                                cmp_flag intdis ;should have added interrupt disable
                                trap_ne
                                tsx
                                cpx #$fc        ;sp -3? (return addr, flags)
                                trap_ne
                                lda $1ff        ;propper return on stack
                                cmp #hi(brk_ret0)
                                trap_ne
                                lda $1fe
                                cmp #lo(brk_ret0)
                                trap_ne
                                load_flag $ff
                                pha
                                ldx irq_x
                                inx             ;return registers with modifications
                                lda irq_a
                                eor #$aa
                                plp             ;N=1, V=1, Z=1, C=1 but original flags should be restored
                                rti
                                trap            ;runover protection
                                jmp start       ;catastrophic error - cannot continue
                                
                        break2                  ;BRK pass 2        
                                cpx #$ff-'R'
                                trap_ne        
                                cpy #$ff-'K'-3
                                trap_ne
                                sta irq_a       ;save registers during break test
                                stx irq_x
                                tsx             ;test break on stack
                                lda $102,x
                                cmp_flag $ff    ;break test should have B=1
                                trap_ne         ; - no break flag on stack
                                pla
                                ora #decmode    ;ignore decmode cleared if 65c02
                                cmp_flag $ff    ;actual passed flags
                                trap_ne
                                tsx
                                cpx #$fc        ;sp -3? (return addr, flags)
                                trap_ne
                                lda $1ff        ;propper return on stack
                                cmp #hi(brk_ret1)
                                trap_ne
                                lda $1fe
                                cmp #lo(brk_ret1)
                                trap_ne
                                load_flag intdis
                                pha      
                                ldx irq_x
                                inx             ;return registers with modifications
                                lda irq_a
                                eor #$aa
                                plp             ;N=0, V=0, Z=0, C=0 but original flags should be restored
                                rti
                                trap            ;runover protection
                                jmp start       ;catastrophic error - cannot continue
                            endif
                            if report = 1
                                include "report.i65"
                            endif
                                
                        ;copy of data to initialize BSS segment
                            if load_data_direct != 1
                        zp_init
                        zp1_    db  $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
                        zp7f_   db  $7f             ;test pattern for compare
                        ;logical zeropage operands
                        zpOR_   db  0,$1f,$71,$80   ;test pattern for OR
                        zpAN_   db  $0f,$ff,$7f,$80 ;test pattern for AND
                        zpEO_   db  $ff,$0f,$8f,$8f ;test pattern for EOR
                        ;indirect addressing pointers
                        ind1_   dw  abs1            ;indirect pointer to pattern in absolute memory
                                dw  abs1+1
                                dw  abs1+2
                                dw  abs1+3
                                dw  abs7f
                        inw1_   dw  abs1-$f8        ;indirect pointer for wrap-test pattern
                        indt_   dw  abst            ;indirect pointer to store area in absolute memory
                                dw  abst+1
                                dw  abst+2
                                dw  abst+3
                        inwt_   dw  abst-$f8        ;indirect pointer for wrap-test store
                        indAN_  dw  absAN           ;indirect pointer to AND pattern in absolute memory
                                dw  absAN+1
                                dw  absAN+2
                                dw  absAN+3
                        indEO_  dw  absEO           ;indirect pointer to EOR pattern in absolute memory
                                dw  absEO+1
                                dw  absEO+2
                                dw  absEO+3
                        indOR_  dw  absOR           ;indirect pointer to OR pattern in absolute memory
                                dw  absOR+1
                                dw  absOR+2
                                dw  absOR+3
                        ;add/subtract indirect pointers
                        adi2_   dw  ada2            ;indirect pointer to operand 2 in absolute memory
                        sbi2_   dw  sba2            ;indirect pointer to complemented operand 2 (SBC)
                        adiy2_  dw  ada2-$ff        ;with offset for indirect indexed
                        sbiy2_  dw  sba2-$ff
                        zp_end
                            if (zp_end - zp_init) != (zp_bss_end - zp_bss)   
                                ;force assembler error if size is different   
                                ERROR ERROR ERROR   ;mismatch between bss and zeropage data
                            endif 
                        data_init
                        ex_and_ and #0              ;execute immediate opcodes
                                rts
                        ex_eor_ eor #0              ;execute immediate opcodes
                                rts
                        ex_ora_ ora #0              ;execute immediate opcodes
                                rts
                        ex_adc_ adc #0              ;execute immediate opcodes
                                rts
                        ex_sbc_ sbc #0              ;execute immediate opcodes
                                rts
                        abs1_   db  $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
                        abs7f_  db  $7f             ;test pattern for compare
                        ;loads
                        fLDx_   db  fn,fn,0,fz      ;expected flags for load
                        ;shifts
                        rASL_                       ;expected result ASL & ROL -carry
                        rROL_   db  $86,$04,$82,0   ; "
                        rROLc_  db  $87,$05,$83,1   ;expected result ROL +carry
                        rLSR_                       ;expected result LSR & ROR -carry
                        rROR_   db  $61,$41,$20,0   ; "
                        rRORc_  db  $e1,$c1,$a0,$80 ;expected result ROR +carry
                        fASL_                       ;expected flags for shifts
                        fROL_   db  fnc,fc,fn,fz    ;no carry in
                        fROLc_  db  fnc,fc,fn,0     ;carry in
                        fLSR_
                        fROR_   db  fc,0,fc,fz      ;no carry in
                        fRORc_  db  fnc,fn,fnc,fn   ;carry in
                        ;increments (decrements)
                        rINC_   db  $7f,$80,$ff,0,1 ;expected result for INC/DEC
                        fINC_   db  0,fn,fn,fz,0    ;expected flags for INC/DEC
                        ;logical memory operand
                        absOR_  db  0,$1f,$71,$80   ;test pattern for OR
                        absAN_  db  $0f,$ff,$7f,$80 ;test pattern for AND
                        absEO_  db  $ff,$0f,$8f,$8f ;test pattern for EOR
                        ;logical accu operand
                        absORa_ db  0,$f1,$1f,0     ;test pattern for OR
                        absANa_ db  $f0,$ff,$ff,$ff ;test pattern for AND
                        absEOa_ db  $ff,$f0,$f0,$0f ;test pattern for EOR
                        ;logical results
                        absrlo_ db  0,$ff,$7f,$80
                        absflo_ db  fz,fn,0,fn
                        data_end
                            if (data_end - data_init) != (data_bss_end - data_bss)
                                ;force assembler error if size is different   
                                ERROR ERROR ERROR   ;mismatch between bss and data
                            endif 
                        
                        vec_init
                                dw  nmi_trap
                                dw  res_trap
                                dw  irq_trap
                        vec_bss equ $fffa
                            endif                   ;end of RAM init data
                            
                            if (load_data_direct = 1) & (ROM_vectors = 1)  
                                org $fffa       ;vectors
                                dw  nmi_trap
                                dw  res_trap
                                dw  irq_trap
                            endif
                        
3527 =                          end start
                                    
No errors in pass 2.
Wrote binary from address $0000 through $352e.
Total size 13615 bytes.
Program start address is at $0400 (1024).
